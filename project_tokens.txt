/// FILE: Cargo.toml

# crates/sinter/Cargo.toml
[package]
name = "sinter"
version.workspace = true
edition.workspace = true
license.workspace = true
description = "Core engine for sinter"
build = "build.rs"

[features]
default = ["lang-en"]
lang-en = []
lang-zh = []

[build-dependencies]
serde_json = "1"

[dependencies]
anyhow      = { workspace = true }
async-trait = { workspace = true }
clap        = { workspace = true }
tokio       = { workspace = true }
serde       = { workspace = true }
toml_edit   = { workspace = true }
config      = { workspace = true }
dirs        = { workspace = true }
paste       = { workspace = true }
inventory   = { workspace = true }
serde_json  = { workspace = true }
walkdir     = "2"




/// FILE: I18N.md

# 国际化支持

Sinter 使用构建时国际化系统，在编译时生成翻译代码，提供零运行时开销的类型安全翻译。

## 工作原理

1. **翻译文件**: `templates/i18n.json` 包含所有语言的翻译
2. **构建脚本**: `build.rs` 在编译时读取翻译文件并生成 Rust 代码
3. **特性标志**: 通过 Cargo 特性标志选择语言
4. **生成的代码**: 在 `OUT_DIR/i18n.rs` 中生成类型安全的翻译函数

## 使用方法

### 默认构建（英文）

```bash
cargo build
# 或
cargo build --package sinter
```

### 构建中文版本

```bash
cargo build --package sinter --features lang-zh
# 或禁用默认特性，只启用中文
cargo build --package sinter --no-default-features --features lang-zh
```

### 在代码中使用

```rust
use sinter::i18n::{t, tf};

// 简单翻译
println!("{}", t("main_about"));

// 带参数的翻译（使用 {} 占位符）
println!("{}", tf("created_project", &["my-project"]));
```

## 添加新翻译

1. 编辑 `templates/i18n.json`
2. 为每个语言添加对应的键值对
3. 重新构建项目

示例：

```json
{
  "en": {
    "my_new_key": "My new message"
  },
  "zh": {
    "my_new_key": "我的新消息"
  }
}
```

## 添加新语言

1. 在 `templates/i18n.json` 中添加新语言对象
2. 在 `Cargo.toml` 中添加新的特性标志：
   ```toml
   [features]
   lang-ja = []  # 日语
   ```
3. 在 `build.rs` 中添加语言检测逻辑
4. 使用 `--features lang-ja` 构建

## 优势

- ✅ **零运行时开销**: 翻译在编译时确定，无运行时查找
- ✅ **类型安全**: 编译时检查翻译键是否存在
- ✅ **易于维护**: 所有翻译集中在一个 JSON 文件中
- ✅ **多语言构建**: 可以为不同语言构建不同的二进制文件
- ✅ **性能优化**: 字符串字面量直接嵌入二进制文件

## 注意事项

- 翻译文件改变后需要重新构建
- 未找到的翻译键会返回 `"[Translation key not found]"`
- 格式化字符串使用 `{}` 作为占位符，按顺序替换参数

## Rust Analyzer 配置

如果遇到 `OUT_DIR not set` 错误，请确保 rust-analyzer 已配置为运行构建脚本：

在 `.vscode/settings.json` 或 `rust-analyzer` 配置中添加：

```json
{
  "rust-analyzer.cargo.buildScripts.enable": true,
  "rust-analyzer.cargo.buildScripts.useRustcWrapper": true
}
```

或者在项目根目录的 `.cargo/config.toml` 中配置。

**注意**：即使 rust-analyzer 无法运行构建脚本，代码仍然可以正常编译，因为实际构建时 `build.rs` 总是会运行。




/// FILE: bin/README.md

# Coursier 可执行文件

此目录用于存放打包的 `coursier` 可执行文件。

## 如何添加 coursier 可执行文件

### Linux (x86_64)
```bash
curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-pc-linux.gz | gzip -d > coursier
chmod +x coursier
```

### macOS (x86_64)
```bash
curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-apple-darwin.gz | gzip -d > coursier
chmod +x coursier
```

### macOS (ARM64)
```bash
curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-aarch64-apple-darwin.gz | gzip -d > coursier
chmod +x coursier
```

### Windows
下载 `cs-x86_64-pc-win32.zip`，解压后将 `cs.exe` 重命名为 `coursier.exe` 并放入此目录。

## 快速下载

使用提供的脚本自动下载：

```bash
cd crates/sinter-core/bin
./download-coursier.sh
```

## 使用说明

如果此目录中存在 `coursier`（或 `coursier.exe`），sinter 将优先使用打包的版本，而不是系统安装的版本。

查找顺序：
1. **打包的版本**：`<可执行文件目录>/bin/coursier` 或开发时的 `CARGO_MANIFEST_DIR/bin/coursier`
2. **系统命令**：PATH 中的 `coursier` 命令
3. **回退方案**：如果两者都不存在，sinter 会回退到使用 `scala-cli` 进行依赖管理

## 构建时包含

在构建发布版本时，确保将 `bin/coursier` 复制到可执行文件目录的 `bin/` 子目录中，这样打包的版本才能被找到。

例如，如果可执行文件在 `target/release/sinter`，则 coursier 应该在 `target/release/bin/coursier`。




/// FILE: build.rs

use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;

fn main() {
    // 下载 coursier 可执行文件
    download_coursier();

    // 告诉 Cargo 如果翻译文件改变，需要重新构建
    println!("cargo:rerun-if-changed=templates/i18n.json");
    
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let i18n_path = Path::new(&manifest_dir).join("templates/i18n.json");
    
    // 读取翻译文件
    let i18n_content = fs::read_to_string(&i18n_path)
        .expect("Failed to read i18n.json");
    
    let translations: serde_json::Value = serde_json::from_str(&i18n_content)
        .expect("Failed to parse i18n.json");
    
    // 确定当前语言（通过特性标志）
    let lang = if cfg!(feature = "lang-zh") {
        "zh"
    } else {
        "en"
    };
    
    // 获取当前语言的翻译
    let lang_translations = translations.get(lang)
        .and_then(|v| v.as_object())
        .expect(&format!("Language '{}' not found in i18n.json", lang));
    
    // 生成输出目录
    let out_dir = env::var("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir).join("i18n.rs");
    
    // 生成 Rust 代码
    let mut code = String::new();
    code.push_str("// Auto-generated i18n code - DO NOT EDIT\n");
    code.push_str("// This file is generated by build.rs\n\n");
    code.push_str("/// Get a translated string by key\n");
    code.push_str("pub fn t(key: &str) -> &'static str {\n");
    code.push_str("    match key {\n");
    
    // 为每个翻译键生成 match arm
    for (key, value) in lang_translations {
        let value_str = value.as_str().unwrap();
        // 转义字符串中的特殊字符
        let escaped = value_str
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n");
        code.push_str(&format!("        \"{}\" => \"{}\",\n", key, escaped));
    }
    
    // 如果 key 不匹配，返回一个默认消息而不是 key 本身（避免生命周期问题）
    code.push_str("        _ => \"[Translation key not found]\",\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    // 生成格式化函数
    code.push_str("/// Format a translated string with arguments\n");
    code.push_str("pub fn tf(key: &str, args: &[&str]) -> String {\n");
    code.push_str("    let template = t(key);\n");
    code.push_str("    let mut result = template.to_string();\n");
    code.push_str("    for arg in args {\n");
    code.push_str("        if result.contains(\"{}\") {\n");
    code.push_str("            result = result.replacen(\"{}\", arg, 1);\n");
    code.push_str("        } else {\n");
    code.push_str("            break;\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("    result\n");
    code.push_str("}\n");
    
    // 写入文件
    fs::write(&out_path, code)
        .expect("Failed to write generated i18n.rs");

    println!("cargo:warning=Generated i18n.rs for language: {}", lang);
}

/// 下载 coursier 可执行文件
fn download_coursier() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let bin_dir = Path::new(&manifest_dir).join("bin");

    // 确保 bin 目录存在
    if !bin_dir.exists() {
        fs::create_dir_all(&bin_dir).expect("Failed to create bin directory");
    }

    let coursier_path = bin_dir.join(if cfg!(target_os = "windows") { "coursier.exe" } else { "coursier" });

    // 如果 coursier 已经存在，检查是否可用
    if coursier_path.exists() {
        if let Ok(output) = Command::new(&coursier_path).arg("--version").output() {
            if output.status.success() {
                println!("cargo:warning=coursier already exists and is working");
                return;
            }
        }
    }

    // 检测平台
    let platform = match (env::consts::OS, env::consts::ARCH) {
        ("linux", "x86_64") => "x86_64-pc-linux",
        ("linux", "aarch64") => "aarch64-pc-linux",
        ("macos", "x86_64") => "x86_64-apple-darwin",
        ("macos", "aarch64") => "aarch64-apple-darwin",
        _ => {
            println!("cargo:warning=Unsupported platform for coursier download: {} {}", env::consts::OS, env::consts::ARCH);
            return;
        }
    };

    println!("cargo:warning=Downloading coursier for platform: {}", platform);

    // 下载并解压 coursier
    let url = format!("https://github.com/coursier/coursier/releases/latest/download/cs-{}.gz", platform);

    let status = Command::new("sh")
        .args(&["-c", &format!("curl -fL {} | gzip -d > {}", url, coursier_path.display())])
        .status()
        .expect("Failed to download and decompress coursier");

    if !status.success() {
        println!("cargo:warning=Failed to download coursier from {}", url);
        return;
    }

    // 设置执行权限 (Unix only)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&coursier_path).unwrap().permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&coursier_path, perms).unwrap();
    }

    // 设置执行权限 (Unix only)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&coursier_path).unwrap().permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&coursier_path, perms).unwrap();
    }

    // 复制到输出目录的 bin 子目录
    let out_dir = env::var("OUT_DIR").unwrap();
    println!("cargo:warning=OUT_DIR: {}", out_dir);
    let target_dir = Path::new(&out_dir).parent().unwrap().parent().unwrap().parent().unwrap(); // target/release
    println!("cargo:warning=target_dir: {}", target_dir.display());
    let target_bin_dir = target_dir.join("bin");

    if !target_bin_dir.exists() {
        fs::create_dir_all(&target_bin_dir).expect("Failed to create target bin directory");
    }

    let target_coursier_path = target_bin_dir.join(if cfg!(target_os = "windows") { "coursier.exe" } else { "coursier" });
    fs::copy(&coursier_path, &target_coursier_path).expect("Failed to copy coursier to target directory");

    // 设置目标文件的执行权限
    #[cfg(unix)]
    {
        let mut perms = fs::metadata(&target_coursier_path).unwrap().permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&target_coursier_path, perms).unwrap();
    }

    // 验证安装
    if let Ok(output) = Command::new(&target_coursier_path).arg("--version").output() {
        if output.status.success() {
            println!("cargo:warning=Successfully installed coursier");
        } else {
            println!("cargo:warning=Installed coursier but version check failed");
        }
    } else {
        println!("cargo:warning=Failed to verify coursier installation");
    }
}




/// FILE: src/cli/commands/builtin.rs

//! 内置命令实现
//!
//! 包含所有内置命令的执行逻辑

use crate::cli::commands::{Commands, cmd_new, cmd_init, cmd_test, cmd_workspace};
use crate::build::{run_scala_file, run_single_file_with_deps, setup_bsp};
use crate::deps::add_dependency;
use std::path::PathBuf;

/// 执行内置命令
pub async fn execute_command(command: Commands, cwd: &PathBuf) -> anyhow::Result<()> {
    match command {
        Commands::New { name } => {
            cmd_new(cwd, &name).await?;
        }
        Commands::Init => {
            cmd_init(cwd).await?;
        }
        Commands::Workspace { subcommand } => {
            cmd_workspace(cwd, &subcommand).await?;
        }
        Commands::Build => {
            execute_build(cwd).await?;
        }
        Commands::Run { file, lib } => {
            execute_run(cwd, file, lib).await?;
        }
        Commands::Add { deps } => {
            execute_add(cwd, &deps).await?;
        }
        Commands::Test { file } => {
            cmd_test(cwd, file).await?;
        }
        Commands::Jsp { name } => {
            // JSP 命令应该由插件系统处理
            anyhow::bail!("JSP command '{}' requires the JSP plugin to be loaded", name);
        }
    }
    Ok(())
}

/// 执行默认行为（无命令时）
pub async fn execute_default(cwd: &PathBuf) -> anyhow::Result<()> {
    if cwd.join("project.toml").exists() {
        let project = crate::config::load_project(cwd)?;
        let target = crate::config::get_main_file_path(&project);
        if cwd.join(&target).exists() {
            let deps = crate::config::get_dependencies(&project);
            let output = run_single_file_with_deps(cwd, &target, &deps).await?;
            println!("{}", output);
        } else {
            println!(
                "{}",
                crate::i18n::tf("main_file_not_found", &[&target.display().to_string()])
            );
        }
    } else {
        println!("{}", crate::i18n::t("no_command_provided"));
    }
    Ok(())
}

/// 执行构建命令
async fn execute_build(cwd: &PathBuf) -> anyhow::Result<()> {
    if let Ok(project) = crate::config::load_project(cwd) {
        if project.workspace.is_some() {
            // Workspace build - build all members
            let (root_project, members) = crate::config::load_workspace(cwd)?.unwrap();
            let mut all_deps = Vec::new();
            let mut source_dirs = Vec::new();
            let mut backend = None;
            for member in members.iter() {
                let member_dir = cwd.join(&member.package.name);
                let transitive_deps = crate::config::get_transitive_dependencies_with_workspace(&member, Some(&root_project), &member_dir).await?;
                all_deps.extend(transitive_deps.clone());
                source_dirs.push((member.package.name.clone(), member.package.source_dir.clone()));
                if backend.is_none() {
                    backend = Some(member.package.backend.clone());
                }
                // For workspace builds, use target directory relative to workspace root
                let workspace_target_dir = format!(
                    "{}/{}",
                    root_project.package.target_dir, member.package.name
                );
                crate::build::build_with_deps(
                    &member_dir,
                    &transitive_deps,
                    &member.package.source_dir,
                    &workspace_target_dir,
                    &member.package.backend,
                    Some(cwd),
                    false, // Do not setup BSP for each member
                    true, // is_workspace_build
                )
                .await?;
                println!("{}", crate::i18n::tf("built_member", &[&member.package.name]));
            }
            // Setup BSP for the entire workspace
            if let Some(bk) = backend {
                setup_bsp(cwd, &all_deps, &source_dirs, &bk).await?;
            }
            println!("{}", crate::i18n::t("workspace_build_succeeded"));
        } else {
            // Single project or member in workspace
            if let Some(workspace_root) = crate::config::find_workspace_root(cwd) {
                // Build single member in workspace
                let (root_project, members) = crate::config::load_workspace(&workspace_root)?.unwrap();
                let member_name = cwd.strip_prefix(&workspace_root).unwrap().components().next().unwrap().as_os_str().to_str().unwrap();
                if let Some(member) = members.into_iter().find(|m| m.package.name == member_name) {
                    let transitive_deps = crate::config::get_transitive_dependencies_with_workspace(&member, Some(&root_project), cwd).await?;
                    crate::build::build_with_deps(
                        cwd,
                        &transitive_deps,
                        &member.package.source_dir,
                        &member.package.target_dir,
                        &member.package.backend,
                        Some(&workspace_root),
                        true, // Setup BSP for this member
                        false, // not workspace build
                    )
                    .await?;
                    println!(
                        "{}",
                        crate::i18n::tf("build_succeeded_with_deps", &[&transitive_deps.len().to_string()])
                    );
                } else {
                    anyhow::bail!("Member {} not found in workspace", member_name);
                }
            } else {
                // Single project build
                let transitive_deps = crate::config::get_transitive_dependencies_with_workspace(&project, None, cwd).await?;
                crate::build::build_with_deps(
                    cwd,
                    &transitive_deps,
                    &project.package.source_dir,
                    &project.package.target_dir,
                    &project.package.backend,
                    None,
                    true, // Setup BSP for single project
                    false, // not workspace build
                )
                .await?;
                println!(
                    "{}",
                    crate::i18n::tf("build_succeeded_with_deps", &[&transitive_deps.len().to_string()])
                );
            }
        }
    } else {
        anyhow::bail!("No project.toml found in {}", cwd.display());
    }
    Ok(())
}

/// 执行运行命令
async fn execute_run(cwd: &PathBuf, file: Option<PathBuf>, lib: bool) -> anyhow::Result<()> {
    let workspace_root = crate::config::find_workspace_root(cwd);
    let workspace_root_ref = workspace_root.as_ref();

    // 确定项目配置和目录
    let (project, project_dir) = if let Some(ws_root) = workspace_root_ref {
        // 在 workspace 中，查找成员项目
        if let Some((_ws_proj, members)) = crate::config::load_workspace(ws_root)? {
            let member_name = cwd
                .strip_prefix(ws_root)
                .unwrap()
                .components()
                .next()
                .unwrap()
                .as_os_str()
                .to_str()
                .unwrap();
            if let Some(member) = members
                .into_iter()
                .find(|m| m.package.name == member_name)
            {
                (member, ws_root.clone().join(member_name))
            } else {
                // 不是成员，作为单个项目处理
                let proj = crate::config::load_project(cwd)?;
                (proj, cwd.clone())
            }
        } else {
            // 实际上不是 workspace，作为单个项目处理
            let proj = crate::config::load_project(cwd)?;
            (proj, cwd.clone())
        }
    } else {
        let proj = crate::config::load_project(cwd)?;
        (proj, cwd.clone())
    };

    // 获取依赖
    let deps = if let Some(ws_root) = workspace_root_ref {
        let ws_proj = crate::config::load_project(ws_root)?;
        crate::config::get_dependencies_with_workspace(&project, Some(&ws_proj))
    } else {
        crate::config::get_dependencies(&project)
    };

    // 设置 BSP 以支持 IDE
    let bsp_dir = workspace_root_ref.unwrap_or(&project_dir);
    let source_dirs = if let Some(ws_root) = workspace_root_ref {
        let member_name = project_dir.strip_prefix(ws_root).unwrap().to_str().unwrap();
        vec![(member_name.to_string(), project.package.source_dir.clone())]
    } else {
        vec![("".to_string(), project.package.source_dir.clone())]
    };
    setup_bsp(bsp_dir, &deps, &source_dirs, &project.package.backend).await?;

    let target = file.unwrap_or_else(|| crate::config::get_main_file_path(&project));

    if !project_dir.join(&target).exists() {
        anyhow::bail!("File not found: {}", target.display());
    }

    if lib {
        let _ = run_scala_file(&project_dir, &target, true).await?;
        println!(
            "{}",
            crate::i18n::tf("lib_compiled_only", &[&target.display().to_string()])
        );
    } else {
        let output = run_single_file_with_deps(&project_dir, &target, &deps).await?;
        println!("{}", output);
    }

    Ok(())
}

/// 执行添加依赖命令
async fn execute_add(cwd: &PathBuf, deps: &[String]) -> anyhow::Result<()> {
    let workspace_root = crate::config::find_workspace_root(cwd);
    let project_dir = workspace_root.unwrap_or(cwd.clone());
    for dep in deps {
        add_dependency(&project_dir, dep).await?;
    }
    Ok(())
}


/// FILE: src/cli/commands/init.rs

use std::path::PathBuf;

pub async fn cmd_init(cwd: &PathBuf) -> anyhow::Result<()> {
    // Check if project.toml already exists
    let manifest_path = cwd.join("project.toml");
    if manifest_path.exists() {
        anyhow::bail!("{}", crate::i18n::t("config_file_already_exists"));
    }

    // Create workspace project.toml
    let manifest = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/workspace.project.toml.template"));
    tokio::fs::write(manifest_path, manifest).await?;

    println!("{}", crate::i18n::tf("initialized_empty_workspace", &[&cwd.display().to_string()]));
    Ok(())
}


/// FILE: src/cli/commands/mod.rs

// src/cli/commands/mod.rs
pub mod new;
pub mod init;
pub mod test;
pub mod workspace;
pub mod builtin;

// 导出命令函数
pub use new::cmd_new;
pub use init::cmd_init;
pub use test::cmd_test;
pub use workspace::cmd_workspace;
pub use builtin::{execute_command, execute_default};

// 命令枚举定义
#[derive(Debug)]
pub enum Commands {
    New {
        name: String
    },
    Init,
    Build,
    Run {
        file: Option<std::path::PathBuf>,
        lib: bool,
    },
    Add {
        deps: Vec<String>,
    },
    Test {
        file: Option<std::path::PathBuf>,
    },
    Workspace {
        subcommand: WorkspaceCommands,
    },
    Jsp {
        name: String,
    },
}

#[derive(Debug)]
pub enum WorkspaceCommands {
    Add {
        paths: Vec<String>,
    },
}

/// 极致简化的命令定义宏
#[macro_export]
macro_rules! plugin_command {
    ($name:ident, $about:expr, $body:block) => {
        pub struct $name;

        #[async_trait::async_trait]
        impl crate::core::CommandHandler for $name {
            fn name(&self) -> &'static str {
                stringify!($name).to_lowercase().trim_end_matches("command")
            }

            fn about(&self) -> &'static str {
                $about
            }

            async fn execute(&self, matches: &clap::ArgMatches, cwd: &std::path::PathBuf) -> anyhow::Result<()> {
                $body
            }
        }

            inventory::submit! {
            Box::new($name) as Box<dyn crate::core::CommandHandler>
        }
    };
}

/// 超级简单的插件定义宏 - 无需了解内部细节
#[macro_export]
macro_rules! simple_plugin {
    ($cmd_name:literal, $description:literal, $config:expr, $handler:expr) => {
        paste::paste! {
            pub struct [<Simple $cmd_name:camel Plugin>];

            #[async_trait::async_trait]
            impl crate::core::CommandHandler for [<Simple $cmd_name:camel Plugin>] {
                fn name(&self) -> &'static str {
                    $cmd_name
                }

                fn about(&self) -> &'static str {
                    $description
                }

                fn configure(&self, cmd: clap::Command) -> clap::Command {
                    let config_fn = $config;
                    config_fn(cmd.about(self.about()))
                }

                async fn execute(&self, matches: &clap::ArgMatches, cwd: &std::path::PathBuf) -> anyhow::Result<()> {
                    let handler = $handler;
                    handler(matches.clone(), cwd.clone()).await
                }
            }

            // 导出插件结构体供注册使用
            pub use [<Simple $cmd_name:camel Plugin>] as [<plugin_ $cmd_name>];
        }
    };
}


/// FILE: src/cli/commands/new.rs

use std::path::PathBuf;

pub async fn cmd_new(cwd: &PathBuf, name: &str) -> anyhow::Result<()> {
    let proj_dir = cwd.join(name);
    if proj_dir.exists() {
        println!("{}", crate::i18n::tf("project_already_exists", &[name]));
        return Ok(());
    }
    tokio::fs::create_dir_all(proj_dir.join("src/main/scala")).await?;

    // project.toml
    let template = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/project.toml.template"));
    let manifest = template.replace("{name}", name);
    tokio::fs::write(proj_dir.join("project.toml"), manifest).await?;

    // Hello world
    let code = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/main.scala.template"));
    tokio::fs::write(
        proj_dir.join("src/main/scala/Main.scala"),
        code,
    )
    .await?;

    // Auto-add to workspace if in one
    if let Some(workspace_root) = crate::config::find_workspace_root(cwd) {
        let manifest_path = workspace_root.join("project.toml");
        let relative_path = proj_dir.strip_prefix(&workspace_root)
            .unwrap_or(&proj_dir)
            .to_string_lossy()
            .to_string();
        match crate::config::add_workspace_member(&manifest_path, &relative_path) {
            Ok(_) => {
                println!("{}", crate::i18n::tf("added_project_to_workspace", &[name]));
            }
            Err(e) => {
                if !e.to_string().contains("already exists") {
                    eprintln!("Warning: Failed to add project to workspace: {}", e);
                }
            }
        }
    }

    println!("{}", crate::i18n::tf("created_project", &[name]));
    Ok(())
}


/// FILE: src/cli/commands/test.rs

use std::path::PathBuf;
use tokio::process::Command;

pub async fn cmd_test(cwd: &PathBuf, file: Option<PathBuf>) -> anyhow::Result<()> {
    let workspace_root = crate::config::find_workspace_root(cwd);
    let (project, project_dir) = if let Some(ws_root) = workspace_root.as_ref() {
        // In workspace, check if this is a member project
        if let Some((_ws_proj, members)) = crate::config::load_workspace(ws_root)? {
            let relative_path = cwd.strip_prefix(ws_root).unwrap();
            if let Some(first_component) = relative_path.components().next() {
                let member_name = first_component.as_os_str().to_str().unwrap();
                if let Some(member) = members.into_iter().find(|m| m.package.name == member_name) {
                    (member, ws_root.clone().join(member_name))
                } else {
                    // Not a workspace member, treat as standalone project
                    let proj = crate::config::load_project(cwd)?;
                    (proj, cwd.clone())
                }
            } else {
                // cwd == ws_root, treat as standalone project
                let proj = crate::config::load_project(cwd)?;
                (proj, cwd.clone())
            }
        } else {
            // No workspace config, treat as standalone project
            let proj = crate::config::load_project(cwd)?;
            (proj, cwd.clone())
        }
    } else {
        let proj = crate::config::load_project(cwd)?;
        (proj, cwd.clone())
    };

    let deps = if let Some(ws_root) = workspace_root {
        let ws_proj = crate::config::load_project(&ws_root)?;
        crate::config::get_dependencies_with_workspace(&project, Some(&ws_proj))
    } else {
        crate::config::get_dependencies(&project)
    };

    let test_target = if let Some(f) = file {
        f
    } else {
        PathBuf::from(&project.package.test_dir)
    };

    let abs_test_target = project_dir.join(&test_target);

    if !abs_test_target.exists() {
        println!("No tests found in {}", test_target.display());
        return Ok(());
    }

    // Use scala-cli test
    let mut cmd = Command::new("scala-cli");
    cmd.arg("test").arg(&abs_test_target);
    cmd.current_dir(&project_dir);

    for dep in deps {
        cmd.arg("--dependency").arg(dep.coord());
    }

    let output = cmd.output().await?;
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);

    if !stdout.is_empty() {
        println!("{}", stdout);
    }
    if !stderr.is_empty() {
        eprintln!("{}", stderr);
    }

    if !output.status.success() {
        anyhow::bail!("Test failed");
    }

    Ok(())
}


/// FILE: src/cli/commands/workspace.rs

use std::path::PathBuf;

use crate::cli::commands::WorkspaceCommands;

pub async fn cmd_workspace(cwd: &PathBuf, subcommand: &WorkspaceCommands) -> anyhow::Result<()> {
    match subcommand {
        WorkspaceCommands::Add { paths } => {
            cmd_workspace_add(cwd, paths).await?;
        }
    }
    Ok(())
}

async fn cmd_workspace_add(cwd: &PathBuf, member_paths: &[String]) -> anyhow::Result<()> {
    // Find workspace root
    let workspace_root = crate::config::find_workspace_root(cwd)
        .ok_or_else(|| anyhow::anyhow!("{}", crate::i18n::t("not_in_workspace")))?;

    let manifest_path = workspace_root.join("project.toml");

    for member_path in member_paths {
        // Check if member already exists by trying to add it
        match crate::config::add_workspace_member(&manifest_path, member_path) {
            Ok(_) => {
                println!("{}", crate::i18n::tf("added_member_to_workspace", &[member_path]));
            }
            Err(_) => {
                println!("{}", crate::i18n::tf("member_already_exists", &[member_path]));
            }
        }
    }
    Ok(())
}


/// FILE: src/cli/mod.rs

// src/cli/mod.rs
use clap::{Arg, Command};
use std::path::PathBuf;

pub mod commands;
pub mod parser;

pub use commands::Commands;
pub use commands::WorkspaceCommands;

pub struct Cli {
    pub command: Option<Commands>,
    pub raw_matches: clap::ArgMatches,
}

impl Cli {
    pub fn parse() -> Self {
        Self::parse_with_plugins(&[])
    }

    pub fn parse_with_plugins(plugins: &[Box<dyn crate::core::CommandHandler>]) -> Self {
        let mut cmd = Command::new("sinter")
            .about(crate::i18n::t("main_about"))
            .subcommand(
                Command::new("new")
                    .about(crate::i18n::t("new_about"))
                    .arg(
                        Arg::new("name")
                            .help(crate::i18n::t("new_name_help"))
                            .required(true)
                    )
            )
            .subcommand(
                Command::new("init")
                    .about(crate::i18n::t("init_about"))
            )
            .subcommand(
                Command::new("build")
                    .about(crate::i18n::t("build_about"))
            )
            .subcommand(
                Command::new("run")
                    .about(crate::i18n::t("run_about"))
                    .arg(
                        Arg::new("file")
                            .help(crate::i18n::t("run_file_help"))
                            .value_name("FILE")
                    )
                    .arg(
                        Arg::new("lib")
                            .long("lib")
                            .help(crate::i18n::t("run_lib_help"))
                            .action(clap::ArgAction::SetTrue)
                    )
            )
            .subcommand(
                Command::new("add")
                    .about(crate::i18n::t("add_about"))
                    .arg(
                        Arg::new("dep")
                            .help(crate::i18n::t("add_dep_help"))
                            .value_name("DEP")
                            .required(true)
                            .num_args(1..)
                    )
            )
            .subcommand(
                Command::new("test")
                    .about(crate::i18n::t("test_about"))
                    .arg(
                        Arg::new("file")
                            .help(crate::i18n::t("test_file_help"))
                            .value_name("FILE")
                    )
            )
            .subcommand(
                Command::new("workspace")
                    .about(crate::i18n::t("workspace_about"))
                    .subcommand(
                        Command::new("add")
                            .about(crate::i18n::t("workspace_add_about"))
                            .arg(
                                Arg::new("path")
                                    .help(crate::i18n::t("workspace_add_path_help"))
                                    .value_name("PATH")
                                    .required(true)
                                    .num_args(1..)
                            )
                    )
            );

        // 自动添加所有插件命令
        for handler in plugins {
            cmd = cmd.subcommand(handler.configure(Command::new(handler.name())));
        }

        let matches = cmd.get_matches();

        let command = parser::parse_command_from_matches(&matches);

        Cli { command, raw_matches: matches }
    }
}


/// FILE: src/cli/parser.rs

// src/cli/parser.rs
use super::commands::{Commands, WorkspaceCommands};

// 辅助函数：安全提取必需的字符串参数
fn extract_required_string(matches: &clap::ArgMatches, key: &str) -> String {
    matches.get_one::<String>(key).unwrap().clone()
}

// 辅助函数：安全提取可选的字符串参数并转换为PathBuf
fn extract_optional_path(matches: &clap::ArgMatches, key: &str) -> Option<std::path::PathBuf> {
    matches.get_one::<String>(key).map(|s| std::path::PathBuf::from(s))
}

pub fn parse_command_from_matches(matches: &clap::ArgMatches) -> Option<Commands> {
    match matches.subcommand() {
        Some(("new", sub_m)) => Some(Commands::New {
            name: extract_required_string(sub_m, "name"),
        }),
        Some(("init", _)) => Some(Commands::Init),
        Some(("build", _)) => Some(Commands::Build),
        Some(("run", sub_m)) => Some(Commands::Run {
            file: extract_optional_path(sub_m, "file"),
            lib: sub_m.get_flag("lib"),
        }),
        Some(("add", sub_m)) => Some(Commands::Add {
            deps: sub_m.get_many::<String>("dep").unwrap_or_default().map(|s| s.to_string()).collect(),
        }),
        Some(("test", sub_m)) => Some(Commands::Test {
            file: extract_optional_path(sub_m, "file"),
        }),
        Some(("workspace", ws_m)) => match ws_m.subcommand() {
            Some(("add", sub_m)) => Some(Commands::Workspace {
                subcommand: WorkspaceCommands::Add {
                    paths: sub_m.get_many::<String>("path").unwrap_or_default().map(|s| s.to_string()).collect(),
                }
            }),
            _ => None,
        },
        Some(("jsp", sub_m)) => Some(Commands::Jsp {
            name: extract_required_string(sub_m, "name"),
        }),
        _ => None,
    }
}


/// FILE: src/config.rs

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};

use anyhow::Context;
use config::Config;
use toml_edit::{value, DocumentMut, Item, Table};

use crate::deps::Dependency;

#[derive(Deserialize, Serialize, Debug)]
pub struct Project {
    pub package: Package,
    #[serde(default)]
    pub dependencies: HashMap<String, DependencySpec>,
    #[serde(default)]
    pub workspace: Option<Workspace>,
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(untagged)]
pub enum DependencySpec {
    Simple(String),
    Detailed(DependencyDetail),
}

#[derive(Deserialize, Serialize, Debug)]
pub struct DependencyDetail {
    pub version: Option<String>,
    #[serde(default)]
    pub workspace: bool,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Workspace {
    pub members: Vec<String>,
    #[serde(default)]
    pub dependencies: HashMap<String, DependencySpec>,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Package {
    pub name: String,
    pub version: String,
    pub main: Option<String>,
    #[serde(default = "default_scala_version")]
    pub scala_version: String,
    #[serde(default = "default_source_dir")]
    pub source_dir: String,
    #[serde(default = "default_target_dir")]
    pub target_dir: String,
    #[serde(default = "default_test_dir")]
    pub test_dir: String,
    #[serde(default = "default_backend")]
    pub backend: String,
}

fn default_scala_version() -> String {
    "2.13".to_string()
}

fn default_source_dir() -> String {
    "src/main/scala".to_string()
}

fn default_target_dir() -> String {
    "target".to_string()
}

fn default_test_dir() -> String {
    "src/test/scala".to_string()
}

fn default_backend() -> String {
    "scala-cli".to_string()
}

pub fn load_project(dir: &Path) -> anyhow::Result<Project> {
    let manifest_path = dir.join("project.toml");
    let settings = Config::builder()
        .add_source(config::File::from(manifest_path))
        .build()?;
    let proj: Project = settings.try_deserialize()?;
    Ok(proj)
}

pub fn load_project_async(dir: &Path) -> anyhow::Result<Project> {
    // For async operations if needed
    load_project(dir)
}

pub fn get_dependencies(project: &Project) -> Vec<Dependency> {
    project.dependencies
        .iter()
        .filter_map(|(k, spec)| match spec {
            crate::config::DependencySpec::Simple(version) => {
                Some(Dependency::from_toml_key(k, &version))
            }
            crate::config::DependencySpec::Detailed(detail) => {
                detail.version.as_ref().map(|v| Dependency::from_toml_key(k, v))
            }
        })
        .collect()
}

pub fn get_dependencies_with_workspace(project: &Project, workspace_root: Option<&Project>) -> Vec<Dependency> {
    let mut deps = Vec::new();

    // 只添加项目中显式声明的依赖
    for (k, spec) in &project.dependencies {
        match spec {
            crate::config::DependencySpec::Simple(version) => {
                // 简单格式的依赖直接使用项目中指定的版本
                deps.push(Dependency::from_toml_key(k, &version));
            }
            crate::config::DependencySpec::Detailed(detail) => {
                if detail.workspace {
                    // workspace依赖，从workspace根获取版本
                    if let Some(ws) = workspace_root {
                        if let Some(ws_config) = &ws.workspace {
                            if let Some(ws_spec) = ws_config.dependencies.get(k) {
                                match ws_spec {
                                    crate::config::DependencySpec::Simple(version) => {
                                        deps.push(Dependency::from_toml_key(k, &version));
                                    }
                                    crate::config::DependencySpec::Detailed(ws_detail) => {
                                        if let Some(version) = &ws_detail.version {
                                            deps.push(Dependency::from_toml_key(k, version));
                                        }
                                    }
                                }
                            } else {
                                // workspace中没有定义此依赖，跳过
                                eprintln!("Warning: dependency '{}' marked as workspace but not found in workspace root", k);
                            }
                        }
                    }
                } else if let Some(version) = &detail.version {
                    // 非workspace依赖，使用项目中指定的版本
                    deps.push(Dependency::from_toml_key(k, version));
                }
            }
        }
    }

    deps
}

pub async fn get_transitive_dependencies_with_workspace(project: &Project, workspace_root: Option<&Project>, project_dir: &Path) -> anyhow::Result<Vec<Dependency>> {
    let direct_deps = get_dependencies_with_workspace(project, workspace_root);
    let mut dep_manager = crate::deps::default_dependency_manager().await;
    dep_manager.set_project_dir(project_dir);
    dep_manager.get_transitive_dependencies(&direct_deps).await
}

pub async fn generate_ide_classpath(project: &Project, workspace_root: Option<&Project>, project_dir: &Path) -> anyhow::Result<()> {
    let transitive_deps = get_transitive_dependencies_with_workspace(project, workspace_root, project_dir).await?;

    let dep_manager = crate::deps::default_dependency_manager().await;
    let target_dir = project_dir.join(&project.package.target_dir);
    dep_manager.prepare_dependencies(&transitive_deps, &target_dir).await?;

    // 获取依赖JAR文件的路径
    let mut classpath_entries = String::new();
    for dep in &transitive_deps {
        if let Dependency::Maven { group, artifact, version, is_scala: _ } = dep {
            // coursier通常将JAR文件存储在~/.coursier/cache/v1/https/repo1.maven.org/maven2/...
            // 我们需要找到实际的JAR文件路径
            if let Some(jar_path) = find_jar_path(group, artifact, version) {
                classpath_entries.push_str(&format!("\t<classpathentry kind=\"lib\" path=\"{}\"/>\n", jar_path.display()));
            }
        }
    }

    // 读取模板
    let template_path = Path::new("templates/.classpath.template");
    let template_content = std::fs::read_to_string(template_path)?;

    // 替换模板变量
    let classpath_content = template_content
        .replace("{source_dir}", &project.package.source_dir)
        .replace("{target_dir}", &project.package.target_dir)
        .replace("{classpath_entries}", &classpath_entries);

    // 写入.classpath文件
    let classpath_path = project_dir.join(".classpath");
    std::fs::write(classpath_path, classpath_content)?;

    Ok(())
}

pub async fn generate_ide_options_v2(project: &Project, workspace_root: Option<&Project>, project_dir: &Path) -> anyhow::Result<()> {
    let transitive_deps = get_transitive_dependencies_with_workspace(project, workspace_root, project_dir).await?;

    let dep_manager = crate::deps::default_dependency_manager().await;
    let target_dir = project_dir.join(&project.package.target_dir);
    dep_manager.prepare_dependencies(&transitive_deps, &target_dir).await?;

    // 构建依赖列表
    let mut dependency_coords = Vec::new();
    for dep in &transitive_deps {
        dependency_coords.push(dep.coord());
    }

    // 读取模板（相对于crate根目录）
    let template_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("templates/ide-options-v2.json.template");
    let template_content = std::fs::read_to_string(template_path)?;

    // 替换模板变量
    let dependencies_json = serde_json::to_string(&dependency_coords)?;
    let options_content = template_content
        .replace("{scalac_option}", "-deprecation")  // 默认scalac选项
        .replace("\"dependency\": []", &format!("\"dependency\": {}", dependencies_json));

    // 写入ide-options-v2.json文件
    let options_path = project_dir.join("ide-options-v2.json");
    std::fs::write(options_path, options_content)?;

    Ok(())
}

fn find_jar_path(group: &str, artifact: &str, version: &str) -> Option<PathBuf> {
    // 尝试常见的coursier缓存位置
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    let cache_base = PathBuf::from(home).join(".coursier").join("cache").join("v1");

    // Maven Central路径
    let maven_path = cache_base
        .join("https")
        .join("repo1.maven.org")
        .join("maven2")
        .join(group.replace(".", "/"))
        .join(artifact)
        .join(version)
        .join(format!("{}-{}.jar", artifact, version));

    if maven_path.exists() {
        Some(maven_path)
    } else {
        // 尝试其他仓库或返回None
        None
    }
}

pub fn get_main_file_path(project: &Project) -> std::path::PathBuf {
    let main_class = project.package.main.as_deref().unwrap_or("Main");
    std::path::PathBuf::from(&project.package.source_dir).join(format!("{}.scala", main_class))
}

pub fn find_workspace_root(start_dir: &Path) -> Option<std::path::PathBuf> {
    let mut current = start_dir;
    loop {
        let manifest = current.join("project.toml");
        if manifest.exists() {
            if let Ok(settings) = Config::builder()
                .add_source(config::File::from(manifest.clone()))
                .build()
            {
                if let Ok(project) = settings.try_deserialize::<Project>() {
                    if project.workspace.is_some() {
                        return Some(current.to_path_buf());
                    }
                }
            }
        }
        if let Some(parent) = current.parent() {
            current = parent;
        } else {
            break;
        }
    }
    None
}

pub fn load_workspace(dir: &Path) -> anyhow::Result<Option<(Project, Vec<Project>)>> {
    let manifest_path = dir.join("project.toml");
    if !manifest_path.exists() {
        return Ok(None);
    }
    let settings = Config::builder()
        .add_source(config::File::from(manifest_path))
        .build()?;
    let root_project: Project = settings.try_deserialize()?;
    if let Some(workspace) = &root_project.workspace {
        let mut members = Vec::new();
        for member_path in &workspace.members {
            let member_dir = dir.join(member_path);
            let member_project = load_project(&member_dir)?;
            members.push(member_project);
        }
        Ok(Some((root_project, members)))
    } else {
        Ok(None)
    }
}


pub fn add_dependency_to_manifest(manifest_path: &Path, key: &str, version: &str) -> anyhow::Result<()> {
    let content = std::fs::read_to_string(manifest_path)?;

    // 步骤 1：解析为 Document<String>
    let mut doc: DocumentMut = content
        .parse()
        .context("Failed to parse project.toml as TOML document")?;

    // 确保 dependencies 表存在
    let deps_key = "dependencies";
    if !doc.contains_key(deps_key) {
        doc.insert(deps_key, Item::Table(Table::new()));
    }

    let deps_item = doc.get_mut(deps_key).unwrap();
    if let Some(deps_table) = deps_item.as_table_mut() {
        deps_table[key] = value(version.to_string());

        // 美化格式
        let decor = deps_table.decor_mut();
        decor.set_prefix("\n");
        decor.set_suffix("\n");
    }

    std::fs::write(manifest_path, doc.to_string())?;
    Ok(())
}

pub fn add_workspace_dependency_to_manifest(manifest_path: &Path, key: &str, version: &str) -> anyhow::Result<()> {
    let content = std::fs::read_to_string(manifest_path)?;

    // 步骤 1：解析为 Document<String>
    let mut doc: DocumentMut = content
        .parse()
        .context("Failed to parse project.toml as TOML document")?;

    // 确保 workspace 表存在
    let ws_key = "workspace";
    if !doc.contains_key(ws_key) {
        doc.insert(ws_key, Item::Table(Table::new()));
    }

    let ws_item = doc.get_mut(ws_key).unwrap();
    if let Some(ws_table) = ws_item.as_table_mut() {
        // 确保 workspace.dependencies 表存在
        let deps_key = "dependencies";
        if !ws_table.contains_key(deps_key) {
            ws_table.insert(deps_key, Item::Table(Table::new()));
        }

        if let Some(deps_item) = ws_table.get_mut(deps_key) {
            if let Some(deps_table) = deps_item.as_table_mut() {
                deps_table[key] = value(version.to_string());

                // 美化格式
                let decor = deps_table.decor_mut();
                decor.set_prefix("\n");
                decor.set_suffix("\n");
            }
        }
    }

    std::fs::write(manifest_path, doc.to_string())?;
    Ok(())
}

pub fn add_workspace_member(manifest_path: &Path, member_path: &str) -> anyhow::Result<()> {
    let content = std::fs::read_to_string(manifest_path)?;
    let mut doc: DocumentMut = content.parse().context("Failed to parse project.toml")?;

    // Ensure workspace table exists
    let ws_key = "workspace";
    if !doc.contains_key(ws_key) {
        doc.insert(ws_key, Item::Table(Table::new()));
    }

    let ws_item = doc.get_mut(ws_key).unwrap();
    if let Some(ws_table) = ws_item.as_table_mut() {
        // Ensure members array exists
        if !ws_table.contains_key("members") {
            ws_table.insert("members", Item::Value(toml_edit::Value::Array(Default::default())));
        }

        if let Some(members_item) = ws_table.get_mut("members") {
            if let Some(members_array) = members_item.as_array_mut() {
                // Check if member already exists
                let exists = members_array.iter().any(|v| v.as_str() == Some(member_path));
                if exists {
                    anyhow::bail!("Member '{}' already exists in workspace", member_path);
                }
                members_array.push(member_path);
                std::fs::write(manifest_path, doc.to_string())?;
            }
        }
    }

    Ok(())
}


/// FILE: src/core/app.rs

//! Sinter 应用构建器
//!
//! 使用函数式 Builder 模式构建应用，支持链式注册插件

use crate::core::handler::CommandHandler;
use crate::cli::Cli;
use crate::runtime::Executor;

/// Sinter 应用构建器
///
/// 使用 Builder 模式，支持链式调用注册插件：
///
/// ```rust
/// Sinter::new()
///     .plugin(my_plugin())
///     .plugin(another_plugin())
///     .run()
///     .await?;
/// ```
pub struct Sinter {
    plugins: Vec<Box<dyn CommandHandler>>,
}

impl Sinter {
    /// 创建新的 Sinter 应用
    pub fn new() -> Self {
        Self {
            plugins: Vec::new(),
        }
    }

    /// 注册单个插件
    ///
    /// 支持链式调用
    pub fn plugin<H: CommandHandler + 'static>(mut self, handler: H) -> Self {
        self.plugins.push(Box::new(handler));
        self
    }

    /// 批量注册插件
    ///
    /// 可以传入一个迭代器，一次性注册多个插件
    pub fn plugins<H: CommandHandler + 'static, I: IntoIterator<Item = H>>(
        mut self,
        handlers: I,
    ) -> Self {
        for handler in handlers {
            self.plugins.push(Box::new(handler));
        }
        self
    }

    /// 运行应用
    ///
    /// 解析命令行参数，执行对应的命令
    pub async fn run(self) -> anyhow::Result<()> {
        let cli = Cli::parse_with_plugins(&self.plugins);
        let cwd = std::env::current_dir()?;
        Executor::new(self.plugins).execute(cli, cwd).await
    }
}

impl Default for Sinter {
    fn default() -> Self {
        Self::new()
    }
}




/// FILE: src/core/handler.rs

//! 命令处理器 trait
//!
//! 所有命令（包括内置命令和插件）都需要实现这个 trait

use async_trait::async_trait;
use clap::{ArgMatches, Command};
use std::path::PathBuf;

/// 命令处理器 trait
///
/// 实现这个 trait 就可以创建一个新的命令。
/// 无论是内置命令还是插件，都使用相同的接口。
#[async_trait]
pub trait CommandHandler: Send + Sync {
    /// 返回命令名称
    ///
    /// 例如：`"new"`, `"build"`, `"jsp"` 等
    fn name(&self) -> &'static str;

    /// 返回命令描述
    ///
    /// 这个描述会显示在帮助信息中
    fn about(&self) -> &'static str;

    /// 配置命令参数
    ///
    /// 默认实现会设置命令名称和描述。
    /// 如果需要添加参数，可以重写这个方法。
    fn configure(&self, cmd: Command) -> Command {
        cmd.name(self.name()).about(self.about())
    }

    /// 执行命令逻辑
    ///
    /// 这是命令的核心逻辑，当用户运行命令时会被调用。
    async fn execute(&self, matches: &ArgMatches, cwd: &PathBuf) -> anyhow::Result<()>;
}




/// FILE: src/core/mod.rs

//! 核心模块
//!
//! 包含插件系统的核心 trait 和应用结构

pub mod handler;
pub mod app;

pub use handler::CommandHandler;
pub use app::Sinter;




/// FILE: src/deps/add.rs

use std::path::Path;

pub async fn add_dependency(project_dir: &Path, dep_spec: &str) -> anyhow::Result<()> {
    let project = crate::config::load_project(project_dir)?;
    let manifest_path = project_dir.join("project.toml");

    // 检测是否在工作空间根目录
    let is_workspace_root = project.workspace.is_some();

    // Check if it's an sbt path
    if dep_spec.starts_with("sbt:") || (dep_spec.contains("/") && !dep_spec.contains("::")) {
        let sbt_path = if dep_spec.starts_with("sbt:") {
            dep_spec[4..].to_string()
        } else {
            dep_spec.to_string()
        };

        // Validate that the sbt project exists
        let sbt_project_path = project_dir.join(&sbt_path);
        if !sbt_project_path.exists() {
            anyhow::bail!("sbt project path does not exist: {}", sbt_path);
        }

        let key = format!("sbt:{}", sbt_path);
        // 如果在工作空间根目录，添加到 workspace.dependencies
        if is_workspace_root {
            crate::config::add_workspace_dependency_to_manifest(&manifest_path, &key, "")?;
            println!("{}", crate::i18n::tf("added_dependency", &[&key, "sbt project (workspace)"]));
        } else {
            crate::config::add_dependency_to_manifest(&manifest_path, &key, "")?;
            println!("{}", crate::i18n::tf("added_dependency", &[&key, "sbt project"]));
        }
        return Ok(());
    }

    let (artifact, scala_ver, version) = parse_dep_spec(dep_spec, &project.package.scala_version).await?;

    let key = artifact.clone();

    // 对于Java依赖（artifact包含单冒号），不添加Scala版本后缀
    let full_key = if artifact.contains(':') && !artifact.contains("::") {
        // Java依赖格式：group:artifact
        key
    } else if !scala_ver.is_empty() && scala_ver != "latest" {
        format!("{}_{}", key, scala_ver)
    } else {
        key
    };

    // 使用依赖管理器验证依赖是否可用
    let dep_manager = crate::deps::default_dependency_manager().await;
    let dep = crate::deps::deps::Dependency::from_toml_key(&full_key, &version);
    
    // 验证依赖是否可用
    if let Err(e) = dep_manager.validate_dependency(&dep).await {
        anyhow::bail!("Failed to validate dependency {}: {}\nPlease check that the dependency coordinates are correct and the version exists.", full_key, e);
    }

    // 如果验证通过，下载依赖（使用coursier时会预先下载并缓存）
    if let Err(e) = dep_manager.prepare_dependencies(&[dep.clone()], &project_dir.join("target")).await {
        anyhow::bail!("Failed to download dependency {}: {}\nPlease check your network connection and try again.", full_key, e);
    }

    // 如果在工作空间根目录，添加到 workspace.dependencies
    if is_workspace_root {
        crate::config::add_workspace_dependency_to_manifest(&manifest_path, &full_key, &version)?;
        println!("{}", crate::i18n::tf("added_dependency", &[&full_key, &format!("{} (workspace)", version)]));
    } else {
        crate::config::add_dependency_to_manifest(&manifest_path, &full_key, &version)?;
        println!("{}", crate::i18n::tf("added_dependency", &[&full_key, &version]));
    }
    Ok(())
}


async fn parse_dep_spec(spec: &str, default_scala_version: &str) -> anyhow::Result<(String, String, String)> {
    // 检查是否是Scala依赖（使用::）还是Java依赖（使用:）
    let is_scala_format = spec.contains("::");

    let (group, artifact_version, is_scala) = if is_scala_format {
        // Scala格式：group::artifact:version
        let parts: Vec<&str> = spec.split("::").collect();
        if parts.len() != 2 {
            anyhow::bail!("{}", crate::i18n::t("invalid_dependency_format"));
        }
        let group = parts[0];
        let artifact_version = parts[1];
        (group, artifact_version, true)
    } else {
        // Java格式：group:artifact:version
        let parts: Vec<&str> = spec.split(':').collect();
        if parts.len() != 3 {
            anyhow::bail!("{}", crate::i18n::t("invalid_dependency_format"));
        }
        let group = parts[0];
        let artifact = parts[1];
        let version = parts[2];
        // 对于Java格式，直接返回，不需要进一步解析
        let full_artifact = format!("{}:{}", group, artifact);
        return Ok((full_artifact, "".to_string(), version.to_string()));
    };

    let av_parts: Vec<&str> = artifact_version.split(':').collect();
    if av_parts.len() != 2 {
        anyhow::bail!("{}", crate::i18n::t("invalid_dependency_format"));
    }

    let artifact_with_scala = av_parts[0];
    let version = av_parts[1];

    // 检查artifact是否包含::，如果是，则报错，因为artifact不应该有::
    if artifact_with_scala.contains("::") {
        anyhow::bail!("{}", crate::i18n::t("invalid_artifact_format"));
    }

    let artifact_parts: Vec<&str> = artifact_with_scala.split('@').collect();
    let (artifact, scala_ver) = if artifact_parts.len() == 2 {
        (artifact_parts[0].to_string(), artifact_parts[1])
    } else {
        (artifact_with_scala.to_string(), default_scala_version)
    };

    let full_artifact = format!("{}::{}", group, artifact);

    if version.is_empty() || version == "latest" {
        anyhow::bail!("{}", crate::i18n::t("version_must_be_specified"));
    }

    Ok((full_artifact, scala_ver.to_string(), version.to_string()))
}



/// FILE: src/deps/deps.rs

// src/deps.rs
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone)]
pub enum Dependency {
    Maven {
        group: String,
        artifact: String,
        version: String,
        is_scala: bool,
    },
    Sbt {
        path: String,
    },
}

impl Dependency {
    pub fn from_toml_key(key: &str, version: &str) -> Self {
        // Check if it's an sbt path (starts with sbt: or is a relative path)
        if key.starts_with("sbt:") || (key.contains("/") && !key.contains("::") && !key.contains(":")) {
            let path = if key.starts_with("sbt:") {
                key[4..].to_string()
            } else {
                key.to_string()
            };
            Self::Sbt { path }
        } else {
            // Check for Scala dependency (::) or Java dependency (:)
            let is_scala = key.contains("::");
            let parts: Vec<&str> = if is_scala {
                key.split("::").collect()
            } else if key.contains(":") {
                key.split(":").collect()
            } else {
                vec!["", key]
            };

            let (group, artifact) = if parts.len() >= 2 {
                (parts[0].to_string(), parts[1].to_string())
            } else {
                ("".to_string(), key.to_string())
            };
            Self::Maven {
                group,
                artifact,
                version: version.to_string(),
                is_scala,
            }
        }
    }

    // 生成 Maven 坐标：group:artifact:version 或 group::artifact:version 或 sbt 路径
    pub fn coord(&self) -> String {
        match self {
            Dependency::Maven { group, artifact, version, is_scala } => {
                if *is_scala {
                    format!("{}::{}:{}", group, artifact, version)
                } else {
                    format!("{}:{}:{}", group, artifact, version)
                }
            }
            Dependency::Sbt { path } => {
                format!("sbt:{}", path)
            }
        }
    }

    pub fn is_sbt(&self) -> bool {
        matches!(self, Dependency::Sbt { .. })
    }

    pub fn sbt_path(&self) -> Option<&str> {
        match self {
            Dependency::Sbt { path } => Some(path),
            _ => None,
        }
    }
}




/// FILE: src/deps/manager.rs

use crate::deps::deps::Dependency; // 假设此行是您的实际引用
use std::path::{Path, PathBuf};
use tokio::process::Command;
use std::sync::atomic::{AtomicBool, Ordering};
use std::collections::HashSet;
use anyhow::anyhow;



// --- 核心 Trait 和辅助函数 ---

/// 抽象的依赖管理器trait
#[async_trait::async_trait]
pub trait DependencyManager: Send + Sync {
    /// 准备依赖（下载、构建等）
    async fn prepare_dependencies(&self, deps: &[Dependency], target_dir: &Path) -> anyhow::Result<()>;

    /// 获取构建命令的参数
    fn get_build_args(&self, deps: &[Dependency]) -> Vec<String>;

    /// 获取运行命令的参数
    fn get_run_args(&self, deps: &[Dependency]) -> Vec<String>;

    /// 验证依赖是否可用（用于添加依赖时）
    async fn validate_dependency(&self, dep: &Dependency) -> anyhow::Result<()>;

    /// 获取传递依赖（包括直接依赖和所有传递依赖）
    async fn get_transitive_dependencies(&self, deps: &[Dependency]) -> anyhow::Result<Vec<Dependency>>;

    /// 设置项目目录（用于解析相对路径）
    fn set_project_dir(&mut self, project_dir: &Path);
}

/// 获取打包的coursier可执行文件路径
fn get_bundled_coursier_path() -> Option<PathBuf> {
    let exe_name = if cfg!(target_os = "windows") {
        "coursier.exe"
    } else {
        "coursier"
    };
    
    // 1. 尝试从bin目录（相对于可执行文件）
    if let Ok(exe) = std::env::current_exe() {
        if let Some(exe_dir) = exe.parent() {
            let bundled_path = exe_dir.join("bin").join(exe_name);
            if bundled_path.exists() {
                return Some(bundled_path);
            }
        }
    }
    
    // 2. 尝试从CARGO_MANIFEST_DIR/bin目录（开发时）
    if let Ok(manifest_dir) = std::env::var("CARGO_MANIFEST_DIR") {
        let bundled_path = PathBuf::from(manifest_dir).join("bin").join(exe_name);
        if bundled_path.exists() {
            return Some(bundled_path);
        }
    }
    
    None
}

/// 获取coursier可执行文件路径
async fn get_coursier_path() -> Option<String> {
    // 首先尝试使用打包的coursier
    if let Some(bundled_path) = get_bundled_coursier_path() {
        // 确保文件有执行权限
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            if let Ok(mut perms) = std::fs::metadata(&bundled_path).map(|m| m.permissions()) {
                perms.set_mode(0o755);
                let _ = std::fs::set_permissions(&bundled_path, perms);
            }
        }
        
        if let Some(path_str) = bundled_path.to_str() {
            // 验证打包的coursier是否可用
            let mut cmd = Command::new(path_str);
            cmd.arg("--version");
            // 使用 timeout 避免卡死，尽管 tokio::process::Command 默认没有
            if cmd.output().await.map(|o| o.status.success()).unwrap_or(false) {
                return Some(path_str.to_string());
            }
        }
    }
    
    // 回退到系统命令
    if check_command_available("coursier").await {
        Some("coursier".to_string())
    } else {
        None
    }
}

/// 检查命令是否可用
async fn check_command_available(cmd: &str) -> bool {
    Command::new(cmd)
        .arg("--version")
        .output()
        .await
        .map(|o| o.status.success())
        .unwrap_or(false)
}

static COURSIER_WARNING_PRINTED: AtomicBool = AtomicBool::new(false);

/// 检查coursier是否可用，如果不可用则打印安装提示（仅一次）
pub async fn check_coursier_available() -> bool {
    let available = get_coursier_path().await.is_some();
    if !available {
        // 只打印一次警告
        if !COURSIER_WARNING_PRINTED.swap(true, Ordering::Relaxed) {
            eprintln!("Warning: coursier is not available. For better dependency management:");
            eprintln!("  - Install coursier: curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-pc-linux.gz | gzip -d > cs && chmod +x cs && ./cs install coursier");
            eprintln!("  - Or visit: https://get-coursier.io/");
            eprintln!("  Falling back to scala-cli for dependency management.");
        }
    }
    available
}

// --- Coursier 实现 ---

/// Coursier 依赖管理器
pub struct CoursierDependencyManager {
    project_dir: Option<PathBuf>,
}

impl CoursierDependencyManager {
    pub fn new() -> Self {
        Self { project_dir: None }
    }
}

#[async_trait::async_trait]
impl DependencyManager for CoursierDependencyManager {
    async fn prepare_dependencies(&self, deps: &[Dependency], _target_dir: &Path) -> anyhow::Result<()> {
        let coursier_path = get_coursier_path().await
            .ok_or_else(|| anyhow!("coursier is not available"))?;
        
        for dep in deps {
            match dep {
                Dependency::Maven { .. } => {
                    // 使用coursier fetch下载依赖（这会自动缓存）
                    let mut cmd = Command::new(&coursier_path);
                    cmd.arg("fetch")
                        .arg("--quiet")
                        .arg(dep.coord());
                    
                    let output = cmd.output().await?;
                    if !output.status.success() {
                        let err = String::from_utf8_lossy(&output.stderr);
                        anyhow::bail!("Failed to fetch dependency {}: {}", dep.coord(), err);
                    }
                }
                Dependency::Sbt { path } => {
                    // 验证sbt项目存在
                    let sbt_project_path = Path::new(path);
                    if !sbt_project_path.exists() {
                        anyhow::bail!("sbt project path does not exist: {}", path);
                    }
                }
            }
        }
        
        Ok(())
    }

    fn get_build_args(&self, deps: &[Dependency]) -> Vec<String> {
        let mut args = Vec::new();

        for dep in deps {
            match dep {
                Dependency::Maven { .. } => {
                    args.push("--dependency".to_string());
                    args.push(dep.coord());
                }
                Dependency::Sbt { path } => {
                    // 统一使用 file:// 格式，无论是相对路径还是绝对路径
                    let dep_path = if Path::new(path).is_relative() {
                        // 使用 project_dir 来解析相对路径
                        self.project_dir.as_ref()
                            .map(|dir| dir.join(path))
                            .unwrap_or_else(|| PathBuf::from(path))
                            .to_string_lossy()
                            .to_string()
                    } else {
                        path.clone()
                    };
                    
                    args.push("--dependency".to_string());
                    args.push(format!("file://{}", dep_path));
                }
            }
        }

        args
    }

    fn get_run_args(&self, deps: &[Dependency]) -> Vec<String> {
        self.get_build_args(deps)
    }

    async fn validate_dependency(&self, dep: &Dependency) -> anyhow::Result<()> {
        let coursier_path = get_coursier_path().await
            .ok_or_else(|| anyhow!("coursier is not available"))?;

        match dep {
            Dependency::Maven { .. } => {
                // 使用coursier resolve验证依赖是否存在
                let mut cmd = Command::new(&coursier_path);
                cmd.arg("resolve")
                    .arg("--quiet")
                    .arg(dep.coord());

                let output = cmd.output().await?;
                if !output.status.success() {
                    let err = String::from_utf8_lossy(&output.stderr);
                    anyhow::bail!("Dependency {} is not available: {}", dep.coord(), err);
                }
                Ok(())
            }
            Dependency::Sbt { path } => {
                let sbt_project_path = Path::new(path);
                if !sbt_project_path.exists() {
                    anyhow::bail!("sbt project path does not exist: {}", path);
                }
                Ok(())
            }
        }
    }

    async fn get_transitive_dependencies(&self, deps: &[Dependency]) -> anyhow::Result<Vec<Dependency>> {
        let coursier_path = get_coursier_path().await
            .ok_or_else(|| anyhow!("coursier is not available"))?;

        let mut all_deps = Vec::new();
        let mut processed_coords: HashSet<String> = HashSet::new();

        for dep in deps {
            match dep {
                Dependency::Maven { group, artifact, version, is_scala } => {
                    let coord = if *is_scala {
                        format!("{}::{}:{}", group, artifact, version)
                    } else {
                        format!("{}:{}:{}", group, artifact, version)
                    };

                    let mut cmd = Command::new(&coursier_path);
                    cmd.arg("resolve")
                        .arg("--quiet")
                        .arg("--print-tree=false")
                        .arg("--intransitive") 
                        .arg(&coord);

                    let output = cmd.output().await?;
                    if !output.status.success() {
                        eprintln!("Warning: Failed to resolve transitive dependencies for {}: {}", coord, String::from_utf8_lossy(&output.stderr));
                        if processed_coords.insert(coord.clone()) {
                            all_deps.push(dep.clone());
                        }
                        continue;
                    }

                    let stdout = String::from_utf8_lossy(&output.stdout);
                    for line in stdout.lines() {
                        let line = line.trim();
                        if line.is_empty() || line.starts_with('#') {
                            continue;
                        }

                        // 解析 Maven 坐标格式 group:artifact:version
                        let parts: Vec<&str> = line.split(':').collect();
                        if parts.len() >= 3 {
                            let group = parts[0];
                            let artifact = parts[1];
                            let version = parts[2];
                            let current_coord = format!("{}:{}:{}", group, artifact, version);

                            if processed_coords.insert(current_coord) {
                                // 继承原始依赖的 is_scala 标志，或者根据 artifact 名称重新判断
                                let is_scala_dep = artifact.contains("_2.13") || artifact.contains("_2.12") || artifact.contains("_3");
                                
                                all_deps.push(Dependency::Maven {
                                    group: group.to_string(),
                                    artifact: artifact.to_string(),
                                    version: version.to_string(),
                                    is_scala: is_scala_dep,
                                });
                            }
                        }
                    }
                }
                Dependency::Sbt { path } => {
                    // 解析 sbt 项目的依赖
                    let sbt_project_path = if let Some(project_dir) = &self.project_dir {
                        // 修正：相对路径相对于 project_dir
                        project_dir.join(path)
                    } else {
                        Path::new(path).to_path_buf()
                    };

                    match resolve_sbt_dependencies(&sbt_project_path).await {
                        Ok(sbt_deps) => {
                            // 仅添加未处理过的 Maven 坐标
                            for sbt_dep in sbt_deps {
                                if let Dependency::Maven { .. } = &sbt_dep {
                                    if processed_coords.insert(sbt_dep.coord()) {
                                        all_deps.push(sbt_dep);
                                    }
                                }
                            }
                        }
                        Err(e) => {
                            eprintln!("Warning: Failed to resolve sbt dependencies for {}: {}", path, e);
                            all_deps.push(dep.clone());
                        }
                    }
                }
            }
        }

        Ok(all_deps)
    }

    fn set_project_dir(&mut self, project_dir: &Path) {
        self.project_dir = Some(project_dir.to_path_buf());
    }
}

// --- ScalaCli 实现 ---

/// Scala CLI 依赖管理器
pub struct ScalaCliDependencyManager;

#[async_trait::async_trait]
impl DependencyManager for ScalaCliDependencyManager {
    async fn prepare_dependencies(&self, deps: &[Dependency], _target_dir: &Path) -> anyhow::Result<()> {
        for dep in deps {
            if let Some(sbt_path) = dep.sbt_path() {
                let sbt_project_path = Path::new(sbt_path);
                if !sbt_project_path.exists() {
                    anyhow::bail!("sbt project path does not exist: {}", sbt_path);
                }
            }
        }
        Ok(())
    }

    fn get_build_args(&self, deps: &[Dependency]) -> Vec<String> {
        let mut args = Vec::new();

        for dep in deps {
            match dep {
                Dependency::Maven { .. } => {
                    args.push("--dependency".to_string());
                    args.push(dep.coord());
                }
                Dependency::Sbt { path } => {
                    // Scala CLI 处理 file:// 路径
                    args.push("--dependency".to_string());
                    args.push(format!("file://{}", path));
                }
            }
        }
        args
    }

    fn get_run_args(&self, deps: &[Dependency]) -> Vec<String> {
        self.get_build_args(deps)
    }

    async fn validate_dependency(&self, dep: &Dependency) -> anyhow::Result<()> {
        match dep {
            Dependency::Maven { .. } => {
                let mut cmd = Command::new("scala-cli");
                cmd.arg("--dependency")
                    .arg(dep.coord())
                    .arg("--quiet")
                    .arg("-e")
                    .arg("println(\"test\")");

                let output = cmd.output().await?;
                if !output.status.success() {
                    let err = String::from_utf8_lossy(&output.stderr);
                    anyhow::bail!("Dependency {} is not available: {}", dep.coord(), err);
                }
                Ok(())
            }
            Dependency::Sbt { path } => {
                let sbt_project_path = Path::new(path);
                if !sbt_project_path.exists() {
                    anyhow::bail!("sbt project path does not exist: {}", path);
                }
                Ok(())
            }
        }
    }

    async fn get_transitive_dependencies(&self, deps: &[Dependency]) -> anyhow::Result<Vec<Dependency>> {
        // Scala CLI 没有原生传递依赖解析功能，尝试回退到 Coursier
        if let Some(coursier_path) = get_coursier_path().await {
            // 使用 CoursierDependencyManager 的逻辑来解析，但不设置 project_dir
            let coursier_manager = CoursierDependencyManager::new();
            coursier_manager.get_transitive_dependencies(deps).await
        } else {
            // 如果coursier不可用，返回直接依赖
            eprintln!("Warning: Coursier is not available. Cannot resolve transitive dependencies using ScalaCliDependencyManager.");
            Ok(deps.to_vec())
        }
    }

    fn set_project_dir(&mut self, _project_dir: &Path) {
        // ScalaCliDependencyManager 不需要项目目录
    }
}

// --- 依赖管理器工厂函数 ---

/// 获取默认的依赖管理器
pub async fn default_dependency_manager() -> Box<dyn DependencyManager + Send + Sync> {
    if check_coursier_available().await {
        Box::new(CoursierDependencyManager::new())
    } else {
        Box::new(ScalaCliDependencyManager)
    }
}

/// 同步版本的默认依赖管理器（用于不需要异步的场景）
pub fn default_dependency_manager_sync() -> Box<dyn DependencyManager + Send + Sync> {
    // 修正：使用 tokio runtime 来安全地调用异步检查，并避免在非异步环境中多次创建 runtime
    // 生产环境中，最好在应用的启动时只创建一次 runtime
    let rt = tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime for sync check");
    
    // 检查 coursier 是否可用
    let is_coursier_available = rt.block_on(check_coursier_available());

    if is_coursier_available {
        Box::new(CoursierDependencyManager::new())
    } else {
        Box::new(ScalaCliDependencyManager)
    }
}

// --- SBT 辅助解析函数 ---

/// 解析 sbt 项目的依赖
async fn resolve_sbt_dependencies(sbt_project_path: &Path) -> anyhow::Result<Vec<Dependency>> {
    let build_sbt_path = sbt_project_path.join("build.sbt");
    if !build_sbt_path.exists() {
        return Ok(vec![]);
    }

    // 优先使用 sbt dependencyTree 命令获取依赖
    if check_command_available("sbt").await {
        return resolve_sbt_dependencies_via_sbt(sbt_project_path).await;
    }

    // 回退：尝试使用 coursier 解析 sbt 项目（仅当 sbt 不可用时）
    if let Some(coursier_path) = get_coursier_path().await {
        let coord = format!("sbt-project:{}", sbt_project_path.display());
        let mut cmd = Command::new(&coursier_path);
        cmd.arg("resolve")
            .arg("--quiet")
            .arg("--print-tree=false")
            .arg("--intransitive")
            .arg(&coord);

        let output = cmd.output().await?;
        if output.status.success() {
            let mut deps = Vec::new();
            let mut processed_coords: HashSet<String> = HashSet::new();

            let stdout = String::from_utf8_lossy(&output.stdout);
            for line in stdout.lines() {
                let line = line.trim();
                // ... (Maven 坐标解析逻辑与 CoursierDependencyManager 中相同，省略细节)
                if line.is_empty() || line.starts_with('#') { continue; }
                let parts: Vec<&str> = line.split(':').collect();
                if parts.len() >= 3 {
                    let group = parts[0];
                    let artifact = parts[1];
                    let version = parts[2];
                    let coord = format!("{}:{}:{}", group, artifact, version);

                    if processed_coords.insert(coord.clone()) {
                        let is_scala = artifact.contains("_2.13") || artifact.contains("_2.12") || artifact.contains("_3");
                        deps.push(Dependency::Maven {
                            group: group.to_string(),
                            artifact: artifact.to_string(),
                            version: version.to_string(),
                            is_scala,
                        });
                    }
                }
            }
            return Ok(deps);
        }
    }

    eprintln!("Warning: Could not resolve dependencies for sbt project {} (sbt command not found).", sbt_project_path.display());
    Ok(vec![])
}

/// 使用 sbt 命令解析依赖
async fn resolve_sbt_dependencies_via_sbt(sbt_project_path: &Path) -> anyhow::Result<Vec<Dependency>> {
    // 这是一个脆弱的方法，依赖于 sbt dependencyTree 的输出格式
    let mut cmd = Command::new("sbt");
    cmd.arg("dependencyTree")
        .current_dir(sbt_project_path);

    let output = cmd.output().await?;
    if !output.status.success() {
        let err = String::from_utf8_lossy(&output.stderr);
        return Err(anyhow!("Failed to run sbt dependencyTree: {}", err));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let mut deps = Vec::new();
    let mut processed_coords: HashSet<String> = HashSet::new();

    for line in stdout.lines() {
        let line = line.trim();

        let line = if line.starts_with("[info]") {
            line.trim_start_matches("[info]").trim()
        } else {
            line
        };

        if line.contains(':') && (line.starts_with("+-") || line.contains(" +-")) {
            let dep_line = if line.starts_with("+-") {
                line.trim_start_matches("+-").trim()
            } else if line.contains(" +-") {
                line.trim_start_matches(|c: char| c.is_whitespace() || c == '|')
                    .trim_start_matches("+-").trim()
            } else {
                continue;
            };

            let parts: Vec<&str> = dep_line.split(':').collect();
            // 依赖格式 group:artifact:version
            if parts.len() >= 3 {
                let group = parts[0];
                let artifact = parts[1];
                let version = parts[2].split(|c: char| c.is_whitespace()).next().unwrap_or(parts[2]);
                let coord = format!("{}:{}:{}", group, artifact, version);

                if processed_coords.insert(coord.clone()) {
                    let is_scala = artifact.contains("_2.13") || artifact.contains("_2.12") || artifact.contains("_3");

                    deps.push(Dependency::Maven {
                        group: group.to_string(),
                        artifact: artifact.to_string(),
                        version: version.to_string(),
                        is_scala,
                    });
                }
            }
        }
    }

    Ok(deps)
}


/// FILE: src/deps/mod.rs

pub mod deps;
pub mod add;
pub mod manager;

pub use deps::Dependency;
pub use add::add_dependency;
pub use manager::{DependencyManager, ScalaCliDependencyManager, CoursierDependencyManager, default_dependency_manager, default_dependency_manager_sync};



/// FILE: src/i18n.rs

//! 国际化支持模块
//!
//! 此模块在构建时由 build.rs 生成，提供类型安全的翻译功能。
//! 语言选择通过 Cargo 特性标志控制：
//! - `lang-en` (默认): 英文
//! - `lang-zh`: 中文
//!
//! 使用示例：
//! ```rust
//! use crate::i18n::{t, tf};
//!
//! // 简单翻译
//! println!("{}", t("main_about"));
//!
//! // 带参数的翻译
//! println!("{}", tf("created_project", &["my-project"]));
//! ```

// Fallback 实现（用于 rust-analyzer 和测试环境）
// 当 OUT_DIR 未设置时，rust-analyzer 可以使用这个实现进行分析
mod fallback {
    /// Get a translated string by key (fallback implementation)
    /// This is used when build scripts haven't run (e.g., in rust-analyzer)
    pub fn t(_key: &str) -> &'static str {
        // 返回一个占位符字符串，这样 rust-analyzer 可以正常工作
        // 实际构建时会使用生成的代码
        "[Translation placeholder]"
    }

    /// Format a translated string with arguments (fallback implementation)
    pub fn tf(key: &str, args: &[&str]) -> String {
        let template = t(key);
        let mut result = template.to_string();
        for arg in args {
            if result.contains("{}") {
                result = result.replacen("{}", arg, 1);
            } else {
                break;
            }
        }
        result
    }
}

// 尝试包含构建时生成的代码
// 使用条件编译：只有在实际构建时才包含生成的代码
#[cfg(all(not(test), not(doctest)))]
mod generated {
    // 尝试包含生成的代码
    // 如果 OUT_DIR 未设置，这会在编译时失败
    // 但我们可以通过提供一个默认的英文实现来避免这个问题
    // 注意：在实际构建时，build.rs 总是会运行，所以 OUT_DIR 总是存在
    include!(concat!(env!("OUT_DIR"), "/i18n.rs"));
}

// 导出函数
// 在实际构建时使用生成的代码，在测试或 rust-analyzer 时使用 fallback
#[cfg(all(not(test), not(doctest)))]
pub use generated::{t, tf};

#[cfg(any(test, doctest))]
pub use fallback::{t, tf};

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_translation() {
        // 测试简单翻译
        let msg = t("main_about");
        assert!(!msg.is_empty());
    }

    #[test]
    fn test_formatted_translation() {
        // 测试格式化翻译
        // 注意：在测试模式下使用 fallback，所以只测试函数能正常调用
        let msg = tf("created_project", &["test-project"]);
        assert!(!msg.is_empty());
        // fallback 实现会替换 {}，所以应该包含参数
        assert!(msg.contains("test-project") || msg == "[Translation placeholder]");
    }
}




/// FILE: src/lib.rs

//! Sinter - Scala 项目构建工具
//!
//! 这是一个类似 Cargo 的 Scala 项目管理和构建工具。

// 核心模块
pub mod core;

// 运行时模块
pub mod runtime;

// CLI 和配置
pub mod cli;
pub mod config;

// 功能模块
pub mod build;
pub mod deps;

// 国际化支持（构建时生成）
pub mod i18n;

// extern crate paste;

// 公共 API
pub use core::{CommandHandler, Sinter};
pub use cli::{Cli, Commands, WorkspaceCommands};


/// FILE: src/runtime/executor.rs

//! 命令执行器
//!
//! 负责将解析后的 CLI 命令分发到对应的处理器

use crate::core::handler::CommandHandler;
use crate::cli::{Cli, commands::builtin};
use std::path::PathBuf;

/// 命令执行器
///
/// 负责执行命令，包括：
/// 1. 插件命令的执行
/// 2. 内置命令的执行
pub struct Executor {
    plugins: Vec<Box<dyn CommandHandler>>,
}

impl Executor {
    /// 创建新的执行器
    pub fn new(plugins: Vec<Box<dyn CommandHandler>>) -> Self {
        Self { plugins }
    }

    /// 执行命令
    ///
    /// 根据 CLI 解析结果，执行对应的命令
    pub async fn execute(&self, cli: Cli, cwd: PathBuf) -> anyhow::Result<()> {
        // 首先检查是否是插件命令
        if let Some((command_name, matches)) = cli.raw_matches.subcommand() {
            if let Some(handler) = self.plugins.iter().find(|cmd| cmd.name() == command_name) {
                return handler.execute(matches, &cwd).await;
            }
        }

        // 处理内置命令
        if let Some(command) = cli.command {
            builtin::execute_command(command, &cwd).await?;
        } else {
            // 没有提供命令，尝试运行默认行为
            builtin::execute_default(&cwd).await?;
        }

        Ok(())
    }
}




/// FILE: src/runtime/mod.rs

//! 运行时模块
//!
//! 处理命令的执行和分发逻辑

pub mod executor;

pub use executor::Executor;




/// FILE: templates/i18n.json

{
  "en": {
    "main_about": "A Cargo-like build tool for Scala",
    "new_about": "Create a new Scala project",
    "init_about": "Initialize a new workspace",
    "build_about": "Build the Scala project",
    "run_about": "Run the Scala project or a specific file",
    "add_about": "Add a dependency to the project",
    "workspace_about": "Workspace management",
    "workspace_add_about": "Add a member to the workspace",
    "new_name_help": "Name of the new project",
    "run_file_help": "Optional .scala file to run (relative to project root)",
    "run_lib_help": "Force library mode (compile only)",
    "add_dep_help": "Dependency in format: group::artifact:version[@scala-version]",
    "workspace_add_path_help": "Path to the member project",
    "test_about": "Run tests",
    "test_file_help": "Optional test file or directory to run (relative to project root)",
    "project_already_exists": "Project '{}' already exists",
    "created_project": "Created project `{}`",
    "initialized_empty_workspace": "Initialized empty workspace in {}",
    "added_member_to_workspace": "Added member '{}' to workspace",
    "added_project_to_workspace": "Added project '{}' to workspace",
    "member_already_exists": "Member '{}' already exists in workspace",
    "added_dependency": "Added dependency: {} = {}",
    "built_member": "Built member: {}",
    "build_succeeded_with_deps": "Build succeeded with {} dependencies",
    "workspace_build_succeeded": "Workspace build succeeded",
    "lib_compiled_only": "lib: {} (compiled only)",
    "main_file_not_found": "Main file not found: {}",
    "no_command_provided": "No command provided. Use --help for usage.",
    "config_file_already_exists": "project.toml already exists in this directory",
    "not_in_workspace": "Not in a workspace",
    "invalid_dependency_format": "Invalid dependency format, please use full format: group::artifact:version, e.g. org.typelevel::cats-core:2.9.0",
    "invalid_artifact_format": "Invalid dependency format, artifact should not contain '::', please use group:artifact:version format",
    "version_must_be_specified": "Version must be explicitly specified, 'latest' is not allowed",
    "running_in_workspace": "Running in workspace: {}",
    "running_in_project": "Running in project: {}",
    "workspace_dependencies": "Workspace dependencies ({}):",
    "project_dependencies": "Project dependencies ({}):",
    "no_workspace_dependencies": "No workspace dependencies",
    "no_project_dependencies": "No project dependencies",
    "dependency_item": "  - {}"
  },
  "zh": {
    "main_about": "一个类似 Cargo 的 Scala 构建工具",
    "new_about": "创建一个新的 Scala 项目",
    "init_about": "初始化一个新的工作空间",
    "build_about": "构建 Scala 项目",
    "run_about": "运行 Scala 项目或特定文件",
    "add_about": "向项目添加依赖",
    "workspace_about": "工作空间管理",
    "workspace_add_about": "向工作空间添加成员",
    "new_name_help": "新项目的名称",
    "run_file_help": "可选的要运行的 .scala 文件（相对于项目根目录）",
    "run_lib_help": "强制库模式（仅编译）",
    "add_dep_help": "依赖格式：group::artifact:version[@scala-version]",
    "workspace_add_path_help": "成员项目的路径",
    "test_about": "运行测试",
    "test_file_help": "可选的测试文件或目录（相对于项目根目录）",
    "project_already_exists": "项目 '{}' 已存在",
    "created_project": "已创建项目 `{}`",
    "initialized_empty_workspace": "已初始化空工作空间于 {}",
    "added_member_to_workspace": "已添加成员 '{}' 到工作空间",
    "added_project_to_workspace": "已添加项目 '{}' 到工作空间",
    "member_already_exists": "成员 '{}' 已存在于工作空间",
    "added_dependency": "已添加依赖: {} = {}",
    "built_member": "已构建成员: {}",
    "build_succeeded_with_deps": "构建成功，包含 {} 个依赖",
    "workspace_build_succeeded": "工作空间构建成功",
    "lib_compiled_only": "库: {} (仅编译)",
    "main_file_not_found": "未找到主文件: {}",
    "no_command_provided": "未提供命令。使用 --help 获取用法。",
    "config_file_already_exists": "project.toml 已存在于此目录",
    "not_in_workspace": "不在工作空间中",
    "invalid_dependency_format": "依赖格式无效，请使用完整格式：group::artifact:version，例如 org.typelevel::cats-core:2.9.0",
    "invalid_artifact_format": "依赖格式无效，artifact 不应包含 '::'，请使用 group:artifact:version 格式",
    "version_must_be_specified": "必须明确指定版本，不允许使用 'latest'",
    "running_in_workspace": "在工作空间中运行: {}",
    "running_in_project": "在项目中运行: {}",
    "workspace_dependencies": "工作空间依赖 ({}):",
    "project_dependencies": "项目依赖 ({}):",
    "no_workspace_dependencies": "无工作空间依赖",
    "no_project_dependencies": "无项目依赖",
    "dependency_item": "  - {}"
  }
}




