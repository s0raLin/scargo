/// FILE: Cargo.toml

# crates/sinter/Cargo.toml
[package]
name = "sinter"
version.workspace = true
edition.workspace = true
license.workspace = true
description = "Core engine for sinter"
build = "build.rs"

[features]
default = ["lang-en"]
lang-en = []
lang-zh = []

[build-dependencies]
serde_json = "1"

[dependencies]
anyhow      = { workspace = true }
async-trait = { workspace = true }
clap        = { workspace = true }
tokio       = { workspace = true }
serde       = { workspace = true }
toml_edit   = { workspace = true }
config      = { workspace = true }
dirs        = { workspace = true }
paste       = { workspace = true }
inventory   = { workspace = true }
serde_json  = { workspace = true }
walkdir     = "2"




/// FILE: I18N.md

# 国际化支持

Sinter 使用构建时国际化系统，在编译时生成翻译代码，提供零运行时开销的类型安全翻译。

## 工作原理

1. **翻译文件**: `templates/i18n.json` 包含所有语言的翻译
2. **构建脚本**: `build.rs` 在编译时读取翻译文件并生成 Rust 代码
3. **特性标志**: 通过 Cargo 特性标志选择语言
4. **生成的代码**: 在 `OUT_DIR/i18n.rs` 中生成类型安全的翻译函数

## 使用方法

### 默认构建（英文）

```bash
cargo build
# 或
cargo build --package sinter
```

### 构建中文版本

```bash
cargo build --package sinter --features lang-zh
# 或禁用默认特性，只启用中文
cargo build --package sinter --no-default-features --features lang-zh
```

### 在代码中使用

```rust
use sinter::i18n::{t, tf};

// 简单翻译
println!("{}", t("main_about"));

// 带参数的翻译（使用 {} 占位符）
println!("{}", tf("created_project", &["my-project"]));
```

## 添加新翻译

1. 编辑 `templates/i18n.json`
2. 为每个语言添加对应的键值对
3. 重新构建项目

示例：

```json
{
  "en": {
    "my_new_key": "My new message"
  },
  "zh": {
    "my_new_key": "我的新消息"
  }
}
```

## 添加新语言

1. 在 `templates/i18n.json` 中添加新语言对象
2. 在 `Cargo.toml` 中添加新的特性标志：
   ```toml
   [features]
   lang-ja = []  # 日语
   ```
3. 在 `build.rs` 中添加语言检测逻辑
4. 使用 `--features lang-ja` 构建

## 优势

- ✅ **零运行时开销**: 翻译在编译时确定，无运行时查找
- ✅ **类型安全**: 编译时检查翻译键是否存在
- ✅ **易于维护**: 所有翻译集中在一个 JSON 文件中
- ✅ **多语言构建**: 可以为不同语言构建不同的二进制文件
- ✅ **性能优化**: 字符串字面量直接嵌入二进制文件

## 注意事项

- 翻译文件改变后需要重新构建
- 未找到的翻译键会返回 `"[Translation key not found]"`
- 格式化字符串使用 `{}` 作为占位符，按顺序替换参数

## Rust Analyzer 配置

如果遇到 `OUT_DIR not set` 错误，请确保 rust-analyzer 已配置为运行构建脚本：

在 `.vscode/settings.json` 或 `rust-analyzer` 配置中添加：

```json
{
  "rust-analyzer.cargo.buildScripts.enable": true,
  "rust-analyzer.cargo.buildScripts.useRustcWrapper": true
}
```

或者在项目根目录的 `.cargo/config.toml` 中配置。

**注意**：即使 rust-analyzer 无法运行构建脚本，代码仍然可以正常编译，因为实际构建时 `build.rs` 总是会运行。




/// FILE: bin/README.md

# Coursier 可执行文件

此目录用于存放打包的 `coursier` 可执行文件。

## 如何添加 coursier 可执行文件

### Linux (x86_64)
```bash
curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-pc-linux.gz | gzip -d > coursier
chmod +x coursier
```

### macOS (x86_64)
```bash
curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-apple-darwin.gz | gzip -d > coursier
chmod +x coursier
```

### macOS (ARM64)
```bash
curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-aarch64-apple-darwin.gz | gzip -d > coursier
chmod +x coursier
```

### Windows
下载 `cs-x86_64-pc-win32.zip`，解压后将 `cs.exe` 重命名为 `coursier.exe` 并放入此目录。

## 快速下载

使用提供的脚本自动下载：

```bash
cd crates/sinter-core/bin
./download-coursier.sh
```

## 使用说明

如果此目录中存在 `coursier`（或 `coursier.exe`），sinter 将优先使用打包的版本，而不是系统安装的版本。

查找顺序：
1. **打包的版本**：`<可执行文件目录>/bin/coursier` 或开发时的 `CARGO_MANIFEST_DIR/bin/coursier`
2. **系统命令**：PATH 中的 `coursier` 命令
3. **回退方案**：如果两者都不存在，sinter 会回退到使用 `scala-cli` 进行依赖管理

## 构建时包含

在构建发布版本时，确保将 `bin/coursier` 复制到可执行文件目录的 `bin/` 子目录中，这样打包的版本才能被找到。

例如，如果可执行文件在 `target/release/sinter`，则 coursier 应该在 `target/release/bin/coursier`。




/// FILE: build.rs

use std::env;
use std::fs::{self, Permissions};
use std::path::Path;
use std::process::Command;

#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;

fn main() {
    println!("cargo:rerun-if-changed=templates/i18n.json");

    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let i18n_path = Path::new(&manifest_dir).join("templates/i18n.json");
    let i18n_content = fs::read_to_string(&i18n_path).expect("Failed to read i18n.json");

    let translations: serde_json::Value = serde_json::from_str(&i18n_content).expect("Failed to parse i18n.json");

    let lang = if cfg!(feature = "lang-zh") { "zh" } else { "en" };
    let lang_translations = translations.get(lang).and_then(|v| v.as_object()).expect(&format!("Language '{}' not found", lang));

    let out_dir = env::var("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir).join("i18n.rs");

    let mut code = String::new();
    code.push_str("// Auto-generated i18n code\n");
    code.push_str("pub fn t(key: &str) -> &'static str {\n match key {\n");
    for (key, value) in lang_translations {
        let escaped = value.as_str().unwrap().replace('\\', "\\\\").replace('"', "\\\"").replace('\n', "\\n");
        code.push_str(&format!(" \"{}\" => \"{}\",\n", key, escaped));
    }
    code.push_str(" _ => \"[Translation key not found]\",\n }\n}\n\n");
    code.push_str("pub fn tf(key: &str, args: &[&str]) -> String {\n let template = t(key);\n let mut result = template.to_string();\n for arg in args {\n if let Some(pos) = result.find(\"{}\") {\n let (left, right) = result.split_at(pos);\n result = format!(\"{}{}{}\", left, arg, &right[2..]);\n } }\n result\n}\n");

    fs::write(&out_path, code).expect("Failed to write i18n.rs");

    // 下载coursier（简化平台检测）
    download_coursier();
}

fn download_coursier() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let bin_dir = Path::new(&manifest_dir).join("bin");
    fs::create_dir_all(&bin_dir).ok();

    let exe_name = if cfg!(target_os = "windows") { "coursier.exe" } else { "coursier" };
    let coursier_path = bin_dir.join(exe_name);

    if coursier_path.exists() && Command::new(&coursier_path).arg("--version").output().map(|o| o.status.success()).unwrap_or(false) {
        println!("cargo:warning=coursier already exists");
        return;
    }

    let platform = match (env::consts::OS, env::consts::ARCH) {
        ("linux", "x86_64") => "x86_64-pc-linux",
        ("linux", "aarch64") => "aarch64-pc-linux",
        ("macos", "x86_64") => "x86_64-apple-darwin",
        ("macos", "aarch64") => "aarch64-apple-darwin",
        _ => return,
    };

    let url = format!("https://github.com/coursier/coursier/releases/latest/download/cs-{}.gz", platform);
    Command::new("sh").args(&["-c", &format!("curl -fL {} | gzip -d > {}", url, coursier_path.display())]).status().ok();

    #[cfg(unix)]
    {
        let perms = Permissions::from_mode(0o755);
        fs::set_permissions(&coursier_path, perms).ok();
    }

    // 拷贝到target/bin
    let binding = env::var("OUT_DIR").unwrap();
    let out_dir = Path::new(&binding).parent().unwrap().parent().unwrap().parent().unwrap();
    let target_bin_dir = out_dir.join("bin");
    fs::create_dir_all(&target_bin_dir).ok();
    let target_path = target_bin_dir.join(exe_name);
    fs::copy(&coursier_path, &target_path).ok();

    #[cfg(unix)]
    {
        let perms = Permissions::from_mode(0o755);
        fs::set_permissions(&target_path, perms).ok();
    }
}


/// FILE: src/cli/builtin.rs

//! 内置命令实现
//!
//! 包含所有内置命令的执行逻辑

use crate::cli::{Commands, commands::{cmd_new, cmd_init, cmd_test, cmd_workspace}};
use crate::build::{run_scala_file, run_single_file_with_deps};
use crate::ide::setup_bsp;
use crate::deps::add_dependency;
use std::path::PathBuf;
use crate::config::loader;

/// 执行内置命令
pub async fn execute_command(command: Commands, cwd: &PathBuf) -> anyhow::Result<()> {
    match command {
        Commands::New { name } => {
            cmd_new(cwd, &name).await?;
        }
        Commands::Init => {
            cmd_init(cwd).await?;
        }
        Commands::Workspace { subcommand } => {
            cmd_workspace(cwd, &subcommand).await?;
        }
        Commands::Build => {
            execute_build(cwd).await?;
        }
        Commands::Run { file, lib } => {
            execute_run(cwd, file, lib).await?;
        }
        Commands::Add { deps } => {
            execute_add(cwd, &deps).await?;
        }
        Commands::Test { file } => {
            cmd_test(cwd, file).await?;
        }
        Commands::Jsp { name } => {
            // JSP 命令应该由插件系统处理
            anyhow::bail!("JSP command '{}' requires the JSP plugin to be loaded", name);
        }
    }
    Ok(())
}

/// 执行默认行为（无命令时）
pub async fn execute_default(cwd: &PathBuf) -> anyhow::Result<()> {
    if cwd.join("project.toml").exists() {
        let project = loader::load_project(cwd)?;
        let target = project.get_main_file_path();
        if cwd.join(&target).exists() {
            let deps = crate::dependency::get_dependencies(&project);
            let output = run_single_file_with_deps(cwd, &target, &deps).await?;
            println!("{}", output);
        } else {
            println!(
                "{}",
                crate::i18n::tf("main_file_not_found", &[&target.display().to_string()])
            );
        }
    } else {
        println!("{}", crate::i18n::t("no_command_provided"));
    }
    Ok(())
}

/// 执行构建命令
async fn execute_build(cwd: &PathBuf) -> anyhow::Result<()> {
    if let Ok(project) = loader::load_project(cwd) {
        if project.workspace.is_some() {
            // Workspace build - build all members
            let (root_project, members) = loader::load_workspace(cwd)?.ok_or_else(|| anyhow::anyhow!("Failed to load workspace configuration"))?;
            let mut all_deps = Vec::new();
            let mut source_dirs = Vec::new();
            let mut backend = None;
            for member in members.iter() {
                let member_dir = cwd.join(member.get_name());
                let transitive_deps = crate::dependency::get_transitive_dependencies_with_workspace(&member, Some(&root_project), &member_dir).await?;
                all_deps.extend(transitive_deps.clone());
                source_dirs.push((member.get_name().to_string(), member.get_source_dir().to_string()));
                if backend.is_none() {
                    backend = Some(member.get_backend().to_string());
                }
                // For workspace builds, use target directory relative to workspace root
                let workspace_target_dir = format!(
                    "{}/{}",
                    root_project.get_target_dir(), member.get_name()
                );
                crate::build::build_with_deps(
                    &member_dir,
                    &transitive_deps,
                    member.get_source_dir(),
                    &workspace_target_dir,
                    member.get_backend(),
                    Some(cwd),
                    false, // Do not setup BSP for each member
                    true, // is_workspace_build
                )
                .await?;
                println!("{}", crate::i18n::tf("built_member", &[member.get_name()]));
            }
            // Setup BSP for the entire workspace
            if let Some(bk) = backend {
                setup_bsp(cwd, &all_deps, &source_dirs, &bk).await?;
            }
            println!("{}", crate::i18n::t("workspace_build_succeeded"));
        } else {
            // Single project or member in workspace
            if let Some(workspace_root) = crate::config::loader::find_workspace_root(cwd) {
                // Build single member in workspace
                if let Some((root_project, members)) = loader::load_workspace(&workspace_root)? {
                    let relative_path = cwd.strip_prefix(&workspace_root).map_err(|_| anyhow::anyhow!("Invalid workspace structure"))?;
                    let member_name = relative_path.components().next()
                        .and_then(|c| c.as_os_str().to_str())
                        .ok_or_else(|| anyhow::anyhow!("Cannot determine member name from path"))?;
                    if let Some(member) = members.into_iter().find(|m| m.get_name() == member_name) {
                        let transitive_deps = crate::dependency::get_transitive_dependencies_with_workspace(&member, Some(&root_project), cwd).await?;
                        crate::build::build_with_deps(
                            cwd,
                            &transitive_deps,
                            member.get_source_dir(),
                            member.get_target_dir(),
                            member.get_backend(),
                            Some(&workspace_root),
                            true, // Setup BSP for this member
                            false, // not workspace build
                        )
                        .await?;
                        println!(
                            "{}",
                            crate::i18n::tf("build_succeeded_with_deps", &[&transitive_deps.len().to_string()])
                        );
                    } else {
                        anyhow::bail!("Member {} not found in workspace", member_name);
                    }
                } else {
                    // Not in a workspace, treat as single project
                    let transitive_deps = crate::dependency::get_transitive_dependencies_with_workspace(&project, None, cwd).await?;
                    crate::build::build_with_deps(
                        cwd,
                        &transitive_deps,
                        project.get_source_dir(),
                        project.get_target_dir(),
                        project.get_backend(),
                        None,
                        true, // Setup BSP for single project
                        false, // not workspace build
                    )
                    .await?;
                    println!(
                        "{}",
                        crate::i18n::tf("build_succeeded_with_deps", &[&transitive_deps.len().to_string()])
                    );
                }
            } else {
                // Single project build
                let transitive_deps = crate::dependency::get_transitive_dependencies_with_workspace(&project, None, cwd).await?;
                crate::build::build_with_deps(
                    cwd,
                    &transitive_deps,
                    project.get_source_dir(),
                    project.get_target_dir(),
                    project.get_backend(),
                    None,
                    true, // Setup BSP for single project
                    false, // not workspace build
                )
                .await?;
                println!(
                    "{}",
                    crate::i18n::tf("build_succeeded_with_deps", &[&transitive_deps.len().to_string()])
                );
            }
        }
    } else {
        anyhow::bail!("No project.toml found in {}", cwd.display());
    }
    Ok(())
}

/// 执行运行命令
async fn execute_run(cwd: &PathBuf, file: Option<PathBuf>, lib: bool) -> anyhow::Result<()> {
    let workspace_root = crate::config::loader::find_workspace_root(cwd);
    let workspace_root_ref = workspace_root.as_ref();

    // 确定项目配置和目录
    let (project, project_dir) = if let Some(ws_root) = workspace_root_ref {
        // 在 workspace 中，查找成员项目
        if let Some((_ws_proj, members)) = crate::config::loader::load_workspace(ws_root)? {
            let relative_path = cwd.strip_prefix(ws_root).map_err(|_| anyhow::anyhow!("Invalid workspace structure"))?;
            let member_name = relative_path.components().next()
                .and_then(|c| c.as_os_str().to_str())
                .ok_or_else(|| anyhow::anyhow!("Cannot determine member name from path"))?;
            if let Some(member) = members
                .into_iter()
                .find(|m| m.package.name == member_name)
            {
                (member, ws_root.clone().join(member_name))
            } else {
                // 不是成员，作为单个项目处理
                let proj = crate::config::loader::load_project(cwd)?;
                (proj, cwd.clone())
            }
        } else {
            // 实际上不是 workspace，作为单个项目处理
            let proj = crate::config::loader::load_project(cwd)?;
            (proj, cwd.clone())
        }
    } else {
        let proj = crate::config::loader::load_project(cwd)?;
        (proj, cwd.clone())
    };

    // 获取依赖
    let deps = if let Some(ws_root) = workspace_root_ref {
        let ws_proj = crate::config::loader::load_project(ws_root)?;
        crate::dependency::get_dependencies_with_workspace(&project, Some(&ws_proj))
    } else {
        crate::dependency::get_dependencies(&project)
    };

    // 设置 BSP 以支持 IDE
    let bsp_dir = workspace_root_ref.unwrap_or(&project_dir);
    let source_dirs = if let Some(ws_root) = workspace_root_ref {
        let member_name = project_dir.strip_prefix(ws_root)
            .map_err(|_| anyhow::anyhow!("Invalid project directory structure"))?
            .to_str()
            .ok_or_else(|| anyhow::anyhow!("Invalid UTF-8 in path"))?;
        vec![(member_name.to_string(), project.get_source_dir().to_string())]
    } else {
        vec![("".to_string(), project.get_source_dir().to_string())]
    };
    setup_bsp(bsp_dir, &deps, &source_dirs, project.get_backend()).await?;

    let target = file.unwrap_or_else(|| project.get_main_file_path());

    if !project_dir.join(&target).exists() {
        anyhow::bail!("File not found: {}", target.display());
    }

    if lib {
        let _ = run_scala_file(&project_dir, &target, true).await?;
        println!(
            "{}",
            crate::i18n::tf("lib_compiled_only", &[&target.display().to_string()])
        );
    } else {
        let output = run_single_file_with_deps(&project_dir, &target, &deps).await?;
        println!("{}", output);
    }

    Ok(())
}

/// 执行添加依赖命令
async fn execute_add(cwd: &PathBuf, deps: &[String]) -> anyhow::Result<()> {
    let workspace_root = loader::find_workspace_root(cwd);
    let project_dir = workspace_root.unwrap_or_else(|| cwd.clone());
    for dep in deps {
        add_dependency(&project_dir, dep).await?;
    }
    Ok(())
}


/// FILE: src/cli/commands/init.rs

use std::path::PathBuf;

pub async fn cmd_init(cwd: &PathBuf) -> anyhow::Result<()> {
    // Check if project.toml already exists
    let manifest_path = cwd.join("project.toml");
    if manifest_path.exists() {
        anyhow::bail!("{}", crate::i18n::t("config_file_already_exists"));
    }

    // Create workspace project.toml
    let manifest = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/workspace.project.toml.template"));
    tokio::fs::write(manifest_path, manifest).await?;

    println!("{}", crate::i18n::tf("initialized_empty_workspace", &[&cwd.display().to_string()]));
    Ok(())
}


/// FILE: src/cli/commands/mod.rs

// src/cli/commands/mod.rs
pub mod new;
pub mod init;
pub mod test;
pub mod workspace;


// 导出命令函数
pub use new::cmd_new;
pub use init::cmd_init;
pub use test::cmd_test;
pub use workspace::cmd_workspace;



/// 极致简化的命令定义宏
#[macro_export]
macro_rules! plugin_command {
    ($name:ident, $about:expr, $body:block) => {
        pub struct $name;

        #[async_trait::async_trait]
        impl crate::core::CommandHandler for $name {
            fn name(&self) -> &'static str {
                stringify!($name).to_lowercase().trim_end_matches("command")
            }

            fn about(&self) -> &'static str {
                $about
            }

            async fn execute(&self, matches: &clap::ArgMatches, cwd: &std::path::PathBuf) -> anyhow::Result<()> {
                $body
            }
        }

            inventory::submit! {
            Box::new($name) as Box<dyn crate::core::CommandHandler>
        }
    };
}

/// 超级简单的插件定义宏 - 无需了解内部细节
#[macro_export]
macro_rules! simple_plugin {
    ($cmd_name:literal, $description:literal, $config:expr, $handler:expr) => {
        paste::paste! {
            pub struct [<Simple $cmd_name:camel Plugin>];

            #[async_trait::async_trait]
            impl crate::core::CommandHandler for [<Simple $cmd_name:camel Plugin>] {
                fn name(&self) -> &'static str {
                    $cmd_name
                }

                fn about(&self) -> &'static str {
                    $description
                }

                fn configure(&self, cmd: clap::Command) -> clap::Command {
                    let config_fn = $config;
                    config_fn(cmd.about(self.about()))
                }

                async fn execute(&self, matches: &clap::ArgMatches, cwd: &std::path::PathBuf) -> anyhow::Result<()> {
                    let handler = $handler;
                    handler(matches.clone(), cwd.clone()).await
                }
            }

            // 导出插件结构体供注册使用
            pub use [<Simple $cmd_name:camel Plugin>] as [<plugin_ $cmd_name>];
        }
    };
}


/// FILE: src/cli/commands/new.rs

use std::path::PathBuf;

pub async fn cmd_new(cwd: &PathBuf, name: &str) -> anyhow::Result<()> {
    let proj_dir = cwd.join(name);
    if proj_dir.exists() {
        println!("{}", crate::i18n::tf("project_already_exists", &[name]));
        return Ok(());
    }
    tokio::fs::create_dir_all(proj_dir.join("src/main/scala")).await?;

    // project.toml
    let template = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/project.toml.template"));
    let manifest = template.replace("{name}", name);
    tokio::fs::write(proj_dir.join("project.toml"), manifest).await?;

    // Hello world
    let code = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/main.scala.template"));
    tokio::fs::write(
        proj_dir.join("src/main/scala/Main.scala"),
        code,
    )
    .await?;

    // Auto-add to workspace if in one
    if let Some(workspace_root) = crate::config::loader::find_workspace_root(cwd) {
        let manifest_path = workspace_root.join("project.toml");
        let relative_path = proj_dir.strip_prefix(&workspace_root)
            .unwrap_or(&proj_dir)
            .to_string_lossy()
            .to_string();
        match crate::config::writer::add_workspace_member(&manifest_path, &relative_path) {
            Ok(_) => {
                println!("{}", crate::i18n::tf("added_project_to_workspace", &[name]));
            }
            Err(e) => {
                if !e.to_string().contains("already exists") {
                    eprintln!("Warning: Failed to add project to workspace: {}", e);
                }
            }
        }
    }

    println!("{}", crate::i18n::tf("created_project", &[name]));
    Ok(())
}


/// FILE: src/cli/commands/test.rs

use std::path::PathBuf;

pub async fn cmd_test(cwd: &PathBuf, file: Option<PathBuf>) -> anyhow::Result<()> {
    let workspace_root = crate::config::loader::find_workspace_root(cwd);
    let (project, project_dir) = if let Some(ws_root) = workspace_root.as_ref() {
        // In workspace, check if this is a member project
        if let Some((_ws_proj, members)) = crate::config::loader::load_workspace(ws_root)? {
            let relative_path = cwd.strip_prefix(ws_root).unwrap();
            if let Some(first_component) = relative_path.components().next() {
                let member_name = first_component.as_os_str().to_str().unwrap();
                if let Some(member) = members.into_iter().find(|m| m.package.name == member_name) {
                    (member, ws_root.clone().join(member_name))
                } else {
                    // Not a workspace member, treat as standalone project
                    let proj = crate::config::loader::load_project(cwd)?;
                    (proj, cwd.clone())
                }
            } else {
                // cwd == ws_root, treat as standalone project
                let proj = crate::config::loader::load_project(cwd)?;
                (proj, cwd.clone())
            }
        } else {
            // No workspace config, treat as standalone project
            let proj = crate::config::loader::load_project(cwd)?;
            (proj, cwd.clone())
        }
    } else {
        let proj = crate::config::loader::load_project(cwd)?;
        (proj, cwd.clone())
    };

    let deps = if let Some(ws_root) = workspace_root {
        let ws_proj = crate::config::loader::load_project(&ws_root)?;
        crate::dependency::get_dependencies_with_workspace(&project, Some(&ws_proj))
    } else {
        crate::dependency::get_dependencies(&project)
    };

    let test_target = if let Some(f) = file {
        f
    } else {
        PathBuf::from(&project.package.test_dir)
    };

    let abs_test_target = project_dir.join(&test_target);

    if !abs_test_target.exists() {
        println!("No tests found in {}", test_target.display());
        return Ok(());
    }

    // Use scala-cli test
    let mut args: Vec<String> = vec!["test".to_string(), abs_test_target.to_string_lossy().to_string()];

    for dep in deps {
        args.push("--dependency".to_string());
        args.push(dep.coord());
    }

    let args_str: Vec<&str> = args.iter().map(|s| s.as_str()).collect();
    let output = crate::build::execute_scala_cli(&args_str, Some(&project_dir)).await?;

    if !output.is_empty() {
        println!("{}", output);
    }

    Ok(())
}


/// FILE: src/cli/commands/workspace.rs

use std::path::PathBuf;

use crate::cli::WorkspaceCommands;

pub async fn cmd_workspace(cwd: &PathBuf, subcommand: &WorkspaceCommands) -> anyhow::Result<()> {
    match subcommand {
        WorkspaceCommands::Add { paths } => {
            cmd_workspace_add(cwd, paths).await?;
        }
    }
    Ok(())
}

async fn cmd_workspace_add(cwd: &PathBuf, member_paths: &[String]) -> anyhow::Result<()> {
    // Find workspace root
    let workspace_root = crate::config::loader::find_workspace_root(cwd)
        .ok_or_else(|| anyhow::anyhow!("{}", crate::i18n::t("not_in_workspace")))?;

    let manifest_path = workspace_root.join("project.toml");

    for member_path in member_paths {
        // Check if member already exists by trying to add it
        match crate::config::writer::add_workspace_member(&manifest_path, member_path) {
            Ok(_) => {
                println!("{}", crate::i18n::tf("added_member_to_workspace", &[member_path]));
            }
            Err(_) => {
                println!("{}", crate::i18n::tf("member_already_exists", &[member_path]));
            }
        }
    }
    Ok(())
}


/// FILE: src/cli/mod.rs

// src/cli/mod.rs
use clap::{Arg, Command};

pub mod commands;
pub mod builtin;
pub mod parser;



#[derive(Debug)]
pub struct Cli {
    pub command: Option<Commands>,
    pub raw_matches: clap::ArgMatches,
}

impl std::ops::Deref for Cli {
    type Target = Option<Commands>;

    fn deref(&self) -> &Self::Target {
        &self.command
    }
}


// 命令枚举定义
#[derive(Debug, Clone)]
pub enum Commands {
    New {name: String},
    Init,
    Build,
    Run {file: Option<std::path::PathBuf>,lib: bool,},
    Add {deps: Vec<String>,},
    Test {file: Option<std::path::PathBuf>,},
    Workspace {subcommand: WorkspaceCommands,},
    Jsp {name: String,},
}


#[derive(clap::Subcommand, Debug, Clone)]
pub enum WorkspaceCommands {
    Add {paths: Vec<String>,},
}

impl Cli {
    pub fn parse() -> Self {
        Self::parse_with_plugins(&[])
    }

    pub fn parse_with_plugins(plugins: &[Box<dyn crate::core::CommandHandler>]) -> Self {
        let mut cmd = Command::new("sinter")
            .about(crate::i18n::t("main_about"))
            .subcommand(
                Command::new("new")
                    .about(crate::i18n::t("new_about"))
                    .arg(
                        Arg::new("name")
                            .help(crate::i18n::t("new_name_help"))
                            .required(true)
                    )
            )
            .subcommand(
                Command::new("init")
                    .about(crate::i18n::t("init_about"))
            )
            .subcommand(
                Command::new("build")
                    .about(crate::i18n::t("build_about"))
            )
            .subcommand(
                Command::new("run")
                    .about(crate::i18n::t("run_about"))
                    .arg(
                        Arg::new("file")
                            .help(crate::i18n::t("run_file_help"))
                            .value_name("FILE")
                    )
                    .arg(
                        Arg::new("lib")
                            .long("lib")
                            .help(crate::i18n::t("run_lib_help"))
                            .action(clap::ArgAction::SetTrue)
                    )
            )
            .subcommand(
                Command::new("add")
                    .about(crate::i18n::t("add_about"))
                    .arg(
                        Arg::new("dep")
                            .help(crate::i18n::t("add_dep_help"))
                            .value_name("DEP")
                            .required(true)
                            .num_args(1..)
                    )
            )
            .subcommand(
                Command::new("test")
                    .about(crate::i18n::t("test_about"))
                    .arg(
                        Arg::new("file")
                            .help(crate::i18n::t("test_file_help"))
                            .value_name("FILE")
                    )
            )
            .subcommand(
                Command::new("workspace")
                    .about(crate::i18n::t("workspace_about"))
                    .subcommand(
                        Command::new("add")
                            .about(crate::i18n::t("workspace_add_about"))
                            .arg(
                                Arg::new("path")
                                    .help(crate::i18n::t("workspace_add_path_help"))
                                    .value_name("PATH")
                                    .required(true)
                                    .num_args(1..)
                            )
                    )
            );

        // 自动添加所有插件命令
        for handler in plugins {
            cmd = cmd.subcommand(handler.configure(Command::new(handler.name())));
        }

        let matches = cmd.get_matches();

        let command = parser::parse_command_from_matches(&matches);

        Cli { command, raw_matches: matches }
    }
}


/// FILE: src/cli/parser.rs

// src/cli/parser.rs
use super::{Commands, WorkspaceCommands};

// 辅助函数：安全提取必需的字符串参数
fn extract_required_string(matches: &clap::ArgMatches, key: &str) -> String {
    matches.get_one::<String>(key).unwrap().clone()
}

// 辅助函数：安全提取可选的字符串参数并转换为PathBuf
fn extract_optional_path(matches: &clap::ArgMatches, key: &str) -> Option<std::path::PathBuf> {
    matches.get_one::<String>(key).map(|s| std::path::PathBuf::from(s))
}

pub fn parse_command_from_matches(matches: &clap::ArgMatches) -> Option<Commands> {
    match matches.subcommand() {
        Some(("new", sub_m)) => Some(Commands::New {
            name: extract_required_string(sub_m, "name"),
        }),
        Some(("init", _)) => Some(Commands::Init),
        Some(("build", _)) => Some(Commands::Build),
        Some(("run", sub_m)) => Some(Commands::Run {
            file: extract_optional_path(sub_m, "file"),
            lib: sub_m.get_flag("lib"),
        }),
        Some(("add", sub_m)) => Some(Commands::Add {
            deps: sub_m.get_many::<String>("dep").unwrap_or_default().map(|s| s.to_string()).collect(),
        }),
        Some(("test", sub_m)) => Some(Commands::Test {
            file: extract_optional_path(sub_m, "file"),
        }),
        Some(("workspace", ws_m)) => match ws_m.subcommand() {
            Some(("add", sub_m)) => Some(Commands::Workspace {
                subcommand: WorkspaceCommands::Add {
                    paths: sub_m.get_many::<String>("path").unwrap_or_default().map(|s| s.to_string()).collect(),
                }
            }),
            _ => None,
        },
        Some(("jsp", sub_m)) => Some(Commands::Jsp {
            name: extract_required_string(sub_m, "name"),
        }),
        _ => None,
    }
}


/// FILE: src/config/loader.rs

//! 配置加载器
//!
//! 负责从文件系统加载和解析配置文件

use std::path::{Path, PathBuf};
use anyhow::Context;
use config::Config;

use crate::domain::*;

/// 加载项目配置
pub fn load_project(dir: &Path) -> anyhow::Result<Project> {
    let manifest_path = dir.join("project.toml");
    let settings = Config::builder()
        .add_source(config::File::from(manifest_path))
        .build()
        .context("Failed to load project configuration")?;
    let proj: Project = settings.try_deserialize()
        .context("Failed to parse project configuration")?;

    // 验证配置
    if let Err(errors) = proj.validate() {
        return Err(anyhow::anyhow!("项目配置验证失败:\n{}", errors.join("\n")));
    }

    Ok(proj)
}

/// 异步版本的项目配置加载
pub async fn load_project_async(dir: &Path) -> anyhow::Result<Project> {
    // 对于异步操作，如果需要可以扩展
    load_project(dir)
}

/// 查找工作空间根目录
pub fn find_workspace_root(start_dir: &Path) -> Option<PathBuf> {
    let mut current = start_dir;
    loop {
        let manifest = current.join("project.toml");
        if manifest.exists() {
            if let Ok(settings) = Config::builder()
                .add_source(config::File::from(manifest.clone()))
                .build()
            {
                if let Ok(project) = settings.try_deserialize::<Project>() {
                    if project.workspace.is_some() {
                        return Some(current.to_path_buf());
                    }
                }
            }
        }
        if let Some(parent) = current.parent() {
            current = parent;
        } else {
            break;
        }
    }
    None
}

/// 加载工作空间配置
pub fn load_workspace(dir: &Path) -> anyhow::Result<Option<(Project, Vec<Project>)>> {
    let manifest_path = dir.join("project.toml");
    if !manifest_path.exists() {
        return Ok(None);
    }

    let settings = Config::builder()
        .add_source(config::File::from(manifest_path))
        .build()
        .context("Failed to load workspace configuration")?;

    let root_project: Project = settings.try_deserialize()
        .context("Failed to parse workspace configuration")?;

    if let Some(workspace) = &root_project.workspace {
        let mut members = Vec::new();
        for member_path in &workspace.members {
            let member_dir = dir.join(member_path);
            let member_project = load_project(&member_dir)
                .with_context(|| format!("Failed to load workspace member: {}", member_path))?;
            members.push(member_project);
        }
        Ok(Some((root_project, members)))
    } else {
        Ok(None)
    }
}


/// FILE: src/config/mod.rs

//! 配置管理模块
//!
//! 提供配置文件的加载、解析和写入功能

pub mod loader;
pub mod writer;

// 重新导出主要类型和函数
pub use loader::*;
pub use writer::*;


/// FILE: src/config/writer.rs

//! 配置写入器
//!
//! 负责修改和写入配置文件

use std::path::Path;
use anyhow::Context;
use toml_edit::{value, DocumentMut, Item, Table};

/// 向项目manifest添加依赖
pub fn add_dependency_to_manifest(manifest_path: &Path, key: &str, version: &str) -> anyhow::Result<()> {
    modify_toml_document(manifest_path, |doc| {
        // 确保 dependencies 表存在
        ensure_table_exists(doc, "dependencies");

        let deps_item = doc.get_mut("dependencies").unwrap();
        if let Some(deps_table) = deps_item.as_table_mut() {
            deps_table[key] = value(version.to_string());
            format_table(deps_table);
        }
        Ok(())
    })
}

/// 向工作空间manifest添加依赖
pub fn add_workspace_dependency_to_manifest(manifest_path: &Path, key: &str, version: &str) -> anyhow::Result<()> {
    modify_toml_document(manifest_path, |doc| {
        // 确保 workspace 表存在
        ensure_table_exists(doc, "workspace");

        let ws_item = doc.get_mut("workspace").unwrap();
        if let Some(ws_table) = ws_item.as_table_mut() {
            // 确保 workspace.dependencies 表存在
            ensure_table_exists_in_table(ws_table, "dependencies");

            if let Some(deps_item) = ws_table.get_mut("dependencies") {
                if let Some(deps_table) = deps_item.as_table_mut() {
                    deps_table[key] = value(version.to_string());
                    format_table(deps_table);
                }
            }
        }
        Ok(())
    })
}

/// 添加工作空间成员
pub fn add_workspace_member(manifest_path: &Path, member_path: &str) -> anyhow::Result<()> {
    modify_toml_document(manifest_path, |doc| {
        // 确保 workspace 表存在
        ensure_table_exists(doc, "workspace");

        let ws_item = doc.get_mut("workspace").unwrap();
        if let Some(ws_table) = ws_item.as_table_mut() {
            // 确保 members 数组存在
            if !ws_table.contains_key("members") {
                ws_table.insert("members", Item::Value(toml_edit::Value::Array(Default::default())));
            }

            if let Some(members_item) = ws_table.get_mut("members") {
                if let Some(members_array) = members_item.as_array_mut() {
                    // 检查成员是否已存在
                    let exists = members_array.iter().any(|v| v.as_str() == Some(member_path));
                    if exists {
                        anyhow::bail!("Member '{}' already exists in workspace", member_path);
                    }
                    members_array.push(member_path);
                }
            }
        }
        Ok(())
    })
}

/// 通用TOML文档修改函数
fn modify_toml_document<F>(manifest_path: &Path, modifier: F) -> anyhow::Result<()>
where
    F: FnOnce(&mut DocumentMut) -> anyhow::Result<()>,
{
    let content = std::fs::read_to_string(manifest_path)
        .with_context(|| format!("Failed to read file: {}", manifest_path.display()))?;

    let mut doc: DocumentMut = content
        .parse()
        .context("Failed to parse TOML document")?;

    modifier(&mut doc)?;

    std::fs::write(manifest_path, doc.to_string())
        .with_context(|| format!("Failed to write file: {}", manifest_path.display()))?;

    Ok(())
}

/// 确保表存在
fn ensure_table_exists(doc: &mut DocumentMut, key: &str) {
    if !doc.contains_key(key) {
        doc.insert(key, Item::Table(Table::new()));
    }
}

/// 确保子表存在
fn ensure_table_exists_in_table(table: &mut Table, key: &str) {
    if !table.contains_key(key) {
        table.insert(key, Item::Table(Table::new()));
    }
}

/// 格式化表
fn format_table(table: &mut Table) {
    let decor = table.decor_mut();
    decor.set_prefix("\n");
    decor.set_suffix("\n");
}


/// FILE: src/config_compat.rs

//! 配置兼容性层
//!
//! 提供向后兼容的配置函数，这些函数委托给新的模块化实现

use crate::domain::*;
use crate::deps::Dependency;

/// 获取项目依赖（兼容性函数）
#[deprecated(note = "Use dependency resolver instead")]
pub fn get_dependencies(project: &Project) -> Vec<Dependency> {
    project.dependencies
        .iter()
        .filter_map(|(k, spec)| match spec {
            DependencySpec::Simple(version) => {
                Some(Dependency::from_toml_key(k, &version))
            }
            DependencySpec::Detailed(detail) => {
                detail.version.as_ref().map(|v| Dependency::from_toml_key(k, v))
            }
        })
        .collect()
}

/// 获取包含工作空间的依赖（兼容性函数）
#[deprecated(note = "Use dependency resolver instead")]
pub fn get_dependencies_with_workspace(project: &Project, workspace_root: Option<&Project>) -> Vec<Dependency> {
    let mut deps = Vec::new();

    for (k, spec) in &project.dependencies {
        match spec {
            DependencySpec::Simple(version) => {
                deps.push(Dependency::from_toml_key(k, &version));
            }
            DependencySpec::Detailed(detail) => {
                if detail.workspace {
                    if let Some(ws) = workspace_root {
                        if let Some(ws_config) = &ws.workspace {
                            if let Some(ws_spec) = ws_config.dependencies.get(k) {
                                match ws_spec {
                                    DependencySpec::Simple(version) => {
                                        deps.push(Dependency::from_toml_key(k, &version));
                                    }
                                    DependencySpec::Detailed(ws_detail) => {
                                        if let Some(version) = &ws_detail.version {
                                            deps.push(Dependency::from_toml_key(k, version));
                                        }
                                    }
                                }
                            } else {
                                eprintln!("Warning: dependency '{}' marked as workspace but not found in workspace root", k);
                            }
                        }
                    }
                } else if let Some(version) = &detail.version {
                    deps.push(Dependency::from_toml_key(k, version));
                }
            }
        }
    }

    deps
}

/// 获取传递依赖（兼容性函数）
#[deprecated(note = "Use dependency resolver instead")]
pub async fn get_transitive_dependencies_with_workspace(
    project: &Project,
    workspace_root: Option<&Project>,
    project_dir: &std::path::Path,
) -> anyhow::Result<Vec<Dependency>> {
    let direct_deps = get_dependencies_with_workspace(project, workspace_root);
    let mut dep_manager = crate::deps::default_dependency_manager().await;
    dep_manager.set_project_dir(project_dir);
    dep_manager.get_transitive_dependencies(&direct_deps).await
}

/// 获取主文件路径（兼容性函数）
#[deprecated(note = "Use Project::get_main_file_path() instead")]
pub fn get_main_file_path(project: &Project) -> std::path::PathBuf {
    project.get_main_file_path()
}


/// FILE: src/core/app.rs

//! Sinter 应用构建器
//!
//! 使用函数式 Builder 模式构建应用，支持链式注册插件

use crate::core::handler::CommandHandler;
use crate::cli::Cli;
use crate::runtime::Executor;

/// Sinter 应用构建器
///
/// 使用 Builder 模式，支持链式调用注册插件：
///
/// ```rust
/// Sinter::new()
///     .plugin(my_plugin())
///     .plugin(another_plugin())
///     .run()
///     .await?;
/// ```
pub struct Sinter {
    plugins: Vec<Box<dyn CommandHandler>>,
}

impl Sinter {
    /// 创建新的 Sinter 应用
    pub fn new() -> Self {
        Self {
            plugins: Vec::new(),
        }
    }

    /// 注册单个插件
    ///
    /// 支持链式调用
    pub fn plugin<H: CommandHandler + 'static>(mut self, handler: H) -> Self {
        self.plugins.push(Box::new(handler));
        self
    }

    /// 批量注册插件
    ///
    /// 可以传入一个迭代器，一次性注册多个插件
    pub fn plugins<H: CommandHandler + 'static, I: IntoIterator<Item = H>>(
        mut self,
        handlers: I,
    ) -> Self {
        for handler in handlers {
            self.plugins.push(Box::new(handler));
        }
        self
    }

    /// 运行应用
    ///
    /// 解析命令行参数，执行对应的命令
    pub async fn run(self) -> anyhow::Result<()> {
        let cli = Cli::parse_with_plugins(&self.plugins);
        let cwd = std::env::current_dir()?;
        Executor::new(self.plugins).execute(cli, cwd).await
    }
}

impl Default for Sinter {
    fn default() -> Self {
        Self::new()
    }
}




/// FILE: src/core/handler.rs

//! 命令处理器 trait
//!
//! 所有命令（包括内置命令和插件）都需要实现这个 trait

use async_trait::async_trait;
use clap::{ArgMatches, Command};
use std::path::PathBuf;

/// 命令处理器 trait
///
/// 实现这个 trait 就可以创建一个新的命令。
/// 无论是内置命令还是插件，都使用相同的接口。
#[async_trait]
pub trait CommandHandler: Send + Sync {
    /// 返回命令名称
    ///
    /// 例如：`"new"`, `"build"`, `"jsp"` 等
    fn name(&self) -> &'static str;

    /// 返回命令描述
    ///
    /// 这个描述会显示在帮助信息中
    fn about(&self) -> &'static str;

    /// 配置命令参数
    ///
    /// 默认实现会设置命令名称和描述。
    /// 如果需要添加参数，可以重写这个方法。
    fn configure(&self, cmd: Command) -> Command {
        cmd.name(self.name()).about(self.about())
    }

    /// 执行命令逻辑
    ///
    /// 这是命令的核心逻辑，当用户运行命令时会被调用。
    async fn execute(&self, matches: &ArgMatches, cwd: &PathBuf) -> anyhow::Result<()>;
}




/// FILE: src/core/mod.rs

//! 核心模块
//!
//! 包含插件系统的核心 trait 和应用结构

pub mod handler;
pub mod app;

pub use handler::CommandHandler;
pub use app::Sinter;




/// FILE: src/dependency/coursier_resolver.rs

//! Coursier依赖解析器

use crate::domain::Project;
use crate::deps::Dependency;
use super::resolver::DependencyResolver;

pub struct CoursierResolver;

impl DependencyResolver for CoursierResolver {
    fn resolve_dependencies(&self, project: &Project) -> Vec<Dependency> {
        // TODO: 实现Coursier依赖解析
        Vec::new()
    }

    fn resolve_dependencies_with_workspace(&self, project: &Project, workspace_root: Option<&Project>) -> Vec<Dependency> {
        // TODO: 实现包含工作空间的Coursier依赖解析
        Vec::new()
    }
}


/// FILE: src/dependency/mod.rs

//! 依赖管理模块
//!
//! 提供依赖解析和管理功能

pub mod resolver;
pub mod coursier_resolver;
pub mod scala_cli_resolver;
pub mod sbt_resolver;

// Re-export for convenience
pub use resolver::*;


/// FILE: src/dependency/resolver.rs

//! 依赖解析接口

use crate::domain::{Project, DependencySpec, DependencyDetail};
use crate::deps::Dependency;

/// 依赖解析器trait
pub trait DependencyResolver {
    /// 解析项目依赖
    fn resolve_dependencies(&self, project: &Project) -> Vec<Dependency>;

    /// 解析包含工作空间的依赖
    fn resolve_dependencies_with_workspace(&self, project: &Project, workspace_root: Option<&Project>) -> Vec<Dependency>;
}

/// 获取项目依赖
pub fn get_dependencies(project: &Project) -> Vec<Dependency> {
    project.dependencies
        .iter()
        .filter_map(|(k, spec)| match spec {
            DependencySpec::Simple(version) => {
                Some(Dependency::from_toml_key(k, &version))
            }
            DependencySpec::Detailed(detail) => {
                detail.version.as_ref().map(|v| Dependency::from_toml_key(k, v))
            }
        })
        .collect()
}

/// 获取包含工作空间的依赖
pub fn get_dependencies_with_workspace(project: &Project, workspace_root: Option<&Project>) -> Vec<Dependency> {
    let mut deps = Vec::new();

    for (k, spec) in &project.dependencies {
        match spec {
            DependencySpec::Simple(version) => {
                deps.push(Dependency::from_toml_key(k, &version));
            }
            DependencySpec::Detailed(detail) => {
                if detail.workspace {
                    if let Some(ws) = workspace_root {
                        if let Some(ws_config) = &ws.workspace {
                            if let Some(ws_spec) = ws_config.dependencies.get(k) {
                                match ws_spec {
                                    DependencySpec::Simple(version) => {
                                        deps.push(Dependency::from_toml_key(k, &version));
                                    }
                                    DependencySpec::Detailed(ws_detail) => {
                                        if let Some(version) = &ws_detail.version {
                                            deps.push(Dependency::from_toml_key(k, version));
                                        }
                                    }
                                }
                            } else {
                                eprintln!("Warning: dependency '{}' marked as workspace but not found in workspace root", k);
                            }
                        }
                    }
                } else if let Some(version) = &detail.version {
                    deps.push(Dependency::from_toml_key(k, version));
                }
            }
        }
    }

    deps
}

/// 获取传递依赖
pub async fn get_transitive_dependencies_with_workspace(
    project: &Project,
    workspace_root: Option<&Project>,
    project_dir: &std::path::Path,
) -> anyhow::Result<Vec<Dependency>> {
    let direct_deps = get_dependencies_with_workspace(project, workspace_root);
    let mut dep_manager = crate::deps::default_dependency_manager().await;
    dep_manager.set_project_dir(project_dir);
    dep_manager.get_transitive_dependencies(&direct_deps).await
}


/// FILE: src/dependency/sbt_resolver.rs

//! SBT依赖解析器

use crate::domain::Project;
use crate::deps::Dependency;
use super::resolver::DependencyResolver;

pub struct SbtResolver;

impl DependencyResolver for SbtResolver {
    fn resolve_dependencies(&self, project: &Project) -> Vec<Dependency> {
        // TODO: 实现SBT依赖解析
        Vec::new()
    }

    fn resolve_dependencies_with_workspace(&self, project: &Project, workspace_root: Option<&Project>) -> Vec<Dependency> {
        // TODO: 实现包含工作空间的SBT依赖解析
        Vec::new()
    }
}


/// FILE: src/dependency/scala_cli_resolver.rs

//! Scala CLI依赖解析器

use crate::domain::Project;
use crate::deps::Dependency;
use super::resolver::DependencyResolver;

pub struct ScalaCliResolver;

impl DependencyResolver for ScalaCliResolver {
    fn resolve_dependencies(&self, project: &Project) -> Vec<Dependency> {
        // TODO: 实现Scala CLI依赖解析
        Vec::new()
    }

    fn resolve_dependencies_with_workspace(&self, project: &Project, workspace_root: Option<&Project>) -> Vec<Dependency> {
        // TODO: 实现包含工作空间的Scala CLI依赖解析
        Vec::new()
    }
}


/// FILE: src/deps/add.rs

use std::path::Path;

pub async fn add_dependency(project_dir: &Path, dep_spec: &str) -> anyhow::Result<()> {
    let project = crate::config::loader::load_project(project_dir)?;
    let manifest_path = project_dir.join("project.toml");

    // 检测是否在工作空间根目录
    let is_workspace_root = project.workspace.is_some();

    // Check if it's an sbt path
    if dep_spec.starts_with("sbt:") || (dep_spec.contains("/") && !dep_spec.contains("::")) {
        let sbt_path = if dep_spec.starts_with("sbt:") {
            dep_spec[4..].to_string()
        } else {
            dep_spec.to_string()
        };

        // Validate that the sbt project exists
        let sbt_project_path = project_dir.join(&sbt_path);
        if !sbt_project_path.exists() {
            anyhow::bail!("sbt project path does not exist: {}", sbt_path);
        }

        let key = format!("sbt:{}", sbt_path);
        // 如果在工作空间根目录，添加到 workspace.dependencies
        if is_workspace_root {
            crate::config::writer::add_workspace_dependency_to_manifest(&manifest_path, &key, "")?;
            println!("{}", crate::i18n::tf("added_dependency", &[&key, "sbt project (workspace)"]));
        } else {
            crate::config::writer::add_dependency_to_manifest(&manifest_path, &key, "")?;
            println!("{}", crate::i18n::tf("added_dependency", &[&key, "sbt project"]));
        }
        return Ok(());
    }

    let (artifact, scala_ver, version) = parse_dep_spec(dep_spec, &project.package.scala_version).await?;

    let key = artifact.clone();

    // 对于Java依赖（artifact包含单冒号），不添加Scala版本后缀
    let full_key = if artifact.contains(':') && !artifact.contains("::") {
        // Java依赖格式：group:artifact
        key
    } else if !scala_ver.is_empty() && scala_ver != "latest" {
        format!("{}_{}", key, scala_ver)
    } else {
        key
    };

    // 使用依赖管理器验证依赖是否可用
    let dep_manager = crate::deps::default_dependency_manager().await;
    let dep = crate::deps::deps::Dependency::from_toml_key(&full_key, &version);
    
    // 验证依赖是否可用
    if let Err(e) = dep_manager.validate_dependency(&dep).await {
        anyhow::bail!("Failed to validate dependency {}: {}\nPlease check that the dependency coordinates are correct and the version exists.", full_key, e);
    }

    // 如果验证通过，下载依赖（使用coursier时会预先下载并缓存）
    if let Err(e) = dep_manager.prepare_dependencies(&[dep.clone()], &project_dir.join("target")).await {
        anyhow::bail!("Failed to download dependency {}: {}\nPlease check your network connection and try again.", full_key, e);
    }

    // 如果在工作空间根目录，添加到 workspace.dependencies
    if is_workspace_root {
        crate::config::writer::add_workspace_dependency_to_manifest(&manifest_path, &full_key, &version)?;
        println!("{}", crate::i18n::tf("added_dependency", &[&full_key, &format!("{} (workspace)", version)]));
    } else {
        crate::config::writer::add_dependency_to_manifest(&manifest_path, &full_key, &version)?;
        println!("{}", crate::i18n::tf("added_dependency", &[&full_key, &version]));
    }
    Ok(())
}


async fn parse_dep_spec(spec: &str, default_scala_version: &str) -> anyhow::Result<(String, String, String)> {
    // 检查是否是Scala依赖（使用::）还是Java依赖（使用:）
    let is_scala_format = spec.contains("::");

    let (group, artifact_version, is_scala) = if is_scala_format {
        // Scala格式：group::artifact:version
        let parts: Vec<&str> = spec.split("::").collect();
        if parts.len() != 2 {
            anyhow::bail!("{}", crate::i18n::t("invalid_dependency_format"));
        }
        let group = parts[0];
        let artifact_version = parts[1];
        (group, artifact_version, true)
    } else {
        // Java格式：group:artifact:version
        let parts: Vec<&str> = spec.split(':').collect();
        if parts.len() != 3 {
            anyhow::bail!("{}", crate::i18n::t("invalid_dependency_format"));
        }
        let group = parts[0];
        let artifact = parts[1];
        let version = parts[2];
        // 对于Java格式，直接返回，不需要进一步解析
        let full_artifact = format!("{}:{}", group, artifact);
        return Ok((full_artifact, "".to_string(), version.to_string()));
    };

    let av_parts: Vec<&str> = artifact_version.split(':').collect();
    if av_parts.len() != 2 {
        anyhow::bail!("{}", crate::i18n::t("invalid_dependency_format"));
    }

    let artifact_with_scala = av_parts[0];
    let version = av_parts[1];

    // 检查artifact是否包含::，如果是，则报错，因为artifact不应该有::
    if artifact_with_scala.contains("::") {
        anyhow::bail!("{}", crate::i18n::t("invalid_artifact_format"));
    }

    let artifact_parts: Vec<&str> = artifact_with_scala.split('@').collect();
    let (artifact, scala_ver) = if artifact_parts.len() == 2 {
        (artifact_parts[0].to_string(), artifact_parts[1])
    } else {
        (artifact_with_scala.to_string(), default_scala_version)
    };

    let full_artifact = format!("{}::{}", group, artifact);

    if version.is_empty() || version == "latest" {
        anyhow::bail!("{}", crate::i18n::t("version_must_be_specified"));
    }

    Ok((full_artifact, scala_ver.to_string(), version.to_string()))
}



/// FILE: src/deps/deps.rs

// src/deps.rs
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone)]
pub enum Dependency {
    Maven {
        group: String,
        artifact: String,
        version: String,
        is_scala: bool,
    },
    Sbt {
        path: String,
    },
}

impl Dependency {
    pub fn from_toml_key(key: &str, version: &str) -> Self {
        // Check if it's an sbt path (starts with sbt: or is a relative path)
        if key.starts_with("sbt:") || (key.contains("/") && !key.contains("::") && !key.contains(":")) {
            let path = if key.starts_with("sbt:") {
                key[4..].to_string()
            } else {
                key.to_string()
            };
            Self::Sbt { path }
        } else {
            // Check for Scala dependency (::) or Java dependency (:)
            let is_scala = key.contains("::");
            let parts: Vec<&str> = if is_scala {
                key.split("::").collect()
            } else if key.contains(":") {
                key.split(":").collect()
            } else {
                vec!["", key]
            };

            let (group, artifact) = if parts.len() >= 2 {
                (parts[0].to_string(), parts[1].to_string())
            } else {
                ("".to_string(), key.to_string())
            };
            Self::Maven {
                group,
                artifact,
                version: version.to_string(),
                is_scala,
            }
        }
    }

    // 生成 Maven 坐标：group:artifact:version 或 group::artifact:version 或 sbt 路径
    pub fn coord(&self) -> String {
        match self {
            Dependency::Maven { group, artifact, version, is_scala } => {
                if *is_scala {
                    format!("{}::{}:{}", group, artifact, version)
                } else {
                    format!("{}:{}:{}", group, artifact, version)
                }
            }
            Dependency::Sbt { path } => {
                format!("sbt:{}", path)
            }
        }
    }

    pub fn is_sbt(&self) -> bool {
        matches!(self, Dependency::Sbt { .. })
    }

    pub fn sbt_path(&self) -> Option<&str> {
        match self {
            Dependency::Sbt { path } => Some(path),
            _ => None,
        }
    }
}




/// FILE: src/deps/manager.rs

use crate::deps::deps::Dependency;
use std::path::{Path, PathBuf};
use tokio::process::Command;
use std::sync::atomic::{AtomicBool, Ordering};
use std::collections::HashSet;
use anyhow::anyhow;



// --- 核心 Trait 和辅助函数 ---

/// 抽象的依赖管理器trait
#[async_trait::async_trait]
pub trait DependencyManager: Send + Sync {
    /// 准备依赖（下载、构建等）
    async fn prepare_dependencies(&self, deps: &[Dependency], target_dir: &Path) -> anyhow::Result<()>;

    /// 获取构建命令的参数
    fn get_build_args(&self, deps: &[Dependency]) -> Vec<String>;

    /// 获取运行命令的参数
    fn get_run_args(&self, deps: &[Dependency]) -> Vec<String>;

    /// 验证依赖是否可用（用于添加依赖时）
    async fn validate_dependency(&self, dep: &Dependency) -> anyhow::Result<()>;

    /// 获取传递依赖（包括直接依赖和所有传递依赖）
    async fn get_transitive_dependencies(&self, deps: &[Dependency]) -> anyhow::Result<Vec<Dependency>>;

    /// 设置项目目录（用于解析相对路径）
    fn set_project_dir(&mut self, project_dir: &Path);
}

/// 获取打包的coursier可执行文件路径
fn get_bundled_coursier_path() -> Option<PathBuf> {
    let exe_name = if cfg!(target_os = "windows") {
        "coursier.exe"
    } else {
        "coursier"
    };
    
    // 1. 尝试从bin目录（相对于可执行文件）
    if let Ok(exe) = std::env::current_exe() {
        if let Some(exe_dir) = exe.parent() {
            let bundled_path = exe_dir.join("bin").join(exe_name);
            if bundled_path.exists() {
                return Some(bundled_path);
            }
        }
    }
    
    // 2. 尝试从CARGO_MANIFEST_DIR/bin目录（开发时）
    if let Ok(manifest_dir) = std::env::var("CARGO_MANIFEST_DIR") {
        let bundled_path = PathBuf::from(manifest_dir).join("bin").join(exe_name);
        if bundled_path.exists() {
            return Some(bundled_path);
        }
    }
    
    None
}

/// 获取coursier可执行文件路径
async fn get_coursier_path() -> Option<String> {
    // 首先尝试使用打包的coursier
    if let Some(bundled_path) = get_bundled_coursier_path() {
        // 确保文件有执行权限
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            if let Ok(mut perms) = std::fs::metadata(&bundled_path).map(|m| m.permissions()) {
                perms.set_mode(0o755);
                let _ = std::fs::set_permissions(&bundled_path, perms);
            }
        }
        
        if let Some(path_str) = bundled_path.to_str() {
            // 验证打包的coursier是否可用
            let mut cmd = Command::new(path_str);
            cmd.arg("--version");
            // 使用 timeout 避免卡死，尽管 tokio::process::Command 默认没有
            if cmd.output().await.map(|o| o.status.success()).unwrap_or(false) {
                return Some(path_str.to_string());
            }
        }
    }
    
    // 回退到系统命令
    if check_command_available("coursier").await {
        Some("coursier".to_string())
    } else {
        None
    }
}

/// 检查命令是否可用
async fn check_command_available(cmd: &str) -> bool {
    Command::new(cmd)
        .arg("--version")
        .output()
        .await
        .map(|o| o.status.success())
        .unwrap_or(false)
}

static COURSIER_WARNING_PRINTED: AtomicBool = AtomicBool::new(false);

/// 检查coursier是否可用，如果不可用则打印安装提示（仅一次）
pub async fn check_coursier_available() -> bool {
    let available = get_coursier_path().await.is_some();
    if !available {
        // 只打印一次警告
        if !COURSIER_WARNING_PRINTED.swap(true, Ordering::Relaxed) {
            eprintln!("Warning: coursier is not available. For better dependency management:");
            eprintln!("  - Install coursier: curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-pc-linux.gz | gzip -d > cs && chmod +x cs && ./cs install coursier");
            eprintln!("  - Or visit: https://get-coursier.io/");
            eprintln!("  Falling back to scala-cli for dependency management.");
        }
    }
    available
}

// --- Coursier 实现 ---

/// Coursier 依赖管理器
pub struct CoursierDependencyManager {
    project_dir: Option<PathBuf>,
}

impl CoursierDependencyManager {
    pub fn new() -> Self {
        Self { project_dir: None }
    }
}

#[async_trait::async_trait]
impl DependencyManager for CoursierDependencyManager {
    async fn prepare_dependencies(&self, deps: &[Dependency], _target_dir: &Path) -> anyhow::Result<()> {
        let coursier_path = get_coursier_path().await
            .ok_or_else(|| anyhow!("coursier is not available"))?;
        
        for dep in deps {
            match dep {
                Dependency::Maven { .. } => {
                    // 使用coursier fetch下载依赖（这会自动缓存）
                    let mut cmd = Command::new(&coursier_path);
                    cmd.arg("fetch")
                        .arg("--quiet")
                        .arg(dep.coord());
                    
                    let output = cmd.output().await?;
                    if !output.status.success() {
                        let err = String::from_utf8_lossy(&output.stderr);
                        anyhow::bail!("Failed to fetch dependency {}: {}", dep.coord(), err);
                    }
                }
                Dependency::Sbt { path } => {
                    // 验证sbt项目存在
                    let sbt_project_path = Path::new(path);
                    if !sbt_project_path.exists() {
                        anyhow::bail!("sbt project path does not exist: {}", path);
                    }
                }
            }
        }
        
        Ok(())
    }

    fn get_build_args(&self, deps: &[Dependency]) -> Vec<String> {
        let mut args = Vec::new();

        for dep in deps {
            match dep {
                Dependency::Maven { .. } => {
                    args.push("--dependency".to_string());
                    args.push(dep.coord());
                }
                Dependency::Sbt { path } => {
                    // 统一使用 file:// 格式，无论是相对路径还是绝对路径
                    let dep_path = if Path::new(path).is_relative() {
                        // 使用 project_dir 来解析相对路径
                        self.project_dir.as_ref()
                            .map(|dir| dir.join(path))
                            .unwrap_or_else(|| PathBuf::from(path))
                            .to_string_lossy()
                            .to_string()
                    } else {
                        path.clone()
                    };
                    
                    args.push("--dependency".to_string());
                    args.push(format!("file://{}", dep_path));
                }
            }
        }

        args
    }

    fn get_run_args(&self, deps: &[Dependency]) -> Vec<String> {
        self.get_build_args(deps)
    }

    async fn validate_dependency(&self, dep: &Dependency) -> anyhow::Result<()> {
        let coursier_path = get_coursier_path().await
            .ok_or_else(|| anyhow!("coursier is not available"))?;

        match dep {
            Dependency::Maven { .. } => {
                // 使用coursier resolve验证依赖是否存在
                let mut cmd = Command::new(&coursier_path);
                cmd.arg("resolve")
                    .arg("--quiet")
                    .arg(dep.coord());

                let output = cmd.output().await?;
                if !output.status.success() {
                    let err = String::from_utf8_lossy(&output.stderr);
                    anyhow::bail!("Dependency {} is not available: {}", dep.coord(), err);
                }
                Ok(())
            }
            Dependency::Sbt { path } => {
                let sbt_project_path = Path::new(path);
                if !sbt_project_path.exists() {
                    anyhow::bail!("sbt project path does not exist: {}", path);
                }
                Ok(())
            }
        }
    }

    async fn get_transitive_dependencies(&self, deps: &[Dependency]) -> anyhow::Result<Vec<Dependency>> {
        let coursier_path = get_coursier_path().await
            .ok_or_else(|| anyhow!("coursier is not available"))?;

        let mut all_deps = Vec::new();
        let mut processed_coords: HashSet<String> = HashSet::new();

        for dep in deps {
            match dep {
                Dependency::Maven { group, artifact, version, is_scala } => {
                    let coord = if *is_scala {
                        format!("{}::{}:{}", group, artifact, version)
                    } else {
                        format!("{}:{}:{}", group, artifact, version)
                    };

                    let mut cmd = Command::new(&coursier_path);
                    cmd.arg("resolve")
                        .arg("--quiet")
                        .arg("--print-tree=false")
                        .arg("--intransitive") 
                        .arg(&coord);

                    let output = cmd.output().await?;
                    if !output.status.success() {
                        eprintln!("Warning: Failed to resolve transitive dependencies for {}: {}", coord, String::from_utf8_lossy(&output.stderr));
                        if processed_coords.insert(coord.clone()) {
                            all_deps.push(dep.clone());
                        }
                        continue;
                    }

                    let stdout = String::from_utf8_lossy(&output.stdout);
                    for line in stdout.lines() {
                        let line = line.trim();
                        if line.is_empty() || line.starts_with('#') {
                            continue;
                        }

                        // 解析 Maven 坐标格式 group:artifact:version
                        let parts: Vec<&str> = line.split(':').collect();
                        if parts.len() >= 3 {
                            let group = parts[0];
                            let artifact = parts[1];
                            let version = parts[2];
                            let current_coord = format!("{}:{}:{}", group, artifact, version);

                            if processed_coords.insert(current_coord) {
                                // 继承原始依赖的 is_scala 标志，或者根据 artifact 名称重新判断
                                let is_scala_dep = artifact.contains("_2.13") || artifact.contains("_2.12") || artifact.contains("_3");
                                
                                all_deps.push(Dependency::Maven {
                                    group: group.to_string(),
                                    artifact: artifact.to_string(),
                                    version: version.to_string(),
                                    is_scala: is_scala_dep,
                                });
                            }
                        }
                    }
                }
                Dependency::Sbt { path } => {
                    // 解析 sbt 项目的依赖
                    let sbt_project_path = if let Some(project_dir) = &self.project_dir {
                        // 修正：相对路径相对于 project_dir
                        project_dir.join(path)
                    } else {
                        Path::new(path).to_path_buf()
                    };

                    match resolve_sbt_dependencies(&sbt_project_path).await {
                        Ok(sbt_deps) => {
                            // 仅添加未处理过的 Maven 坐标
                            for sbt_dep in sbt_deps {
                                if let Dependency::Maven { .. } = &sbt_dep {
                                    if processed_coords.insert(sbt_dep.coord()) {
                                        all_deps.push(sbt_dep);
                                    }
                                }
                            }
                        }
                        Err(e) => {
                            eprintln!("Warning: Failed to resolve sbt dependencies for {}: {}", path, e);
                            all_deps.push(dep.clone());
                        }
                    }
                }
            }
        }

        Ok(all_deps)
    }

    fn set_project_dir(&mut self, project_dir: &Path) {
        self.project_dir = Some(project_dir.to_path_buf());
    }
}

// --- ScalaCli 实现 ---

/// Scala CLI 依赖管理器
pub struct ScalaCliDependencyManager;

#[async_trait::async_trait]
impl DependencyManager for ScalaCliDependencyManager {
    async fn prepare_dependencies(&self, deps: &[Dependency], _target_dir: &Path) -> anyhow::Result<()> {
        for dep in deps {
            if let Some(sbt_path) = dep.sbt_path() {
                let sbt_project_path = Path::new(sbt_path);
                if !sbt_project_path.exists() {
                    anyhow::bail!("sbt project path does not exist: {}", sbt_path);
                }
            }
        }
        Ok(())
    }

    fn get_build_args(&self, deps: &[Dependency]) -> Vec<String> {
        let mut args = Vec::new();

        for dep in deps {
            match dep {
                Dependency::Maven { .. } => {
                    args.push("--dependency".to_string());
                    args.push(dep.coord());
                }
                Dependency::Sbt { path } => {
                    // Scala CLI 处理 file:// 路径
                    args.push("--dependency".to_string());
                    args.push(format!("file://{}", path));
                }
            }
        }
        args
    }

    fn get_run_args(&self, deps: &[Dependency]) -> Vec<String> {
        self.get_build_args(deps)
    }

    async fn validate_dependency(&self, dep: &Dependency) -> anyhow::Result<()> {
        match dep {
            Dependency::Maven { .. } => {
                let args: Vec<String> = vec!["--dependency".to_string(), dep.coord(), "--quiet".to_string(), "-e".to_string(), "println(\"test\")".to_string()];
                let args_str: Vec<&str> = args.iter().map(|s| s.as_str()).collect();
                let output = crate::build::run_scala_cli(&args_str, None).await?;
                if !output.status.success() {
                    let err = String::from_utf8_lossy(&output.stderr);
                    anyhow::bail!("Dependency {} is not available: {}", dep.coord(), err);
                }
                Ok(())
            }
            Dependency::Sbt { path } => {
                let sbt_project_path = Path::new(path);
                if !sbt_project_path.exists() {
                    anyhow::bail!("sbt project path does not exist: {}", path);
                }
                Ok(())
            }
        }
    }

    async fn get_transitive_dependencies(&self, deps: &[Dependency]) -> anyhow::Result<Vec<Dependency>> {
        // Scala CLI 没有原生传递依赖解析功能，尝试回退到 Coursier
        if let Some(coursier_path) = get_coursier_path().await {
            // 使用 CoursierDependencyManager 的逻辑来解析，但不设置 project_dir
            let coursier_manager = CoursierDependencyManager::new();
            coursier_manager.get_transitive_dependencies(deps).await
        } else {
            // 如果coursier不可用，返回直接依赖
            eprintln!("Warning: Coursier is not available. Cannot resolve transitive dependencies using ScalaCliDependencyManager.");
            Ok(deps.to_vec())
        }
    }

    fn set_project_dir(&mut self, _project_dir: &Path) {
        // ScalaCliDependencyManager 不需要项目目录
    }
}

// --- 依赖管理器工厂函数 ---

/// 获取默认的依赖管理器
pub async fn default_dependency_manager() -> Box<dyn DependencyManager + Send + Sync> {
    if check_coursier_available().await {
        Box::new(CoursierDependencyManager::new())
    } else {
        Box::new(ScalaCliDependencyManager)
    }
}

/// 同步版本的默认依赖管理器（用于不需要异步的场景）
pub fn default_dependency_manager_sync() -> Box<dyn DependencyManager + Send + Sync> {
    // 修正：使用 tokio runtime 来安全地调用异步检查，并避免在非异步环境中多次创建 runtime
    // 生产环境中，最好在应用的启动时只创建一次 runtime
    let rt = tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime for sync check");
    
    // 检查 coursier 是否可用
    let is_coursier_available = rt.block_on(check_coursier_available());

    if is_coursier_available {
        Box::new(CoursierDependencyManager::new())
    } else {
        Box::new(ScalaCliDependencyManager)
    }
}

// --- SBT 辅助解析函数 ---

/// 解析 sbt 项目的依赖
async fn resolve_sbt_dependencies(sbt_project_path: &Path) -> anyhow::Result<Vec<Dependency>> {
    let build_sbt_path = sbt_project_path.join("build.sbt");
    if !build_sbt_path.exists() {
        return Ok(vec![]);
    }

    // 优先使用 sbt dependencyTree 命令获取依赖
    if check_command_available("sbt").await {
        return resolve_sbt_dependencies_via_sbt(sbt_project_path).await;
    }

    // 回退：尝试使用 coursier 解析 sbt 项目（仅当 sbt 不可用时）
    if let Some(coursier_path) = get_coursier_path().await {
        let coord = format!("sbt-project:{}", sbt_project_path.display());
        let mut cmd = Command::new(&coursier_path);
        cmd.arg("resolve")
            .arg("--quiet")
            .arg("--print-tree=false")
            .arg("--intransitive")
            .arg(&coord);

        let output = cmd.output().await?;
        if output.status.success() {
            let mut deps = Vec::new();
            let mut processed_coords: HashSet<String> = HashSet::new();

            let stdout = String::from_utf8_lossy(&output.stdout);
            for line in stdout.lines() {
                let line = line.trim();
                // ... (Maven 坐标解析逻辑与 CoursierDependencyManager 中相同，省略细节)
                if line.is_empty() || line.starts_with('#') { continue; }
                let parts: Vec<&str> = line.split(':').collect();
                if parts.len() >= 3 {
                    let group = parts[0];
                    let artifact = parts[1];
                    let version = parts[2];
                    let coord = format!("{}:{}:{}", group, artifact, version);

                    if processed_coords.insert(coord.clone()) {
                        let is_scala = artifact.contains("_2.13") || artifact.contains("_2.12") || artifact.contains("_3");
                        deps.push(Dependency::Maven {
                            group: group.to_string(),
                            artifact: artifact.to_string(),
                            version: version.to_string(),
                            is_scala,
                        });
                    }
                }
            }
            return Ok(deps);
        }
    }

    eprintln!("Warning: Could not resolve dependencies for sbt project {} (sbt command not found).", sbt_project_path.display());
    Ok(vec![])
}

/// 使用 sbt 命令解析依赖
async fn resolve_sbt_dependencies_via_sbt(sbt_project_path: &Path) -> anyhow::Result<Vec<Dependency>> {
    // 这是一个脆弱的方法，依赖于 sbt dependencyTree 的输出格式
    let mut cmd = Command::new("sbt");
    cmd.arg("dependencyTree")
        .current_dir(sbt_project_path);

    let output = cmd.output().await?;
    if !output.status.success() {
        let err = String::from_utf8_lossy(&output.stderr);
        return Err(anyhow!("Failed to run sbt dependencyTree: {}", err));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let mut deps = Vec::new();
    let mut processed_coords: HashSet<String> = HashSet::new();

    for line in stdout.lines() {
        let line = line.trim();

        let line = if line.starts_with("[info]") {
            line.trim_start_matches("[info]").trim()
        } else {
            line
        };

        if line.contains(':') && (line.starts_with("+-") || line.contains(" +-")) {
            let dep_line = if line.starts_with("+-") {
                line.trim_start_matches("+-").trim()
            } else if line.contains(" +-") {
                line.trim_start_matches(|c: char| c.is_whitespace() || c == '|')
                    .trim_start_matches("+-").trim()
            } else {
                continue;
            };

            let parts: Vec<&str> = dep_line.split(':').collect();
            // 依赖格式 group:artifact:version
            if parts.len() >= 3 {
                let group = parts[0];
                let artifact = parts[1];
                let version = parts[2].split(|c: char| c.is_whitespace()).next().unwrap_or(parts[2]);
                let coord = format!("{}:{}:{}", group, artifact, version);

                if processed_coords.insert(coord.clone()) {
                    let is_scala = artifact.contains("_2.13") || artifact.contains("_2.12") || artifact.contains("_3");

                    deps.push(Dependency::Maven {
                        group: group.to_string(),
                        artifact: artifact.to_string(),
                        version: version.to_string(),
                        is_scala,
                    });
                }
            }
        }
    }

    Ok(deps)
}


/// FILE: src/deps/mod.rs

pub mod deps;
pub mod add;
pub mod manager;

pub use deps::Dependency;
pub use add::add_dependency;
pub use manager::{DependencyManager, ScalaCliDependencyManager, CoursierDependencyManager, default_dependency_manager, default_dependency_manager_sync};



/// FILE: src/domain/dependency.rs

//! 依赖模型

use serde::{Deserialize, Serialize};

/// 依赖规范
#[derive(Deserialize, Serialize, Debug, Clone)]
#[serde(untagged)]
pub enum DependencySpec {
    Simple(String),
    Detailed(DependencyDetail),
}

/// 依赖详情
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct DependencyDetail {
    pub version: Option<String>,
    #[serde(default)]
    pub workspace: bool,
}

impl DependencySpec {
    /// 验证依赖规范
    pub fn validate(&self) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();

        match self {
            DependencySpec::Simple(dep_str) => {
                if dep_str.trim().is_empty() {
                    errors.push("依赖字符串不能为空".to_string());
                } else {
                    // 简单的格式验证：group:artifact:version
                    let parts: Vec<&str> = dep_str.split(':').collect();
                    if parts.len() < 3 {
                        errors.push(format!("依赖格式无效 '{}'，应为 'group:artifact:version'", dep_str));
                    }
                }
            }
            DependencySpec::Detailed(detail) => {
                if let Some(version) = &detail.version {
                    if version.trim().is_empty() {
                        errors.push("依赖版本不能为空".to_string());
                    }
                }
                // workspace依赖不需要版本
                if detail.workspace && detail.version.is_some() {
                    errors.push("工作空间依赖不应指定版本".to_string());
                }
            }
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }

    /// 获取依赖坐标字符串
    pub fn to_coordinate(&self) -> Option<String> {
        match self {
            DependencySpec::Simple(coord) => Some(coord.clone()),
            DependencySpec::Detailed(detail) => {
                // 对于详细配置，我们需要外部提供group和artifact信息
                // 这里返回None，表示需要更多上下文
                None
            }
        }
    }

    /// 检查是否为工作空间依赖
    pub fn is_workspace_dependency(&self) -> bool {
        match self {
            DependencySpec::Simple(_) => false,
            DependencySpec::Detailed(detail) => detail.workspace,
        }
    }
}


/// FILE: src/domain/mod.rs

//! 领域模型
//!
//! 定义 Sinter 的核心业务实体和值对象

pub mod project;
pub mod dependency;
pub mod workspace;

// Re-export for convenience
pub use project::{Project, Package};
pub use dependency::{DependencySpec, DependencyDetail};
pub use workspace::Workspace;


/// FILE: src/domain/project.rs

//! 项目配置模型

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use super::dependency::DependencySpec;
use super::workspace::Workspace;

/// 项目配置
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct Project {
    pub package: Package,
    #[serde(default)]
    pub dependencies: HashMap<String, DependencySpec>,
    #[serde(default)]
    pub workspace: Option<Workspace>,
}

impl Project {
    /// 获取主文件路径
    pub fn get_main_file_path(&self) -> std::path::PathBuf {
        let main_class = self.package.main.as_deref().unwrap_or("Main");
        std::path::PathBuf::from(&self.package.source_dir)
            .join(format!("{}.scala", main_class))
    }

    /// 获取源代码目录路径
    pub fn get_source_dir(&self) -> &str {
        &self.package.source_dir
    }

    /// 获取目标目录路径
    pub fn get_target_dir(&self) -> &str {
        &self.package.target_dir
    }

    /// 获取测试目录路径
    pub fn get_test_dir(&self) -> &str {
        &self.package.test_dir
    }

    /// 获取构建后端
    pub fn get_backend(&self) -> &str {
        &self.package.backend
    }

    /// 获取项目名称
    pub fn get_name(&self) -> &str {
        &self.package.name
    }

    /// 获取项目版本
    pub fn get_version(&self) -> &str {
        &self.package.version
    }

    /// 获取Scala版本
    pub fn get_scala_version(&self) -> &str {
        &self.package.scala_version
    }

    /// 获取所有依赖（包括工作空间级别的）
    pub fn get_all_dependencies(&self) -> std::collections::HashMap<String, &DependencySpec> {
        let mut deps = std::collections::HashMap::new();

        // 添加项目级依赖
        for (name, spec) in &self.dependencies {
            deps.insert(name.clone(), spec);
        }

        // 添加工作空间级依赖（如果存在）
        if let Some(workspace) = &self.workspace {
            for (name, spec) in &workspace.dependencies {
                deps.insert(name.clone(), spec);
            }
        }

        deps
    }

    /// 检查是否为工作空间根项目
    pub fn is_workspace_root(&self) -> bool {
        self.workspace.is_some()
    }

    /// 获取工作空间配置（如果存在）
    pub fn get_workspace(&self) -> Option<&Workspace> {
        self.workspace.as_ref()
    }

    /// 验证项目配置
    pub fn validate(&self) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();

        // 验证包信息
        if self.package.name.trim().is_empty() {
            errors.push("项目名称不能为空".to_string());
        }

        if self.package.version.trim().is_empty() {
            errors.push("项目版本不能为空".to_string());
        }

        // 验证Scala版本格式
        if !self.package.scala_version.starts_with("2.") && !self.package.scala_version.starts_with("3.") {
            errors.push("Scala版本格式无效，应为 2.x 或 3.x".to_string());
        }

        // 验证目录路径
        if self.package.source_dir.trim().is_empty() {
            errors.push("源代码目录不能为空".to_string());
        }

        if self.package.target_dir.trim().is_empty() {
            errors.push("目标目录不能为空".to_string());
        }

        // 验证后端
        let valid_backends = ["scala-cli", "sbt", "gradle", "maven"];
        if !valid_backends.contains(&self.package.backend.as_str()) {
            errors.push(format!("不支持的后端: {}，支持的后端: {}", self.package.backend, valid_backends.join(", ")));
        }

        // 验证依赖
        for (name, spec) in &self.dependencies {
            if name.trim().is_empty() {
                errors.push("依赖名称不能为空".to_string());
            }
            if let Err(dep_errors) = spec.validate() {
                for error in dep_errors {
                    errors.push(format!("依赖 '{}' 验证失败: {}", name, error));
                }
            }
        }

        // 验证工作空间
        if let Some(workspace) = &self.workspace {
            if let Err(ws_errors) = workspace.validate() {
                errors.extend(ws_errors);
            }
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

/// 包信息
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct Package {
    pub name: String,
    pub version: String,
    pub main: Option<String>,
    #[serde(default = "default_scala_version")]
    pub scala_version: String,
    #[serde(default = "default_source_dir")]
    pub source_dir: String,
    #[serde(default = "default_target_dir")]
    pub target_dir: String,
    #[serde(default = "default_test_dir")]
    pub test_dir: String,
    #[serde(default = "default_backend")]
    pub backend: String,
}

fn default_scala_version() -> String {
    "2.13".to_string()
}

fn default_source_dir() -> String {
    "src/main/scala".to_string()
}

fn default_target_dir() -> String {
    "target".to_string()
}

fn default_test_dir() -> String {
    "src/test/scala".to_string()
}

fn default_backend() -> String {
    "scala-cli".to_string()
}


/// FILE: src/domain/workspace.rs

//! 工作空间模型

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use super::dependency::DependencySpec;

/// 工作空间配置
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct Workspace {
    pub members: Vec<String>,
    #[serde(default)]
    pub dependencies: HashMap<String, DependencySpec>,
}

impl Workspace {
    /// 验证工作空间配置
    pub fn validate(&self) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();

        // 验证成员列表
        if self.members.is_empty() {
            errors.push("工作空间至少需要一个成员项目".to_string());
        }

        for member in &self.members {
            if member.trim().is_empty() {
                errors.push("工作空间成员路径不能为空".to_string());
            }
            // 检查路径格式（基本检查）
            if member.contains("..") {
                errors.push(format!("工作空间成员路径不能包含 '..': {}", member));
            }
        }

        // 检查重复成员
        let mut seen = std::collections::HashSet::new();
        for member in &self.members {
            if !seen.insert(member) {
                errors.push(format!("工作空间成员重复: {}", member));
            }
        }

        // 验证工作空间级依赖
        for (name, spec) in &self.dependencies {
            if name.trim().is_empty() {
                errors.push("工作空间依赖名称不能为空".to_string());
            }
            if let Err(dep_errors) = spec.validate() {
                for error in dep_errors {
                    errors.push(format!("工作空间依赖 '{}' 验证失败: {}", name, error));
                }
            }
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }

    /// 获取所有成员路径
    pub fn get_members(&self) -> &[String] {
        &self.members
    }

    /// 获取工作空间级依赖
    pub fn get_dependencies(&self) -> &HashMap<String, DependencySpec> {
        &self.dependencies
    }

    /// 检查是否包含指定成员
    pub fn contains_member(&self, member_path: &str) -> bool {
        self.members.iter().any(|m| m == member_path)
    }

    /// 添加成员（返回新的Workspace实例）
    pub fn add_member(mut self, member_path: String) -> Self {
        if !self.members.contains(&member_path) {
            self.members.push(member_path);
        }
        self
    }

    /// 移除成员（返回新的Workspace实例）
    pub fn remove_member(mut self, member_path: &str) -> Self {
        self.members.retain(|m| m != member_path);
        self
    }
}


/// FILE: src/error.rs

//! 自定义错误类型
//!
//! 提供结构化的错误处理，替代anyhow的字符串错误

use std::fmt;

/// Sinter 错误类型
#[derive(Debug)]
pub enum SinterError {
    /// 配置相关错误
    Config(ConfigError),
    /// 项目验证错误
    Validation(Vec<String>),
    /// 构建错误
    Build(BuildError),
    /// 依赖解析错误
    Dependency(DependencyError),
    /// IO错误
    Io(std::io::Error),
    /// TOML解析错误
    Toml(toml::de::Error),
}

#[derive(Debug)]
pub enum ConfigError {
    FileNotFound { path: std::path::PathBuf },
    ParseError { source: toml::de::Error },
    InvalidFormat(String),
}

#[derive(Debug)]
pub enum BuildError {
    BackendNotSupported(String),
    CommandFailed { command: String, exit_code: Option<i32> },
    ScalaVersionMismatch { required: String, found: String },
}

#[derive(Debug)]
pub enum DependencyError {
    InvalidCoordinate(String),
    VersionConflict { name: String, versions: Vec<String> },
    NotFound(String),
}

impl fmt::Display for SinterError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SinterError::Config(e) => write!(f, "配置错误: {}", e),
            SinterError::Validation(errors) => {
                write!(f, "验证失败:\n{}", errors.join("\n"))
            }
            SinterError::Build(e) => write!(f, "构建错误: {}", e),
            SinterError::Dependency(e) => write!(f, "依赖错误: {}", e),
            SinterError::Io(e) => write!(f, "IO错误: {}", e),
            SinterError::Toml(e) => write!(f, "TOML解析错误: {}", e),
        }
    }
}

impl fmt::Display for ConfigError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ConfigError::FileNotFound { path } => {
                write!(f, "配置文件未找到: {}", path.display())
            }
            ConfigError::ParseError { source } => {
                write!(f, "配置文件解析失败: {}", source)
            }
            ConfigError::InvalidFormat(msg) => write!(f, "配置格式无效: {}", msg),
        }
    }
}

impl fmt::Display for BuildError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BuildError::BackendNotSupported(backend) => {
                write!(f, "不支持的构建后端: {}", backend)
            }
            BuildError::CommandFailed { command, exit_code } => {
                write!(f, "命令执行失败: {} (退出码: {:?})", command, exit_code)
            }
            BuildError::ScalaVersionMismatch { required, found } => {
                write!(f, "Scala版本不匹配，需要: {}, 发现: {}", required, found)
            }
        }
    }
}

impl fmt::Display for DependencyError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DependencyError::InvalidCoordinate(coord) => {
                write!(f, "无效的依赖坐标: {}", coord)
            }
            DependencyError::VersionConflict { name, versions } => {
                write!(f, "依赖版本冲突 {}: {:?}", name, versions)
            }
            DependencyError::NotFound(name) => {
                write!(f, "依赖未找到: {}", name)
            }
        }
    }
}

impl std::error::Error for SinterError {}
impl std::error::Error for ConfigError {}
impl std::error::Error for BuildError {}
impl std::error::Error for DependencyError {}

impl From<std::io::Error> for SinterError {
    fn from(err: std::io::Error) -> Self {
        SinterError::Io(err)
    }
}

impl From<toml::de::Error> for SinterError {
    fn from(err: toml::de::Error) -> Self {
        SinterError::Toml(err)
    }
}

/// 结果类型别名
pub type Result<T> = std::result::Result<T, SinterError>;


/// FILE: src/i18n.rs

//! 国际化支持模块
//!
//! 此模块在构建时由 build.rs 生成，提供类型安全的翻译功能。
//! 语言选择通过 Cargo 特性标志控制：
//! - `lang-en` (默认): 英文
//! - `lang-zh`: 中文
//!
//! 使用示例：
//! ```rust
//! use crate::i18n::{t, tf};
//!
//! // 简单翻译
//! println!("{}", t("main_about"));
//!
//! // 带参数的翻译
//! println!("{}", tf("created_project", &["my-project"]));
//! ```

// Fallback 实现（用于 rust-analyzer 和测试环境）
// 当 OUT_DIR 未设置时，rust-analyzer 可以使用这个实现进行分析
mod fallback {
    /// Get a translated string by key (fallback implementation)
    /// This is used when build scripts haven't run (e.g., in rust-analyzer)
    pub fn t(_key: &str) -> &'static str {
        // 返回一个占位符字符串，这样 rust-analyzer 可以正常工作
        // 实际构建时会使用生成的代码
        "[Translation placeholder]"
    }

    /// Format a translated string with arguments (fallback implementation)
    pub fn tf(key: &str, args: &[&str]) -> String {
        let template = t(key);
        let mut result = template.to_string();
        for arg in args {
            if result.contains("{}") {
                result = result.replacen("{}", arg, 1);
            } else {
                break;
            }
        }
        result
    }
}

// 尝试包含构建时生成的代码
// 使用条件编译：只有在实际构建时才包含生成的代码
#[cfg(all(not(test), not(doctest)))]
mod generated {
    // 尝试包含生成的代码
    // 如果 OUT_DIR 未设置，这会在编译时失败
    // 但我们可以通过提供一个默认的英文实现来避免这个问题
    // 注意：在实际构建时，build.rs 总是会运行，所以 OUT_DIR 总是存在
    include!(concat!(env!("OUT_DIR"), "/i18n.rs"));
}

// 导出函数
// 在实际构建时使用生成的代码，在测试或 rust-analyzer 时使用 fallback
#[cfg(all(not(test), not(doctest)))]
pub use generated::{t, tf};

#[cfg(any(test, doctest))]
pub use fallback::{t, tf};

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_translation() {
        // 测试简单翻译
        let msg = t("main_about");
        assert!(!msg.is_empty());
    }

    #[test]
    fn test_formatted_translation() {
        // 测试格式化翻译
        // 注意：在测试模式下使用 fallback，所以只测试函数能正常调用
        let msg = tf("created_project", &["test-project"]);
        assert!(!msg.is_empty());
        // fallback 实现会替换 {}，所以应该包含参数
        assert!(msg.contains("test-project") || msg == "[Translation placeholder]");
    }
}




/// FILE: src/ide/bsp_setup.rs

use crate::deps::deps::Dependency;
use tokio::fs;
use std::path::Path;

pub async fn setup_bsp(bsp_dir: &Path, deps: &[Dependency], source_dirs: &[(String, String)], backend: &str) -> anyhow::Result<()> {
    // Remove any existing .bsp and .scala-build in the bsp_dir.
    let _ = fs::remove_dir_all(bsp_dir.join(".bsp")).await;
    let _ = fs::remove_dir_all(bsp_dir.join(".scala-build")).await;

    // Clean source trees
    for (member_name, source_dir) in source_dirs {
        let source_path = if member_name.is_empty() {
            bsp_dir.join(source_dir)
        } else {
            bsp_dir.join(member_name).join(source_dir)
        };
        let _ = fs::remove_dir_all(source_path.join(".bsp")).await;
        let _ = fs::remove_dir_all(source_path.join(".scala-build")).await;
    }

    match backend {
        "scala-cli" => {
            let mut args: Vec<String> = vec!["setup-ide".to_string(), ".".to_string()];
            for dep in deps {
                args.push("--dependency".to_string());
                args.push(dep.coord());
            }
            let args_str: Vec<&str> = args.iter().map(|s| s.as_str()).collect();
            let output = crate::build::run_scala_cli(&args_str, Some(bsp_dir)).await?;
            if !output.status.success() {
                anyhow::bail!("BSP setup failed");
            }
        }
        "sbt" | "gradle" | "maven" => {
            // For other backends, BSP setup might be different or not needed
            // For now, skip BSP setup for non-scala-cli backends
            return Ok(());
        }
        _ => {
            anyhow::bail!("Unsupported backend: {}", backend);
        }
    };

    // Manually set ide-options-v2.json
    let options_path = bsp_dir.join(".scala-build/ide-options-v2.json");
    fs::create_dir_all(options_path.parent().unwrap()).await?;
    let dependencies: Vec<String> = deps.iter().map(|d| d.coord()).collect();
    let scalac_options: Vec<String> = source_dirs.iter().map(|(member_name, source_dir)| {
        let source_dir_rel = if member_name.is_empty() {
            source_dir.clone()
        } else {
            format!("{}/{}", member_name, source_dir)
        };
        format!("{}/**/*.scala", source_dir_rel)
    }).collect();
    let template = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/ide-options-v2.json.template"));
    let json_str = template.replace("{scalac_option}", &scalac_options.join("\",\""));
    let mut options: serde_json::Value = serde_json::from_str(&json_str)?;
    options["dependencies"]["dependency"] = serde_json::Value::Array(dependencies.into_iter().map(serde_json::Value::String).collect());
    let content = options.to_string();
    fs::write(&options_path, content).await?;
    Ok(())
}


/// FILE: src/ide/classpath_generator.rs

//! Classpath生成器

use crate::domain::Project;
use crate::deps::Dependency;

/// Classpath生成器
pub struct ClasspathGenerator;

impl ClasspathGenerator {
    /// 生成项目classpath
    pub fn generate_classpath(&self, project: &Project, dependencies: &[Dependency]) -> anyhow::Result<String> {
        // TODO: 实现classpath生成逻辑
        Ok(String::new())
    }

    /// 生成工作空间classpath
    pub fn generate_workspace_classpath(&self, projects: &[Project], dependencies: &[Dependency]) -> anyhow::Result<String> {
        // TODO: 实现工作空间classpath生成逻辑
        Ok(String::new())
    }
}


/// FILE: src/ide/mod.rs

//! IDE支持模块
//!
//! 提供IDE集成功能

pub mod classpath_generator;
pub mod bsp_setup;

// Re-export for convenience
pub use classpath_generator::*;
pub use bsp_setup::*;


/// FILE: src/lib.rs

//! Sinter - Scala 项目构建工具
//!
//! 这是一个类似 Cargo 的 Scala 项目管理和构建工具。

// 领域模型
pub mod domain;

// 配置管理
pub mod config;

// 依赖管理
pub mod dependency;

// 构建系统
pub mod build;

// 工作空间管理
pub mod workspace;

// IDE支持
pub mod ide;

// 命令行接口
pub mod cli;

// 运行时
pub mod runtime;

// 核心模块
pub mod core;

// 国际化支持（构建时生成）
pub mod i18n;

// 兼容性层（已废弃）
mod config_compat;

// 功能模块（已迁移）
pub mod deps;

// 公共 API
pub use core::{CommandHandler, Sinter};
pub use cli::{Cli, Commands, WorkspaceCommands};


/// FILE: src/runtime/executor.rs

//! 命令执行器
//!
//! 负责将解析后的 CLI 命令分发到对应的处理器

use crate::core::handler::CommandHandler;
use crate::cli::{Cli, builtin};
use std::path::PathBuf;

/// 命令执行器
///
/// 负责执行命令，包括：
/// 1. 插件命令的执行
/// 2. 内置命令的执行
pub struct Executor {
    plugins: Vec<Box<dyn CommandHandler>>,
}

impl Executor {
    /// 创建新的执行器
    pub fn new(plugins: Vec<Box<dyn CommandHandler>>) -> Self {
        Self { plugins }
    }

    /// 执行命令
    ///
    /// 根据 CLI 解析结果，执行对应的命令
    pub async fn execute(&self, cli: Cli, cwd: PathBuf) -> anyhow::Result<()> {
        // 首先检查是否是插件命令
        if let Some((command_name, matches)) = cli.raw_matches.subcommand() {
            if let Some(handler) = self.plugins.iter().find(|cmd| cmd.name() == command_name) {
                return handler.execute(matches, &cwd).await;
            }
        }

        // 处理内置命令
        if let Some(command) = cli.command {
            builtin::execute_command(command, &cwd).await?;
        } else {
            // 没有提供命令，尝试运行默认行为
            builtin::execute_default(&cwd).await?;
        }

        Ok(())
    }
}




/// FILE: src/runtime/mod.rs

//! 运行时模块
//!
//! 处理命令的执行和分发逻辑

pub mod executor;

pub use executor::Executor;




/// FILE: src/workspace/manager.rs

//! 工作空间操作

use crate::domain::Workspace;

/// 工作空间管理器
pub struct WorkspaceManager;

impl WorkspaceManager {
    /// 创建新的工作空间管理器
    pub fn new() -> Self {
        Self
    }

    /// 验证工作空间配置
    pub fn validate_workspace(&self, workspace: &Workspace) -> anyhow::Result<()> {
        // TODO: 实现工作空间验证逻辑
        Ok(())
    }
}


/// FILE: src/workspace/member.rs

//! 成员管理

use crate::domain::Project;

/// 工作空间成员管理器
pub struct MemberManager;

impl MemberManager {
    /// 创建新的成员管理器
    pub fn new() -> Self {
        Self
    }

    /// 添加工作空间成员
    pub fn add_member(&self, workspace_path: &std::path::Path, member_path: &str) -> anyhow::Result<()> {
        // TODO: 实现添加成员逻辑
        Ok(())
    }

    /// 移除工作空间成员
    pub fn remove_member(&self, workspace_path: &std::path::Path, member_path: &str) -> anyhow::Result<()> {
        // TODO: 实现移除成员逻辑
        Ok(())
    }

    /// 验证成员项目
    pub fn validate_member(&self, member_project: &Project) -> anyhow::Result<()> {
        // TODO: 实现成员验证逻辑
        Ok(())
    }
}


/// FILE: src/workspace/mod.rs

//! 工作空间管理模块
//!
//! 提供工作空间操作和管理功能

pub mod manager;
pub mod member;

// Re-export for convenience
pub use manager::*;
pub use member::*;


/// FILE: templates/i18n.json

{
  "en": {
    "main_about": "A Cargo-like build tool for Scala",
    "new_about": "Create a new Scala project",
    "init_about": "Initialize a new workspace",
    "build_about": "Build the Scala project",
    "run_about": "Run the Scala project or a specific file",
    "add_about": "Add a dependency to the project",
    "workspace_about": "Workspace management",
    "workspace_add_about": "Add a member to the workspace",
    "new_name_help": "Name of the new project",
    "run_file_help": "Optional .scala file to run (relative to project root)",
    "run_lib_help": "Force library mode (compile only)",
    "add_dep_help": "Dependency in format: group::artifact:version[@scala-version]",
    "workspace_add_path_help": "Path to the member project",
    "test_about": "Run tests",
    "test_file_help": "Optional test file or directory to run (relative to project root)",
    "project_already_exists": "Project '{}' already exists",
    "created_project": "Created project `{}`",
    "initialized_empty_workspace": "Initialized empty workspace in {}",
    "added_member_to_workspace": "Added member '{}' to workspace",
    "added_project_to_workspace": "Added project '{}' to workspace",
    "member_already_exists": "Member '{}' already exists in workspace",
    "added_dependency": "Added dependency: {} = {}",
    "built_member": "Built member: {}",
    "build_succeeded_with_deps": "Build succeeded with {} dependencies",
    "workspace_build_succeeded": "Workspace build succeeded",
    "lib_compiled_only": "lib: {} (compiled only)",
    "main_file_not_found": "Main file not found: {}",
    "no_command_provided": "No command provided. Use --help for usage.",
    "config_file_already_exists": "project.toml already exists in this directory",
    "not_in_workspace": "Not in a workspace",
    "invalid_dependency_format": "Invalid dependency format, please use full format: group::artifact:version, e.g. org.typelevel::cats-core:2.9.0",
    "invalid_artifact_format": "Invalid dependency format, artifact should not contain '::', please use group:artifact:version format",
    "version_must_be_specified": "Version must be explicitly specified, 'latest' is not allowed",
    "running_in_workspace": "Running in workspace: {}",
    "running_in_project": "Running in project: {}",
    "workspace_dependencies": "Workspace dependencies ({}):",
    "project_dependencies": "Project dependencies ({}):",
    "no_workspace_dependencies": "No workspace dependencies",
    "no_project_dependencies": "No project dependencies",
    "dependency_item": "  - {}"
  },
  "zh": {
    "main_about": "一个类似 Cargo 的 Scala 构建工具",
    "new_about": "创建一个新的 Scala 项目",
    "init_about": "初始化一个新的工作空间",
    "build_about": "构建 Scala 项目",
    "run_about": "运行 Scala 项目或特定文件",
    "add_about": "向项目添加依赖",
    "workspace_about": "工作空间管理",
    "workspace_add_about": "向工作空间添加成员",
    "new_name_help": "新项目的名称",
    "run_file_help": "可选的要运行的 .scala 文件（相对于项目根目录）",
    "run_lib_help": "强制库模式（仅编译）",
    "add_dep_help": "依赖格式：group::artifact:version[@scala-version]",
    "workspace_add_path_help": "成员项目的路径",
    "test_about": "运行测试",
    "test_file_help": "可选的测试文件或目录（相对于项目根目录）",
    "project_already_exists": "项目 '{}' 已存在",
    "created_project": "已创建项目 `{}`",
    "initialized_empty_workspace": "已初始化空工作空间于 {}",
    "added_member_to_workspace": "已添加成员 '{}' 到工作空间",
    "added_project_to_workspace": "已添加项目 '{}' 到工作空间",
    "member_already_exists": "成员 '{}' 已存在于工作空间",
    "added_dependency": "已添加依赖: {} = {}",
    "built_member": "已构建成员: {}",
    "build_succeeded_with_deps": "构建成功，包含 {} 个依赖",
    "workspace_build_succeeded": "工作空间构建成功",
    "lib_compiled_only": "库: {} (仅编译)",
    "main_file_not_found": "未找到主文件: {}",
    "no_command_provided": "未提供命令。使用 --help 获取用法。",
    "config_file_already_exists": "project.toml 已存在于此目录",
    "not_in_workspace": "不在工作空间中",
    "invalid_dependency_format": "依赖格式无效，请使用完整格式：group::artifact:version，例如 org.typelevel::cats-core:2.9.0",
    "invalid_artifact_format": "依赖格式无效，artifact 不应包含 '::'，请使用 group:artifact:version 格式",
    "version_must_be_specified": "必须明确指定版本，不允许使用 'latest'",
    "running_in_workspace": "在工作空间中运行: {}",
    "running_in_project": "在项目中运行: {}",
    "workspace_dependencies": "工作空间依赖 ({}):",
    "project_dependencies": "项目依赖 ({}):",
    "no_workspace_dependencies": "无工作空间依赖",
    "no_project_dependencies": "无项目依赖",
    "dependency_item": "  - {}"
  }
}




