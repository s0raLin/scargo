/// FILE: ARCHITECTURE.md

# Sinter æ¶æ„æ–‡æ¡£

## é¡¹ç›®ç»“æ„

```
sinter/
â”œâ”€â”€ Cargo.toml              # Workspace é…ç½®
â”œâ”€â”€ src/                     # ä¸»é¡¹ç›®åº“ä»£ç 
â”‚   â”œâ”€â”€ core/               # æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ handler.rs      # CommandHandler trait
â”‚   â”‚   â”œâ”€â”€ app.rs          # Sinter åº”ç”¨æ„å»ºå™¨
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ runtime/            # è¿è¡Œæ—¶æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ executor.rs     # å‘½ä»¤æ‰§è¡Œå™¨
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ cli.rs              # CLI å®šä¹‰å’Œè§£æ
â”‚   â”œâ”€â”€ config.rs           # é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ build/              # æ„å»ºç›¸å…³
â”‚   â”œâ”€â”€ deps/               # ä¾èµ–ç®¡ç†
â”‚   â”œâ”€â”€ cmd/                # å†…ç½®å‘½ä»¤å®ç°
â”‚   â”‚   â”œâ”€â”€ builtin.rs      # å†…ç½®å‘½ä»¤æ‰§è¡Œé€»è¾‘
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ lib.rs              # å…¬å…± API
â”œâ”€â”€ cli/                    # å¯æ‰§è¡Œæ–‡ä»¶ï¼ˆç‹¬ç«‹ crateï¼‰
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ main.rs         # ä¸»å…¥å£ï¼Œæ³¨å†Œæ’ä»¶
â”œâ”€â”€ sinter-plugin/          # æ’ä»¶å¼€å‘ APIï¼ˆç‹¬ç«‹ crateï¼‰
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ README.md
â”‚   â””â”€â”€ src/lib.rs          # æ’ä»¶å¼€å‘ API
â””â”€â”€ plugins/                # æ’ä»¶é›†åˆï¼ˆç‹¬ç«‹ crateï¼‰
    â”œâ”€â”€ Cargo.toml
    â”œâ”€â”€ README.md
    â””â”€â”€ src/
        â”œâ”€â”€ lib.rs          # å¯¼å‡ºæ‰€æœ‰æ’ä»¶
        â””â”€â”€ jsp.rs          # JSP æ’ä»¶ç¤ºä¾‹
```

## æ¨¡å—è¯´æ˜

### æ ¸å¿ƒæ¨¡å— (core)

æ ¸å¿ƒæ¨¡å—åŒ…å«æ’ä»¶ç³»ç»Ÿçš„æ ¸å¿ƒæŠ½è±¡ï¼š

- **CommandHandler trait**: æ‰€æœ‰å‘½ä»¤ï¼ˆå†…ç½®å’Œæ’ä»¶ï¼‰éƒ½éœ€è¦å®ç°çš„ trait
- **Sinter ç»“æ„ä½“**: åº”ç”¨æ„å»ºå™¨ï¼Œä½¿ç”¨ Builder æ¨¡å¼

### è¿è¡Œæ—¶æ¨¡å— (runtime)

è¿è¡Œæ—¶æ¨¡å—å¤„ç†å‘½ä»¤çš„æ‰§è¡Œï¼š

- **Executor**: è´Ÿè´£å°†è§£æåçš„å‘½ä»¤åˆ†å‘åˆ°å¯¹åº”çš„å¤„ç†å™¨

### æ’ä»¶ç³»ç»Ÿ

æ’ä»¶ç³»ç»Ÿé‡‡ç”¨ç‹¬ç«‹ crate è®¾è®¡ï¼š

- **plugins**: ç‹¬ç«‹çš„æ’ä»¶ crateï¼ŒåŒ…å«æ‰€æœ‰æ‰©å±•æ’ä»¶
- **cli**: ç‹¬ç«‹çš„å¯æ‰§è¡Œæ–‡ä»¶ crateï¼Œè´Ÿè´£æ³¨å†Œå’Œè¿è¡Œæ’ä»¶
- **sinter-plugin**: æ’ä»¶å¼€å‘ API crateï¼Œæä¾›æ’ä»¶å¼€å‘æ‰€éœ€çš„æ‰€æœ‰ä¾èµ–å’Œç±»å‹

è¿™ç§è®¾è®¡çš„ä¼˜åŠ¿ï¼š
1. **é¿å…å¾ªç¯ä¾èµ–**ï¼šä¸»é¡¹ç›®åº“ä¸ä¾èµ–æ’ä»¶ï¼Œæ’ä»¶ä¾èµ–ä¸»é¡¹ç›®
2. **æ¸…æ™°çš„åˆ†ç¦»**ï¼šæ ¸å¿ƒåŠŸèƒ½å’Œæ‰©å±•åŠŸèƒ½å®Œå…¨åˆ†ç¦»
3. **æ˜“äºç»´æŠ¤**ï¼šæ’ä»¶å¯ä»¥ç‹¬ç«‹å¼€å‘å’Œå‘å¸ƒ
4. **çµæ´»é…ç½®**ï¼šå¯ä»¥é€‰æ‹©æ€§åœ°åŒ…å«æ’ä»¶

## ä¾èµ–å…³ç³»

```
sinter (lib)
  â””â”€ ä¸ä¾èµ–ä»»ä½•æ’ä»¶

sinter-plugin
  â””â”€ ä¾èµ– sinter (lib)

plugins
  â””â”€ ä¾èµ– sinter-plugin

cli
  â”œâ”€ ä¾èµ– sinter (lib)
  â””â”€ ä¾èµ– plugins
```

## è®¾è®¡åŸåˆ™

1. **æ¸…æ™°çš„æ¨¡å—åˆ†å±‚**ï¼š
   - core: æ ¸å¿ƒæŠ½è±¡
   - runtime: è¿è¡Œæ—¶é€»è¾‘
   - cmd: å…·ä½“å‘½ä»¤å®ç°

2. **ç»Ÿä¸€çš„å‘½ä»¤æ¥å£**ï¼š
   - æ‰€æœ‰å‘½ä»¤ï¼ˆå†…ç½®å’Œæ’ä»¶ï¼‰éƒ½å®ç° `CommandHandler` trait
   - ç»Ÿä¸€çš„æ‰§è¡Œæµç¨‹

3. **æ˜“äºæ‰©å±•**ï¼š
   - æ·»åŠ æ–°æ’ä»¶åªéœ€åœ¨ `plugins` ä¸­å®ç° `CommandHandler` trait
   - æ— éœ€ä¿®æ”¹æ ¸å¿ƒä»£ç 

4. **é¿å…å¾ªç¯ä¾èµ–**ï¼š
   - ä¸»é¡¹ç›®åº“ä¸ä¾èµ–æ’ä»¶
   - æ’ä»¶ä¾èµ–ä¸»é¡¹ç›®
   - å¯æ‰§è¡Œæ–‡ä»¶åŒæ—¶ä¾èµ–ä¸»é¡¹ç›®å’Œæ’ä»¶

## ä½¿ç”¨ç¤ºä¾‹

### åˆ›å»ºæ’ä»¶

åœ¨ `plugins/src/` ä¸­åˆ›å»ºæ–°æ’ä»¶ï¼š

```rust
use sinter::CommandHandler;
use async_trait::async_trait;
use clap::{Arg, ArgMatches, Command};
use std::path::PathBuf;

pub struct MyPlugin;

#[async_trait]
impl CommandHandler for MyPlugin {
    fn name(&self) -> &'static str {
        "mycommand"
    }

    fn about(&self) -> &'static str {
        "My awesome command"
    }

    fn configure(&self, cmd: Command) -> Command {
        cmd.arg(Arg::new("input").required(true))
    }

    async fn execute(&self, matches: &ArgMatches, cwd: &PathBuf) -> anyhow::Result<()> {
        let input = matches.get_one::<String>("input").unwrap();
        println!("Processing: {}", input);
        Ok(())
    }
}

pub fn my_plugin() -> MyPlugin {
    MyPlugin
}
```

### æ³¨å†Œæ’ä»¶

åœ¨ `cli/src/main.rs` ä¸­ï¼š

```rust
use sinter::Sinter;
use plugins::{jsp_plugin, my_plugin};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    Sinter::new()
        .plugin(jsp_plugin())
        .plugin(my_plugin())
        .run()
        .await
}
```

## æ„å»ºå’Œè¿è¡Œ

```bash
# æ„å»ºæ‰€æœ‰ crate
cargo build

# æ„å»ºç‰¹å®š crate
cargo build --package sinter
cargo build --package sinter-plugin
cargo build --package plugins
cargo build --package cli

# è¿è¡Œ
cargo run --package cli
```



/// FILE: Cargo.lock

# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "anstream"
version = "0.6.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43d5b281e737544384e969a5ccad3f1cdd24b48086a0fc1b2a5262a26b8f4f4a"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40c48f72fd53cd289104fc64099abca73db4166ad86ea0b4341abe65af83dadc"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "291e6a250ff86cd4a820112fb8898808a366d8f9f58ce16d1f538353ad55747d"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.61.2",
]

[[package]]
name = "anyhow"
version = "1.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a23eb6b1614318a8071c9b2521f36b424b2c83db5eb3a0fead4a6c0809af6e61"

[[package]]
name = "arraydeque"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d902e3d592a523def97af8f317b08ce16b7ab854c1985a0c671e6f15cebc236"

[[package]]
name = "async-trait"
version = "0.1.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9035ad2d096bed7955a320ee7e2230574d28fd3c3a0f186cbea1ff3c7eed5dbb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "bitflags"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "812e12b5285cc515a9c72a5c1d3b6d46a19dac5acfef5265968c166106e31dd3"
dependencies = [
 "serde_core",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "cfg-if"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"

[[package]]
name = "clap"
version = "4.5.53"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9e340e012a1bf4935f5282ed1436d1489548e8f72308207ea5df0e23d2d03f8"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.53"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d76b5d13eaa18c901fd2f7fca939fefe3a0727a953561fefdf3b2922b8569d00"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.49"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a0b5487afeab2deb2ff4e03a807ad1a03ac532ff5a2cee5d86884440c7f7671"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1d728cc89cf3aee9ff92b05e62b19ee65a02b5702cff7d5a377e32c6ae29d8d"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "config"
version = "0.15.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b30fa8254caad766fc03cb0ccae691e14bf3bd72bfff27f72802ce729551b3d6"
dependencies = [
 "async-trait",
 "convert_case",
 "json5",
 "pathdiff",
 "ron",
 "rust-ini",
 "serde-untagged",
 "serde_core",
 "serde_json",
 "toml",
 "winnow",
 "yaml-rust2",
]

[[package]]
name = "const-random"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e00182fe74b066627d63b85fd550ac2998d4b0bd86bfed477a0ae4c7c71359"
dependencies = [
 "const-random-macro",
]

[[package]]
name = "const-random-macro"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9d839f2a20b0aee515dc581a6172f2321f96cab76c1a38a4c584a194955390e"
dependencies = [
 "getrandom",
 "once_cell",
 "tiny-keccak",
]

[[package]]
name = "convert_case"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec182b0ca2f35d8fc196cf3404988fd8b8c739a4d270ff118a398feb0cbec1ca"
dependencies = [
 "unicode-segmentation",
]

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crunchy"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "460fbee9c2c2f33933d720630a6a0bac33ba7053db5344fac858d4b8952d77d5"

[[package]]
name = "crypto-common"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78c8292055d1c1df0cce5d180393dc8cce0abec0a7102adb6c7b1eef6016d60a"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "dirs"
version = "6.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3e8aa94d75141228480295a7d0e7feb620b1a5ad9f12bc40be62411e38cce4e"
dependencies = [
 "dirs-sys",
]

[[package]]
name = "dirs-sys"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e01a3366d27ee9890022452ee61b2b63a67e6f13f58900b651ff5665f0bb1fab"
dependencies = [
 "libc",
 "option-ext",
 "redox_users",
 "windows-sys 0.61.2",
]

[[package]]
name = "dlv-list"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "442039f5147480ba31067cb00ada1adae6892028e40e45fc5de7b7df6dcc1b5f"
dependencies = [
 "const-random",
]

[[package]]
name = "encoding_rs"
version = "0.8.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "erased-serde"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89e8918065695684b2b0702da20382d5ae6065cf3327bc2d6436bd49a71ce9f3"
dependencies = [
 "serde",
 "serde_core",
 "typeid",
]

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"

[[package]]
name = "hashbrown"
version = "0.15.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9229cfe53dfd69f0609a49f65461bd93001ea1ef889cd5529dd176593f5338a1"
dependencies = [
 "foldhash",
]

[[package]]
name = "hashbrown"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5419bdc4f6a9207fbeba6d11b604d481addf78ecd10c11ad51e76c2f6482748d"

[[package]]
name = "hashlink"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7382cf6263419f2d8df38c55d7da83da5c18aef87fc7a7fc1fb1e344edfe14c1"
dependencies = [
 "hashbrown 0.15.5",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "indexmap"
version = "2.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6717a8d2a5a929a1a2eb43a12812498ed141a0bcfb7e8f7844fbdbe4303bba9f"
dependencies = [
 "equivalent",
 "hashbrown 0.16.0",
]

[[package]]
name = "inventory"
version = "0.3.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc61209c082fbeb19919bee74b176221b27223e27b65d781eb91af24eb1fb46e"
dependencies = [
 "rustversion",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6cb138bb79a146c1bd460005623e142ef0181e3d0219cb493e02f7d08a35695"

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "json5"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b0db21af676c1ce64250b5f40f3ce2cf27e4e47cb91ed91eb6fe9350b430c1"
dependencies = [
 "pest",
 "pest_derive",
 "serde",
]

[[package]]
name = "libc"
version = "0.2.177"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2874a2af47a2325c2001a6e6fad9b16a53b802102b528163885171cf92b15976"

[[package]]
name = "libredox"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "416f7e718bdb06000964960ffa43b4335ad4012ae8b99060261aa4a8088d5ccb"
dependencies = [
 "bitflags",
 "libc",
]

[[package]]
name = "lock_api"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "224399e74b87b5f3557511d98dff8b14089b3dadafcab6bb93eab67d3aace965"
dependencies = [
 "scopeguard",
]

[[package]]
name = "memchr"
version = "2.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f52b00d39961fc5b2736ea853c9cc86238e165017a493d1d5c8eac6bdc4cc273"

[[package]]
name = "mio"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69d83b0086dc8ecf3ce9ae2874b2d1290252e2a30720bea58a5c6639b0092873"
dependencies = [
 "libc",
 "wasi",
 "windows-sys 0.61.2",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"

[[package]]
name = "option-ext"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d"

[[package]]
name = "ordered-multimap"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49203cdcae0030493bad186b28da2fa25645fa276a51b6fec8010d281e02ef79"
dependencies = [
 "dlv-list",
 "hashbrown 0.14.5",
]

[[package]]
name = "parking_lot"
version = "0.12.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93857453250e3077bd71ff98b6a65ea6621a19bb0f559a85248955ac12c45a1a"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2621685985a2ebf1c516881c026032ac7deafcda1a2c9b7850dc81e3dfcb64c1"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-link",
]

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "pathdiff"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df94ce210e5bc13cb6651479fa48d14f601d9858cfe0467f43ae157023b938d3"

[[package]]
name = "pest"
version = "2.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "989e7521a040efde50c3ab6bbadafbe15ab6dc042686926be59ac35d74607df4"
dependencies = [
 "memchr",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "187da9a3030dbafabbbfb20cb323b976dc7b7ce91fcd84f2f74d6e31d378e2de"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49b401d98f5757ebe97a26085998d6c0eecec4995cad6ab7fc30ffdf4b052843"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "pest_meta"
version = "2.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72f27a2cfee9f9039c4d86faa5af122a0ac3851441a34865b8a043b46be0065a"
dependencies = [
 "pest",
 "sha2",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "proc-macro2"
version = "1.0.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ee95bc4ef87b8d5ba32e8b7714ccc834865276eab0aed5c9958d00ec45f49e8"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a338cc41d27e6cc6dce6cefc13a0729dfbb81c262b1f519331575dd80ef3067f"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "redox_syscall"
version = "0.5.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed2bf2547551a7053d6fdfafda3f938979645c44812fbfcda098faae3f1a362d"
dependencies = [
 "bitflags",
]

[[package]]
name = "redox_users"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4e608c6638b9c18977b00b475ac1f28d14e84b27d8d42f70e0bf1e3dec127ac"
dependencies = [
 "getrandom",
 "libredox",
 "thiserror",
]

[[package]]
name = "ron"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd490c5b18261893f14449cbd28cb9c0b637aebf161cd77900bfdedaff21ec32"
dependencies = [
 "bitflags",
 "once_cell",
 "serde",
 "serde_derive",
 "typeid",
 "unicode-ident",
]

[[package]]
name = "rust-ini"
version = "0.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "796e8d2b6696392a43bea58116b667fb4c29727dc5abd27d6acf338bb4f688c7"
dependencies = [
 "cfg-if",
 "ordered-multimap",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "serde"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
dependencies = [
 "serde_core",
 "serde_derive",
]

[[package]]
name = "serde-untagged"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9faf48a4a2d2693be24c6289dbe26552776eb7737074e6722891fadbe6c5058"
dependencies = [
 "erased-serde",
 "serde",
 "serde_core",
 "typeid",
]

[[package]]
name = "serde_core"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.145"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "402a6f66d8c709116cf22f558eab210f5a50187f702eb4d7e5ef38d9a7f1c79c"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
 "serde_core",
]

[[package]]
name = "serde_spanned"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e24345aa0fe688594e73770a5f6d1b216508b4f93484c0026d521acd30134392"
dependencies = [
 "serde_core",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "signal-hook-registry"
version = "1.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2a4719bff48cee6b39d12c020eeb490953ad2443b7055bd0b21fca26bd8c28b"
dependencies = [
 "libc",
]

[[package]]
name = "sinter"
version = "0.1.2"
dependencies = [
 "anyhow",
 "async-trait",
 "clap",
 "config",
 "dirs",
 "inventory",
 "paste",
 "serde",
 "serde_json",
 "tokio",
 "toml_edit",
]

[[package]]
name = "sinter-cli"
version = "0.1.2"
dependencies = [
 "anyhow",
 "sinter",
 "sinter-plugins",
 "tokio",
]

[[package]]
name = "sinter-plugin-api"
version = "0.1.2"
dependencies = [
 "anyhow",
 "async-trait",
 "clap",
 "sinter",
 "tokio",
]

[[package]]
name = "sinter-plugins"
version = "0.1.2"
dependencies = [
 "sinter-plugin-api",
]

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "socket2"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17129e116933cf371d018bb80ae557e889637989d8638274fb25622827b03881"
dependencies = [
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "2.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f17c7e013e88258aa9543dcbe81aca68a667a9ac37cd69c9fbc07858bfe0e2f"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "thiserror"
version = "2.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f63587ca0f12b72a0600bcba1d40081f830876000bb46dd2337a3051618f4fc8"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "2.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ff15c8ecd7de3849db632e14d18d2571fa09dfc5ed93479bc4485c7a517c913"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tiny-keccak"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237"
dependencies = [
 "crunchy",
]

[[package]]
name = "tokio"
version = "1.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff360e02eab121e0bc37a2d3b4d4dc622e6eda3a8e5253d5435ecf5bd4c68408"
dependencies = [
 "bytes",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.61.2",
]

[[package]]
name = "tokio-macros"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af407857209536a95c8e56f8231ef2c2e2aff839b22e07a1ffcbc617e9db9fa5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "toml"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0dc8b1fb61449e27716ec0e1bdf0f6b8f3e8f6b05391e8497b8b6d7804ea6d8"
dependencies = [
 "serde_core",
 "serde_spanned",
 "toml_datetime",
 "toml_parser",
 "winnow",
]

[[package]]
name = "toml_datetime"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2cdb639ebbc97961c51720f858597f7f24c4fc295327923af55b74c3c724533"
dependencies = [
 "serde_core",
]

[[package]]
name = "toml_edit"
version = "0.23.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6485ef6d0d9b5d0ec17244ff7eb05310113c3f316f2d14200d4de56b3cb98f8d"
dependencies = [
 "indexmap",
 "toml_datetime",
 "toml_parser",
 "toml_writer",
 "winnow",
]

[[package]]
name = "toml_parser"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0cbe268d35bdb4bb5a56a2de88d0ad0eb70af5384a99d648cd4b3d04039800e"
dependencies = [
 "winnow",
]

[[package]]
name = "toml_writer"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df8b2b54733674ad286d16267dcfc7a71ed5c776e4ac7aa3c3e2561f7c637bf2"

[[package]]
name = "typeid"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc7d623258602320d5c55d1bc22793b57daff0ec7efc270ea7d55ce1d5f5471c"

[[package]]
name = "typenum"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "562d481066bde0658276a35467c4af00bdc6ee726305698a55b86e61d7ad82bb"

[[package]]
name = "ucd-trie"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2896d95c02a80c6d6a5d6e953d479f5ddf2dfdb6a244441010e373ac0fb88971"

[[package]]
name = "unicode-ident"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-targets"
version = "0.53.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4945f9f551b88e0d65f3db0bc25c33b8acea4d9e41163edf90dcd0b19f9069f3"
dependencies = [
 "windows-link",
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9d8416fa8b42f5c947f8482c43e7d89e73a173cead56d044f6a56104a6d1b53"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d782e804c2f632e395708e99a94275910eb9100b2114651e04744e9b125006"

[[package]]
name = "windows_i686_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "960e6da069d81e09becb0ca57a65220ddff016ff2d6af6a223cf372a506593a3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa7359d10048f68ab8b09fa71c3daccfb0e9b559aed648a8f95469c27057180c"

[[package]]
name = "windows_i686_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e7ac75179f18232fe9c285163565a57ef8d3c89254a30685b57d83a38d326c2"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c3842cdd74a865a8066ab39c8a7a473c0778a3f29370b5fd6b4b9aa7df4a499"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ffa179e2d07eee8ad8f57493436566c7cc30ac536a3379fdf008f47f6bb7ae1"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6bbff5f0aada427a1e5a6da5f1f98158182f26556f345ac9e04d36d0ebed650"

[[package]]
name = "winnow"
version = "0.7.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21a0236b59786fed61e2a80582dd500fe61f18b5dca67a4a067d0bc9039339cf"
dependencies = [
 "memchr",
]

[[package]]
name = "yaml-rust2"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2462ea039c445496d8793d052e13787f2b90e750b833afee748e601c17621ed9"
dependencies = [
 "arraydeque",
 "encoding_rs",
 "hashlink",
]



/// FILE: Cargo.toml

[workspace]
resolver = "2"
members = [
    "crates/*",
]

[workspace.package]
version = "0.1.2"
edition = "2021"
license = "MIT"

[workspace.dependencies]
anyhow = "1"
async-trait = "0.1"
clap = { version = "4", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
toml = "0.8"
toml_edit = "0.23.7"
config = "0.15.19"
dirs = "6.0.0"
paste = "1.0"
lazy_static = "1.4"
inventory = "0.3"




/// FILE: PLUGIN_SYSTEM.md

# Sinter æ’ä»¶ç³»ç»Ÿ

## æ¦‚è¿°

Sinter é‡‡ç”¨æè‡´ç®€åŒ–çš„æ’ä»¶æ¶æ„ï¼Œå…è®¸å¼€å‘è€…é€šè¿‡å®ç°ç®€å•çš„ trait æ¥æ·»åŠ æ–°å‘½ä»¤ï¼Œæ•´ä¸ªè¿‡ç¨‹åªéœ€å‡ è¡Œä»£ç ï¼Œæ— éœ€ä¿®æ”¹æ ¸å¿ƒä»£ç ã€‚

## æ ¸å¿ƒè®¾è®¡ç†å¿µ

- **å‡½æ•°å¼Builderæ¨¡å¼**ï¼šä½¿ç”¨é“¾å¼è°ƒç”¨æ³¨å†Œæ’ä»¶ï¼Œå¦‚ `Sinter::new().plugin(A).plugin(B).run()`
- **é›¶é…ç½®æ³¨å†Œ**ï¼šæ’ä»¶è‡ªåŠ¨æ³¨å†Œï¼Œæ— éœ€æ‰‹åŠ¨é…ç½®
- **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶æ£€æŸ¥æ’ä»¶æ¥å£
- **è¿è¡Œæ—¶çµæ´»**ï¼šæ”¯æŒæ¡ä»¶åŠ è½½å’ŒåŠ¨æ€æ‰©å±•
- **æè‡´ç®€å•**ï¼šæ·»åŠ æ–°å‘½ä»¤åªéœ€å®ç° trait

## æ¶æ„ç»„ä»¶

### CommandHandler Trait

æ‰€æœ‰æ’ä»¶å‘½ä»¤éƒ½å®ç° `CommandHandler` traitï¼š

```rust
#[async_trait]
pub trait CommandHandler: Send + Sync {
    fn name(&self) -> &'static str;
    fn about(&self) -> &'static str;
    fn configure(&self, cmd: Command) -> Command;
    async fn execute(&self, matches: &ArgMatches, cwd: &PathBuf) -> anyhow::Result<()>;
}
```

### Sinter Builder

ä½¿ç”¨å‡½æ•°å¼Builderæ¨¡å¼æ„å»ºåº”ç”¨ï¼Œæ”¯æŒé“¾å¼æ’ä»¶æ³¨å†Œï¼š

```rust
pub struct Sinter {
    plugins: Vec<Box<dyn CommandHandler>>,
}

impl Sinter {
    pub fn new() -> Self;
    pub fn plugin<H: CommandHandler + 'static>(self, handler: H) -> Self;
    pub fn plugins<H: CommandHandler + 'static, I: IntoIterator<Item = H>>(self, handlers: I) -> Self;
    pub async fn run(self) -> anyhow::Result<()>;
}
```

## æ·»åŠ æ–°æ’ä»¶çš„æ­¥éª¤

### æ–¹å¼ä¸€ï¼šä½¿ç”¨è¶…çº§ç®€å•çš„å®ï¼ˆæ¨èï¼‰

æœ€ç®€å•çš„æ–¹å¼ï¼Œæ— éœ€äº†è§£å†…éƒ¨ç»†èŠ‚ï¼š

```rust
// src/cmd/my_plugin.rs
use crate::simple_plugin;

simple_plugin!(
    "mycommand",           // å‘½ä»¤å
    "My awesome command",  // å‘½ä»¤æè¿°
    |cmd: clap::Command| cmd.arg(  // å‚æ•°é…ç½®
        clap::Arg::new("input")
            .help("Input file")
            .required(true)
    ),
    |matches: clap::ArgMatches, cwd: std::path::PathBuf| async move {  // æ‰§è¡Œé€»è¾‘
        let input = matches.get_one::<String>("input").unwrap();
        println!("Processing: {}", input);
        Ok(())
    }
);
```

ç„¶ååœ¨ `main.rs` ä¸­æ³¨å†Œï¼š

```rust
use sinter::{Sinter, cmd::plugin_mycommand};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    Sinter::new()
        .plugin(plugin_mycommand)
        .run()
        .await
}
```

### æ–¹å¼äºŒï¼šä¼ ç»Ÿæ–¹å¼ï¼ˆäº†è§£å†…éƒ¨ç»†èŠ‚ï¼‰

å¦‚æœä½ éœ€è¦æ›´å¤šæ§åˆ¶ï¼Œå¯ä»¥ä½¿ç”¨ä¼ ç»Ÿæ–¹å¼ï¼š

```rust
pub struct MyPlugin;

#[async_trait]
impl CommandHandler for MyPlugin {
    fn name(&self) -> &'static str {
        "mycommand"
    }

    fn about(&self) -> &'static str {
        "My awesome command"
    }

    fn configure(&self, cmd: Command) -> Command {
        cmd.arg(
            Arg::new("input")
                .help("Input file")
                .required(true)
        )
    }

    async fn execute(&self, matches: &ArgMatches, cwd: &PathBuf) -> anyhow::Result<()> {
        let input = matches.get_one::<String>("input").unwrap();
        println!("Processing: {}", input);
        Ok(())
    }
}
```

## å®Œæ•´ç¤ºä¾‹

### ä½¿ç”¨ç®€å•å®çš„å®Œæ•´ç¤ºä¾‹

```rust
// src/cmd/hello_plugin.rs
use crate::simple_plugin;

simple_plugin!(
    "hello",
    "Say hello to someone",
    |cmd: clap::Command| cmd.arg(
        clap::Arg::new("name")
            .help("Name to greet")
            .required(true)
    ),
    |matches: clap::ArgMatches, _cwd: std::path::PathBuf| async move {
        let name = matches.get_one::<String>("name").unwrap();
        println!("Hello, {}!", name);
        Ok(())
    }
);
```

```rust
// src/cmd/mod.rs
pub mod hello_plugin;
pub use hello_plugin::plugin_hello;
```

```rust
// src/main.rs - å‡½æ•°å¼Builderæ¨¡å¼
use sinter::{Sinter, cmd::plugin_hello};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // é“¾å¼æ³¨å†Œæ’ä»¶ï¼Œæè‡´ç®€æ´
    Sinter::new()
        .plugin(plugin_hello)
        .run()
        .await
}
```

### ä¼ ç»Ÿæ–¹å¼çš„å®Œæ•´ç¤ºä¾‹

```rust
// src/cmd/hello_plugin.rs
use crate::CommandHandler;
use async_trait::async_trait;
use clap::{Arg, ArgMatches, Command};
use std::path::PathBuf;

pub struct HelloPlugin;

#[async_trait]
impl CommandHandler for HelloPlugin {
    fn name(&self) -> &'static str {
        "hello"
    }

    fn about(&self) -> &'static str {
        "Say hello to someone"
    }

    fn configure(&self, cmd: Command) -> Command {
        cmd.arg(
            Arg::new("name")
                .help("Name to greet")
                .required(true)
        )
    }

    async fn execute(&self, matches: &ArgMatches, _cwd: &PathBuf) -> anyhow::Result<()> {
        let name = matches.get_one::<String>("name").unwrap();
        println!("Hello, {}!", name);
        Ok(())
    }
}
```

```rust
// src/cmd/mod.rs
pub mod hello_plugin;
pub use hello_plugin::HelloPlugin;
```

```rust
// src/main.rs - å‡½æ•°å¼Builderæ¨¡å¼
use sinter::{Sinter, cmd::HelloPlugin};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // é“¾å¼æ³¨å†Œæ’ä»¶ï¼Œæè‡´ç®€æ´
    Sinter::new()
        .plugin(HelloPlugin)
        .run()
        .await
}
```

## å‡½æ•°å¼Builderæ¨¡å¼ä½¿ç”¨

### åŸºæœ¬ç”¨æ³•

```rust
use sinter::{Sinter, cmd::*};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    Sinter::new()
        .plugin(JspPlugin)
        .run()
        .await
}
```

### é«˜çº§ç”¨æ³•

```rust
// æ‰¹é‡æ³¨å†Œæ’ä»¶
let plugins = vec![JspPlugin, HelloPlugin, BuildPlugin];
Sinter::new()
    .plugins(plugins)
    .run()
    .await?;

// æ¡ä»¶æ³¨å†Œ
Sinter::new()
    .plugin(BasicPlugin)
    .plugin(AdvancedPlugin)
    .run()
    .await?;
```

### é“¾å¼è°ƒç”¨çš„ç¾å­¦

```rust
// åƒæ­ç§¯æœ¨ä¸€æ ·æ„å»ºåº”ç”¨
Sinter::new()
    .plugin(WebPlugin)      // Webå¼€å‘æ’ä»¶
    .plugin(DatabasePlugin) // æ•°æ®åº“æ’ä»¶
    .plugin(TestPlugin)     // æµ‹è¯•æ’ä»¶
    .plugin(DocsPlugin)     // æ–‡æ¡£æ’ä»¶
    .run()
    .await?;
```

## ä½¿ç”¨æ’ä»¶

```bash
# æ’ä»¶ä¼šè‡ªåŠ¨å‡ºç°åœ¨å¸®åŠ©ä¸­
sinter --help

# ä½¿ç”¨æ’ä»¶å‘½ä»¤
sinter jsp myapp
sinter hello world
# è¾“å‡º: Hello, world!
```

## æ’ä»¶ç”Ÿå‘½å‘¨æœŸ

1. **ç¼–è¯‘æ—¶æ³¨å†Œ**ï¼šæ’ä»¶åœ¨ç¼–è¯‘æ—¶é€šè¿‡ `register_plugin!` å®æ³¨å†Œåˆ°å…¨å±€æ³¨å†Œè¡¨
2. **è¿è¡Œæ—¶åˆå§‹åŒ–**ï¼šåœ¨ `main` å‡½æ•°ä¸­è°ƒç”¨æ’ä»¶åˆå§‹åŒ–å‡½æ•°
3. **å‘½ä»¤æ‰§è¡Œ**ï¼šCLI è§£ææ—¶è‡ªåŠ¨å‘ç°æ’ä»¶å‘½ä»¤ï¼Œæ‰§è¡Œæ—¶è°ƒç”¨å¯¹åº”å¤„ç†å™¨

## è®¾è®¡ä¼˜åŠ¿

### 1. æè‡´ç®€å•
- æ·»åŠ æ–°å‘½ä»¤åªéœ€å®ç° trait
- æ— éœ€ä¿®æ”¹æ ¸å¿ƒä»£ç 
- è‡ªåŠ¨å‘½ä»¤å‘ç°å’Œæ³¨å†Œ

### 2. ç±»å‹å®‰å…¨
- ç¼–è¯‘æ—¶æ£€æŸ¥æ‰€æœ‰æ¥å£
- é¿å…è¿è¡Œæ—¶ç±»å‹é”™è¯¯
- æ™ºèƒ½æç¤ºå’Œé‡æ„æ”¯æŒ

### 3. é«˜æ€§èƒ½
- é›¶æˆæœ¬æŠ½è±¡
- é™æ€åˆ†å‘
- æœ€å°è¿è¡Œæ—¶å¼€é”€

### 4. å¯æ‰©å±•æ€§
- æ”¯æŒä»»æ„æ•°é‡çš„æ’ä»¶
- è¿è¡Œæ—¶åŠ¨æ€åŠ è½½
- æ¡ä»¶ç¼–è¯‘æ”¯æŒ

### 5. æ˜“ç»´æŠ¤
- æ’ä»¶å®Œå…¨ç‹¬ç«‹
- ç§»é™¤æ’ä»¶åªéœ€åˆ é™¤æ–‡ä»¶
- æ— æ®‹ç•™ä»£ç 

## æœ€ä½³å®è·µ

### æ’ä»¶å‘½å
- ä½¿ç”¨å°å†™å­—æ¯å’Œä¸‹åˆ’çº¿
- é¿å…ä¸å†…ç½®å‘½ä»¤å†²çª
- ä¿æŒç®€æ´æ˜äº†

### é”™è¯¯å¤„ç†
- ä½¿ç”¨ `anyhow::Result` è¿›è¡Œé”™è¯¯å¤„ç†
- æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯
- æ­£ç¡®å¤„ç†å¼‚æ­¥æ“ä½œ

### å‚æ•°è®¾è®¡
- ä½¿ç”¨ clap çš„ç±»å‹å®‰å…¨å‚æ•°
- æä¾›æ¸…æ™°çš„å¸®åŠ©ä¿¡æ¯
- æ”¯æŒå¯é€‰å‚æ•°

### æµ‹è¯•
- ä¸ºæ¯ä¸ªæ’ä»¶ç¼–å†™å•å…ƒæµ‹è¯•
- æµ‹è¯•å‚æ•°è§£æå’Œæ‰§è¡Œé€»è¾‘
- éªŒè¯é”™è¯¯å¤„ç†

## é«˜çº§ç”¨æ³•

### æ¡ä»¶æ’ä»¶
```rust
#[cfg(feature = "advanced")]
pub fn init_advanced_plugin() {
    crate::register_plugin(AdvancedPlugin);
}
```

### æ’ä»¶ç»„
```rust
pub fn init_all_plugins() {
    init_basic_plugin();
    init_advanced_plugin();
    init_experimental_plugin();
}
```

### åŠ¨æ€é…ç½®
```rust
impl CommandHandler for ConfigurablePlugin {
    fn configure(&self, cmd: Command) -> Command {
        // ä»é…ç½®æ–‡ä»¶è¯»å–å‚æ•°å®šä¹‰
        let config = load_config();
        cmd.args(&config.args)
    }
}
```

## è¿ç§»æŒ‡å—

### ä»æ—§æ¶æ„è¿ç§»

æ—§çš„å‘½ä»¤ç³»ç»Ÿéœ€è¦æ‰‹åŠ¨ä¿®æ”¹å¤šä¸ªæ–‡ä»¶ï¼š

```rust
// æ—§æ–¹å¼ - éœ€è¦ä¿®æ”¹4ä¸ªæ–‡ä»¶
// 1. cli.rs - æ·»åŠ æšä¸¾å˜ä½“å’Œè§£æ
// 2. lib.rs - æ·»åŠ matchåˆ†æ”¯
// 3. cmd/mod.rs - æ·»åŠ æ¨¡å—
// 4. main.rs - å¯èƒ½éœ€è¦æ³¨å†Œ
```

æ–°çš„æ’ä»¶ç³»ç»Ÿåªéœ€ï¼š

```rust
// æ–°æ–¹å¼ - åªéœ€ä¸€ä¸ªæ–‡ä»¶
pub struct MyCommand;
impl CommandHandler for MyCommand { /* ... */ }
crate::register_plugin(MyCommand);
```

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

1. **æ’ä»¶æœªæ˜¾ç¤ºåœ¨å¸®åŠ©ä¸­**
   - æ£€æŸ¥æ˜¯å¦è°ƒç”¨äº†åˆå§‹åŒ–å‡½æ•°
   - éªŒè¯æ’ä»¶åç§°ä¸ä¸å†…ç½®å‘½ä»¤å†²çª

2. **ç¼–è¯‘é”™è¯¯**
   - ç¡®ä¿å®ç°äº†æ‰€æœ‰ trait æ–¹æ³•
   - æ£€æŸ¥å¼‚æ­¥å‡½æ•°ç­¾å

3. **è¿è¡Œæ—¶é”™è¯¯**
   - éªŒè¯å‚æ•°è§£æé€»è¾‘
   - æ£€æŸ¥æ–‡ä»¶è·¯å¾„å¤„ç†

### è°ƒè¯•æŠ€å·§

- ä½¿ç”¨ `cargo build --verbose` æŸ¥çœ‹ç¼–è¯‘è¯¦æƒ…
- æ·»åŠ æ—¥å¿—è¾“å‡ºè°ƒè¯•æ’ä»¶æ‰§è¡Œ
- ä½¿ç”¨ `println!` éªŒè¯åˆå§‹åŒ–é¡ºåº

## æœªæ¥æ‰©å±•

- **æ’ä»¶å¸‚åœº**ï¼šæ”¯æŒä»è¿œç¨‹ä»“åº“åŠ è½½æ’ä»¶
- **çƒ­é‡è½½**ï¼šè¿è¡Œæ—¶é‡æ–°åŠ è½½æ’ä»¶
- **ä¾èµ–ç®¡ç†**ï¼šæ’ä»¶é—´çš„ä¾èµ–å…³ç³»
- **é…ç½®ç•Œé¢**ï¼šå›¾å½¢åŒ–æ’ä»¶é…ç½®

---

è¿™ä¸ªæ’ä»¶ç³»ç»Ÿå°†å¤æ‚æ€§é™åˆ°æœ€ä½ï¼ŒåŒæ—¶ä¿æŒäº†æœ€å¤§çš„çµæ´»æ€§å’Œæ‰©å±•æ€§ã€‚å¼€å‘è€…å¯ä»¥ä¸“æ³¨äºä¸šåŠ¡é€»è¾‘ï¼Œè€Œä¸å¿…å…³å¿ƒæ¡†æ¶ç»†èŠ‚ã€‚


/// FILE: README.md

# Sinter

A Cargo-like build tool for Scala projects.

ğŸ“– **Documentation**: [English](README.md) | [ä¸­æ–‡](README_CN.md)

## Features

- Project initialization with `sinter new <name>`
- Workspace initialization with `sinter init`
- Building Scala projects with `sinter build`
- Running Scala applications with `sinter run`
- Adding dependencies with `sinter add <dep>`
- Running tests with `sinter test`
- Workspace management with `sinter workspace`
- Internationalization support with `sinter i18n`
- Configurable project settings via `project.toml`

## Installation

### From Source

```bash
git clone https://github.com/s0raLin/sinter.git
cd sinter
cargo build --release
# Add target/release/sinter to your PATH
```

### Prerequisites

- Rust (latest stable)
- Scala CLI (for Scala compilation and execution)
- Coursier (for dependency management, optional but recommended)

## Quick Start

```bash
# Create a new project
sinter new hello-scala
cd hello-scala

# Add a dependency
sinter add cats

# Build and run
sinter build
sinter run
```

## Usage

### Getting Help

```bash
sinter --help          # Show all commands
sinter [command] --help # Show help for specific command
```

### Initialize a workspace

```bash
mkdir my-workspace
cd my-workspace
sinter init
```

This creates a workspace configuration file `workspace.project.toml`.

### Create a new project

```bash
sinter new my-scala-project
cd my-scala-project
```

This creates a new Scala project with the following structure:
```
my-scala-project/
â”œâ”€â”€ project.toml          # Project configuration
â””â”€â”€ src/main/scala/
    â””â”€â”€ Main.scala       # Main application file
```

### Manage workspace

```bash
sinter workspace add path/to/project
```

Adds a project to the workspace.

### Build the project

```bash
sinter build
```

Compiles all Scala sources in `src/main/scala` and places compiled classes in the `target_dir` specified in `project.toml`.

### Run the project

```bash
sinter run
sinter run path/to/MyFile.scala
sinter run --lib
```

- Without arguments: Runs the main file specified in `project.toml`
- With a file path: Runs the specified Scala file
- `--lib`: Forces library mode (compile only, no execution)

### Add dependencies

```bash
sinter add cats
sinter add org.typelevel::cats-core_2.13:2.10.0
sinter add cats@2.13:2.10.0
```

Dependency format: `group::artifact[@scala-version][:version]`

- `cats`: Adds the latest stable version of cats-core for the project's Scala version
- `org.typelevel::cats-core_2.13:2.10.0`: Full specification with group, artifact, Scala version, and version
- `cats@2.13:2.10.0`: Short form with Scala version and version

### Run tests

```bash
sinter test
sinter test path/to/TestFile.scala
```

Runs tests in the project or a specific test file.

## Configuration

Project configuration is stored in `project.toml`:

```toml
[package]
name = "my-project"
version = "0.1.0"
main = "Main"
scala_version = "2.13"
source_dir = "src/main/scala"
target_dir = "target"

[dependencies]
"org.typelevel::cats-core_2.13" = "2.10.0"
```

## Troubleshooting

### Common Issues

- **Scala CLI not found**: Make sure Scala CLI is installed and available in your PATH
- **Coursier not found**: Coursier is optional but recommended for better dependency management. Install it from https://get-coursier.io/
- **Build fails**: Check that all dependencies are correctly specified in `project.toml`
- **Run fails**: Ensure your main file has a proper entry point (extends App or has a main method)

### Getting More Help

- Run `sinter --help` for command overview
- Check the [Scala CLI documentation](https://scala-cli.virtuslab.org/) for Scala-specific issues
- Report issues on the [GitHub repository](https://github.com/s0raLin/sinter)

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.


/// FILE: README_CN.md

# Sinter

ä¸€ä¸ªç±»ä¼¼ Cargo çš„ Scala é¡¹ç›®æ„å»ºå·¥å…·ã€‚

ğŸ“– **æ–‡æ¡£**: [English](README.md) | [ä¸­æ–‡](README_CN.md)

## åŠŸèƒ½ç‰¹æ€§

- ä½¿ç”¨ `sinter new <name>` åˆå§‹åŒ–é¡¹ç›®
- ä½¿ç”¨ `sinter init` åˆå§‹åŒ–å·¥ä½œç©ºé—´
- ä½¿ç”¨ `sinter build` æ„å»º Scala é¡¹ç›®
- ä½¿ç”¨ `sinter run` è¿è¡Œ Scala åº”ç”¨ç¨‹åº
- ä½¿ç”¨ `sinter add <dep>` æ·»åŠ ä¾èµ–
- ä½¿ç”¨ `sinter test` è¿è¡Œæµ‹è¯•
- ä½¿ç”¨ `sinter workspace` ç®¡ç†å·¥ä½œç©ºé—´
- ä½¿ç”¨ `sinter i18n` æ”¯æŒå›½é™…åŒ–
- é€šè¿‡ `project.toml` é…ç½®é¡¹ç›®è®¾ç½®

## å¿«é€Ÿå¼€å§‹

```bash
# åˆ›å»ºæ–°é¡¹ç›®
sinter new hello-scala
cd hello-scala

# æ·»åŠ ä¾èµ–
sinter add cats

# æ„å»ºå¹¶è¿è¡Œ
sinter build
sinter run
```

## å®‰è£…

### ä»æºç å®‰è£…

```bash
git clone https://github.com/s0raLin/sinter.git
cd sinter
cargo build --release
# å°† target/release/sinter æ·»åŠ åˆ° PATH
```

### å‰ç½®è¦æ±‚

- Rustï¼ˆæœ€æ–°ç¨³å®šç‰ˆï¼‰
- Scala CLIï¼ˆç”¨äº Scala ç¼–è¯‘å’Œæ‰§è¡Œï¼‰
- Coursierï¼ˆç”¨äºä¾èµ–ç®¡ç†ï¼Œå¯é€‰ä½†æ¨èï¼‰

## ä½¿ç”¨æ–¹æ³•

### è·å–å¸®åŠ©

```bash
sinter --help          # æ˜¾ç¤ºæ‰€æœ‰å‘½ä»¤
sinter [command] --help # æ˜¾ç¤ºç‰¹å®šå‘½ä»¤çš„å¸®åŠ©
```

### åˆå§‹åŒ–å·¥ä½œç©ºé—´

```bash
mkdir my-workspace
cd my-workspace
sinter init
```

è¿™å°†åˆ›å»ºå·¥ä½œç©ºé—´é…ç½®æ–‡ä»¶ `workspace.project.toml`ã€‚

### åˆ›å»ºæ–°é¡¹ç›®

```bash
sinter new my-scala-project
cd my-scala-project
```

è¿™å°†åˆ›å»ºä¸€ä¸ªå…·æœ‰ä»¥ä¸‹ç»“æ„çš„ Scala é¡¹ç›®ï¼š
```
my-scala-project/
â”œâ”€â”€ project.toml          # é¡¹ç›®é…ç½®
â””â”€â”€ src/main/scala/
    â””â”€â”€ Main.scala       # ä¸»åº”ç”¨ç¨‹åºæ–‡ä»¶
```

### ç®¡ç†å·¥ä½œç©ºé—´

```bash
sinter workspace add path/to/project
```

å‘å·¥ä½œç©ºé—´æ·»åŠ é¡¹ç›®ã€‚

### æ„å»ºé¡¹ç›®

```bash
sinter build
```

ç¼–è¯‘ `src/main/scala` ä¸­çš„æ‰€æœ‰ Scala æºä»£ç ï¼Œå¹¶å°†ç¼–è¯‘åçš„ç±»æ”¾åœ¨ `project.toml` ä¸­æŒ‡å®šçš„ `target_dir`ã€‚

### è¿è¡Œé¡¹ç›®

```bash
sinter run
sinter run path/to/MyFile.scala
sinter run --lib
```

- æ— å‚æ•°ï¼šè¿è¡Œ `project.toml` ä¸­æŒ‡å®šçš„ä¸»æ–‡ä»¶
- æŒ‡å®šæ–‡ä»¶è·¯å¾„ï¼šè¿è¡ŒæŒ‡å®šçš„ Scala æ–‡ä»¶
- `--lib`ï¼šå¼ºåˆ¶åº“æ¨¡å¼ï¼ˆä»…ç¼–è¯‘ï¼Œä¸æ‰§è¡Œï¼‰

### æ·»åŠ ä¾èµ–

```bash
sinter add cats
sinter add org.typelevel::cats-core_2.13:2.10.0
sinter add cats@2.13:2.10.0
sinter add ../my-sbt-project
sinter add sbt:../my-sbt-project
```

ä¾èµ–æ ¼å¼ï¼š`group::artifact[@scala-version][:version]` æˆ– `path/to/sbt/project`

- `cats`ï¼šä¸ºé¡¹ç›® Scala ç‰ˆæœ¬æ·»åŠ æœ€æ–°ç¨³å®šç‰ˆæœ¬çš„ cats-core
- `org.typelevel::cats-core_2.13:2.10.0`ï¼šå®Œæ•´è§„èŒƒï¼ŒåŒ…æ‹¬ç»„ã€åˆ¶å“ã€Scala ç‰ˆæœ¬å’Œç‰ˆæœ¬
- `cats@2.13:2.10.0`ï¼šç®€çŸ­å½¢å¼ï¼ŒåŒ…å« Scala ç‰ˆæœ¬å’Œç‰ˆæœ¬
- `../my-sbt-project`ï¼šæ·»åŠ æœ¬åœ° sbt é¡¹ç›®çš„ä¾èµ–ï¼ˆä¼šè‡ªåŠ¨æ„å»º sbt é¡¹ç›®å¹¶åŒ…å«ç”Ÿæˆçš„ JARï¼‰
- `sbt:../my-sbt-project`ï¼šæ˜¾å¼æŒ‡å®š sbt é¡¹ç›®è·¯å¾„

### è¿è¡Œæµ‹è¯•

```bash
sinter test
sinter test path/to/TestFile.scala
```

è¿è¡Œé¡¹ç›®ä¸­çš„æµ‹è¯•æˆ–ç‰¹å®šæµ‹è¯•æ–‡ä»¶ã€‚

## é…ç½®

é¡¹ç›®é…ç½®å­˜å‚¨åœ¨ `project.toml` ä¸­ï¼š

```toml
[package]
name = "my-project"
version = "0.1.0"
main = "Main"
scala_version = "2.13"
source_dir = "src/main/scala"
target_dir = "target"

[dependencies]
"org.typelevel::cats-core_2.13" = "2.10.0"
```

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

- **æ‰¾ä¸åˆ° Scala CLI**ï¼šç¡®ä¿ Scala CLI å·²å®‰è£…å¹¶åœ¨ PATH ä¸­å¯ç”¨
- **æ‰¾ä¸åˆ° Coursier**ï¼šCoursier æ˜¯å¯é€‰çš„ä½†æ¨èç”¨äºæ›´å¥½çš„ä¾èµ–ç®¡ç†ã€‚ä» https://get-coursier.io/ å®‰è£…
- **æ„å»ºå¤±è´¥**ï¼šæ£€æŸ¥ `project.toml` ä¸­çš„æ‰€æœ‰ä¾èµ–æ˜¯å¦æ­£ç¡®æŒ‡å®š
- **è¿è¡Œå¤±è´¥**ï¼šç¡®ä¿ä¸»æ–‡ä»¶å…·æœ‰æ­£ç¡®çš„å…¥å£ç‚¹ï¼ˆextends App æˆ–å…·æœ‰ main æ–¹æ³•ï¼‰

### è·å–æ›´å¤šå¸®åŠ©

- è¿è¡Œ `sinter --help` è·å–å‘½ä»¤æ¦‚è§ˆ
- æŸ¥çœ‹ [Scala CLI æ–‡æ¡£](https://scala-cli.virtuslab.org/) äº†è§£ Scala ç›¸å…³é—®é¢˜
- åœ¨ [GitHub ä»“åº“](https://github.com/s0raLin/sinter) ä¸ŠæŠ¥å‘Šé—®é¢˜

## è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ MIT è®¸å¯è¯ - æŸ¥çœ‹ [LICENSE](LICENSE) æ–‡ä»¶äº†è§£è¯¦æƒ…ã€‚


/// FILE: crates/sinter-cli/Cargo.toml

[package]
name = "sinter-cli"
version.workspace = true
edition.workspace = true
license.workspace = true

[[bin]]
name = "sinter"
path = "src/main.rs"

[dependencies]
sinter = { path = "../sinter-core" }
sinter-plugins = { path = "../sinter-plugins" }
anyhow = { workspace = true }
tokio = { workspace = true }




/// FILE: crates/sinter-cli/src/main.rs

use sinter::Sinter;

// ä»æ’ä»¶ crate å¯¼å…¥æ’ä»¶
// æ³¨æ„ï¼šæ’ä»¶ crate ä¾èµ–ä¸»é¡¹ç›®ï¼Œä½†ä¸»é¡¹ç›®ä¸ä¾èµ–æ’ä»¶ crate
// è¿™æ ·å¯ä»¥é¿å…å¾ªç¯ä¾èµ–
use sinter_plugins::jsp_plugin;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // å‡½æ•°å¼Builderæ¨¡å¼ - é“¾å¼æ³¨å†Œæ’ä»¶
    Sinter::new()
        .plugin(jsp_plugin())
        .run()
        .await
}


/// FILE: crates/sinter-core/Cargo.toml

# crates/sinter/Cargo.toml
[package]
name = "sinter"
version.workspace = true
edition.workspace = true
license.workspace = true
description = "Core engine for sinter"
build = "build.rs"

[features]
default = ["lang-en"]
lang-en = []
lang-zh = []

[build-dependencies]
serde_json = "1"

[dependencies]
anyhow      = { workspace = true }
async-trait = { workspace = true }
clap        = { workspace = true }
tokio       = { workspace = true }
serde       = { workspace = true }
toml_edit   = { workspace = true }
config      = { workspace = true }
dirs        = { workspace = true }
paste       = { workspace = true }
inventory   = { workspace = true }
serde_json  = { workspace = true }




/// FILE: crates/sinter-core/I18N.md

# å›½é™…åŒ–æ”¯æŒ

Sinter ä½¿ç”¨æ„å»ºæ—¶å›½é™…åŒ–ç³»ç»Ÿï¼Œåœ¨ç¼–è¯‘æ—¶ç”Ÿæˆç¿»è¯‘ä»£ç ï¼Œæä¾›é›¶è¿è¡Œæ—¶å¼€é”€çš„ç±»å‹å®‰å…¨ç¿»è¯‘ã€‚

## å·¥ä½œåŸç†

1. **ç¿»è¯‘æ–‡ä»¶**: `templates/i18n.json` åŒ…å«æ‰€æœ‰è¯­è¨€çš„ç¿»è¯‘
2. **æ„å»ºè„šæœ¬**: `build.rs` åœ¨ç¼–è¯‘æ—¶è¯»å–ç¿»è¯‘æ–‡ä»¶å¹¶ç”Ÿæˆ Rust ä»£ç 
3. **ç‰¹æ€§æ ‡å¿—**: é€šè¿‡ Cargo ç‰¹æ€§æ ‡å¿—é€‰æ‹©è¯­è¨€
4. **ç”Ÿæˆçš„ä»£ç **: åœ¨ `OUT_DIR/i18n.rs` ä¸­ç”Ÿæˆç±»å‹å®‰å…¨çš„ç¿»è¯‘å‡½æ•°

## ä½¿ç”¨æ–¹æ³•

### é»˜è®¤æ„å»ºï¼ˆè‹±æ–‡ï¼‰

```bash
cargo build
# æˆ–
cargo build --package sinter
```

### æ„å»ºä¸­æ–‡ç‰ˆæœ¬

```bash
cargo build --package sinter --features lang-zh
# æˆ–ç¦ç”¨é»˜è®¤ç‰¹æ€§ï¼Œåªå¯ç”¨ä¸­æ–‡
cargo build --package sinter --no-default-features --features lang-zh
```

### åœ¨ä»£ç ä¸­ä½¿ç”¨

```rust
use sinter::i18n::{t, tf};

// ç®€å•ç¿»è¯‘
println!("{}", t("main_about"));

// å¸¦å‚æ•°çš„ç¿»è¯‘ï¼ˆä½¿ç”¨ {} å ä½ç¬¦ï¼‰
println!("{}", tf("created_project", &["my-project"]));
```

## æ·»åŠ æ–°ç¿»è¯‘

1. ç¼–è¾‘ `templates/i18n.json`
2. ä¸ºæ¯ä¸ªè¯­è¨€æ·»åŠ å¯¹åº”çš„é”®å€¼å¯¹
3. é‡æ–°æ„å»ºé¡¹ç›®

ç¤ºä¾‹ï¼š

```json
{
  "en": {
    "my_new_key": "My new message"
  },
  "zh": {
    "my_new_key": "æˆ‘çš„æ–°æ¶ˆæ¯"
  }
}
```

## æ·»åŠ æ–°è¯­è¨€

1. åœ¨ `templates/i18n.json` ä¸­æ·»åŠ æ–°è¯­è¨€å¯¹è±¡
2. åœ¨ `Cargo.toml` ä¸­æ·»åŠ æ–°çš„ç‰¹æ€§æ ‡å¿—ï¼š
   ```toml
   [features]
   lang-ja = []  # æ—¥è¯­
   ```
3. åœ¨ `build.rs` ä¸­æ·»åŠ è¯­è¨€æ£€æµ‹é€»è¾‘
4. ä½¿ç”¨ `--features lang-ja` æ„å»º

## ä¼˜åŠ¿

- âœ… **é›¶è¿è¡Œæ—¶å¼€é”€**: ç¿»è¯‘åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œæ— è¿è¡Œæ—¶æŸ¥æ‰¾
- âœ… **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶æ£€æŸ¥ç¿»è¯‘é”®æ˜¯å¦å­˜åœ¨
- âœ… **æ˜“äºç»´æŠ¤**: æ‰€æœ‰ç¿»è¯‘é›†ä¸­åœ¨ä¸€ä¸ª JSON æ–‡ä»¶ä¸­
- âœ… **å¤šè¯­è¨€æ„å»º**: å¯ä»¥ä¸ºä¸åŒè¯­è¨€æ„å»ºä¸åŒçš„äºŒè¿›åˆ¶æ–‡ä»¶
- âœ… **æ€§èƒ½ä¼˜åŒ–**: å­—ç¬¦ä¸²å­—é¢é‡ç›´æ¥åµŒå…¥äºŒè¿›åˆ¶æ–‡ä»¶

## æ³¨æ„äº‹é¡¹

- ç¿»è¯‘æ–‡ä»¶æ”¹å˜åéœ€è¦é‡æ–°æ„å»º
- æœªæ‰¾åˆ°çš„ç¿»è¯‘é”®ä¼šè¿”å› `"[Translation key not found]"`
- æ ¼å¼åŒ–å­—ç¬¦ä¸²ä½¿ç”¨ `{}` ä½œä¸ºå ä½ç¬¦ï¼ŒæŒ‰é¡ºåºæ›¿æ¢å‚æ•°

## Rust Analyzer é…ç½®

å¦‚æœé‡åˆ° `OUT_DIR not set` é”™è¯¯ï¼Œè¯·ç¡®ä¿ rust-analyzer å·²é…ç½®ä¸ºè¿è¡Œæ„å»ºè„šæœ¬ï¼š

åœ¨ `.vscode/settings.json` æˆ– `rust-analyzer` é…ç½®ä¸­æ·»åŠ ï¼š

```json
{
  "rust-analyzer.cargo.buildScripts.enable": true,
  "rust-analyzer.cargo.buildScripts.useRustcWrapper": true
}
```

æˆ–è€…åœ¨é¡¹ç›®æ ¹ç›®å½•çš„ `.cargo/config.toml` ä¸­é…ç½®ã€‚

**æ³¨æ„**ï¼šå³ä½¿ rust-analyzer æ— æ³•è¿è¡Œæ„å»ºè„šæœ¬ï¼Œä»£ç ä»ç„¶å¯ä»¥æ­£å¸¸ç¼–è¯‘ï¼Œå› ä¸ºå®é™…æ„å»ºæ—¶ `build.rs` æ€»æ˜¯ä¼šè¿è¡Œã€‚




/// FILE: crates/sinter-core/bin/README.md

# Coursier å¯æ‰§è¡Œæ–‡ä»¶

æ­¤ç›®å½•ç”¨äºå­˜æ”¾æ‰“åŒ…çš„ `coursier` å¯æ‰§è¡Œæ–‡ä»¶ã€‚

## å¦‚ä½•æ·»åŠ  coursier å¯æ‰§è¡Œæ–‡ä»¶

### Linux (x86_64)
```bash
curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-pc-linux.gz | gzip -d > coursier
chmod +x coursier
```

### macOS (x86_64)
```bash
curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-apple-darwin.gz | gzip -d > coursier
chmod +x coursier
```

### macOS (ARM64)
```bash
curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-aarch64-apple-darwin.gz | gzip -d > coursier
chmod +x coursier
```

### Windows
ä¸‹è½½ `cs-x86_64-pc-win32.zip`ï¼Œè§£å‹åå°† `cs.exe` é‡å‘½åä¸º `coursier.exe` å¹¶æ”¾å…¥æ­¤ç›®å½•ã€‚

## å¿«é€Ÿä¸‹è½½

ä½¿ç”¨æä¾›çš„è„šæœ¬è‡ªåŠ¨ä¸‹è½½ï¼š

```bash
cd crates/sinter-core/bin
./download-coursier.sh
```

## ä½¿ç”¨è¯´æ˜

å¦‚æœæ­¤ç›®å½•ä¸­å­˜åœ¨ `coursier`ï¼ˆæˆ– `coursier.exe`ï¼‰ï¼Œsinter å°†ä¼˜å…ˆä½¿ç”¨æ‰“åŒ…çš„ç‰ˆæœ¬ï¼Œè€Œä¸æ˜¯ç³»ç»Ÿå®‰è£…çš„ç‰ˆæœ¬ã€‚

æŸ¥æ‰¾é¡ºåºï¼š
1. **æ‰“åŒ…çš„ç‰ˆæœ¬**ï¼š`<å¯æ‰§è¡Œæ–‡ä»¶ç›®å½•>/bin/coursier` æˆ–å¼€å‘æ—¶çš„ `CARGO_MANIFEST_DIR/bin/coursier`
2. **ç³»ç»Ÿå‘½ä»¤**ï¼šPATH ä¸­çš„ `coursier` å‘½ä»¤
3. **å›é€€æ–¹æ¡ˆ**ï¼šå¦‚æœä¸¤è€…éƒ½ä¸å­˜åœ¨ï¼Œsinter ä¼šå›é€€åˆ°ä½¿ç”¨ `scala-cli` è¿›è¡Œä¾èµ–ç®¡ç†

## æ„å»ºæ—¶åŒ…å«

åœ¨æ„å»ºå‘å¸ƒç‰ˆæœ¬æ—¶ï¼Œç¡®ä¿å°† `bin/coursier` å¤åˆ¶åˆ°å¯æ‰§è¡Œæ–‡ä»¶ç›®å½•çš„ `bin/` å­ç›®å½•ä¸­ï¼Œè¿™æ ·æ‰“åŒ…çš„ç‰ˆæœ¬æ‰èƒ½è¢«æ‰¾åˆ°ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœå¯æ‰§è¡Œæ–‡ä»¶åœ¨ `target/release/sinter`ï¼Œåˆ™ coursier åº”è¯¥åœ¨ `target/release/bin/coursier`ã€‚




/// FILE: crates/sinter-core/build.rs

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // å‘Šè¯‰ Cargo å¦‚æœç¿»è¯‘æ–‡ä»¶æ”¹å˜ï¼Œéœ€è¦é‡æ–°æ„å»º
    println!("cargo:rerun-if-changed=templates/i18n.json");
    
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let i18n_path = Path::new(&manifest_dir).join("templates/i18n.json");
    
    // è¯»å–ç¿»è¯‘æ–‡ä»¶
    let i18n_content = fs::read_to_string(&i18n_path)
        .expect("Failed to read i18n.json");
    
    let translations: serde_json::Value = serde_json::from_str(&i18n_content)
        .expect("Failed to parse i18n.json");
    
    // ç¡®å®šå½“å‰è¯­è¨€ï¼ˆé€šè¿‡ç‰¹æ€§æ ‡å¿—ï¼‰
    let lang = if cfg!(feature = "lang-zh") {
        "zh"
    } else {
        "en"
    };
    
    // è·å–å½“å‰è¯­è¨€çš„ç¿»è¯‘
    let lang_translations = translations.get(lang)
        .and_then(|v| v.as_object())
        .expect(&format!("Language '{}' not found in i18n.json", lang));
    
    // ç”Ÿæˆè¾“å‡ºç›®å½•
    let out_dir = env::var("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir).join("i18n.rs");
    
    // ç”Ÿæˆ Rust ä»£ç 
    let mut code = String::new();
    code.push_str("// Auto-generated i18n code - DO NOT EDIT\n");
    code.push_str("// This file is generated by build.rs\n\n");
    code.push_str("/// Get a translated string by key\n");
    code.push_str("pub fn t(key: &str) -> &'static str {\n");
    code.push_str("    match key {\n");
    
    // ä¸ºæ¯ä¸ªç¿»è¯‘é”®ç”Ÿæˆ match arm
    for (key, value) in lang_translations {
        let value_str = value.as_str().unwrap();
        // è½¬ä¹‰å­—ç¬¦ä¸²ä¸­çš„ç‰¹æ®Šå­—ç¬¦
        let escaped = value_str
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n");
        code.push_str(&format!("        \"{}\" => \"{}\",\n", key, escaped));
    }
    
    // å¦‚æœ key ä¸åŒ¹é…ï¼Œè¿”å›ä¸€ä¸ªé»˜è®¤æ¶ˆæ¯è€Œä¸æ˜¯ key æœ¬èº«ï¼ˆé¿å…ç”Ÿå‘½å‘¨æœŸé—®é¢˜ï¼‰
    code.push_str("        _ => \"[Translation key not found]\",\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    // ç”Ÿæˆæ ¼å¼åŒ–å‡½æ•°
    code.push_str("/// Format a translated string with arguments\n");
    code.push_str("pub fn tf(key: &str, args: &[&str]) -> String {\n");
    code.push_str("    let template = t(key);\n");
    code.push_str("    let mut result = template.to_string();\n");
    code.push_str("    for arg in args {\n");
    code.push_str("        if result.contains(\"{}\") {\n");
    code.push_str("            result = result.replacen(\"{}\", arg, 1);\n");
    code.push_str("        } else {\n");
    code.push_str("            break;\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("    result\n");
    code.push_str("}\n");
    
    // å†™å…¥æ–‡ä»¶
    fs::write(&out_path, code)
        .expect("Failed to write generated i18n.rs");
    
    println!("cargo:warning=Generated i18n.rs for language: {}", lang);
}




/// FILE: crates/sinter-core/src/cli.rs

// src/cli.rs
use clap::{Arg, Command};
use std::path::PathBuf;

pub struct Cli {
    pub command: Option<crate::cmd::Commands>,
    pub raw_matches: clap::ArgMatches,
}

impl Cli {

    // è¾…åŠ©å‡½æ•°ï¼šå®‰å…¨æå–å¿…éœ€çš„å­—ç¬¦ä¸²å‚æ•°
    fn extract_required_string(matches: &clap::ArgMatches, key: &str) -> String {
        matches.get_one::<String>(key).unwrap().clone()
    }

    // è¾…åŠ©å‡½æ•°ï¼šå®‰å…¨æå–å¯é€‰çš„å­—ç¬¦ä¸²å‚æ•°å¹¶è½¬æ¢ä¸ºPathBuf
    fn extract_optional_path(matches: &clap::ArgMatches, key: &str) -> Option<PathBuf> {
        matches.get_one::<String>(key).map(|s| PathBuf::from(s))
    }

    pub fn parse() -> Self {
        Self::parse_with_plugins(&[])
    }

    fn parse_command_from_matches(matches: &clap::ArgMatches) -> Option<crate::cmd::Commands> {
        match matches.subcommand() {
            Some(("new", sub_m)) => Some(crate::cmd::Commands::New {
                name: Self::extract_required_string(sub_m, "name"),
            }),
            Some(("init", _)) => Some(crate::cmd::Commands::Init),
            Some(("build", _)) => Some(crate::cmd::Commands::Build),
            Some(("run", sub_m)) => Some(crate::cmd::Commands::Run {
                file: Self::extract_optional_path(sub_m, "file"),
                lib: sub_m.get_flag("lib"),
            }),
            Some(("add", sub_m)) => Some(crate::cmd::Commands::Add {
                deps: sub_m.get_many::<String>("dep").unwrap_or_default().map(|s| s.to_string()).collect(),
            }),
            Some(("test", sub_m)) => Some(crate::cmd::Commands::Test {
                file: Self::extract_optional_path(sub_m, "file"),
            }),
            Some(("workspace", ws_m)) => match ws_m.subcommand() {
                Some(("add", sub_m)) => Some(crate::cmd::Commands::Workspace {
                    subcommand: crate::cmd::WorkspaceCommands::Add {
                        paths: sub_m.get_many::<String>("path").unwrap_or_default().map(|s| s.to_string()).collect(),
                    }
                }),
                _ => None,
            },
            Some(("jsp", sub_m)) => Some(crate::cmd::Commands::Jsp {
                name: Self::extract_required_string(sub_m, "name"),
            }),
            _ => None,
        }
    }

    pub fn parse_with_plugins(plugins: &[Box<dyn crate::core::CommandHandler>]) -> Self {
        let mut cmd = Command::new("sinter")
            .about(crate::i18n::t("main_about"))
            .subcommand(
                Command::new("new")
                    .about(crate::i18n::t("new_about"))
                    .arg(
                        Arg::new("name")
                            .help(crate::i18n::t("new_name_help"))
                            .required(true)
                    )
            )
            .subcommand(
                Command::new("init")
                    .about(crate::i18n::t("init_about"))
            )
            .subcommand(
                Command::new("build")
                    .about(crate::i18n::t("build_about"))
            )
            .subcommand(
                Command::new("run")
                    .about(crate::i18n::t("run_about"))
                    .arg(
                        Arg::new("file")
                            .help(crate::i18n::t("run_file_help"))
                            .value_name("FILE")
                    )
                    .arg(
                        Arg::new("lib")
                            .long("lib")
                            .help(crate::i18n::t("run_lib_help"))
                            .action(clap::ArgAction::SetTrue)
                    )
            )
            .subcommand(
                Command::new("add")
                    .about(crate::i18n::t("add_about"))
                    .arg(
                        Arg::new("dep")
                            .help(crate::i18n::t("add_dep_help"))
                            .value_name("DEP")
                            .required(true)
                            .num_args(1..)
                    )
            )
            .subcommand(
                Command::new("test")
                    .about(crate::i18n::t("test_about"))
                    .arg(
                        Arg::new("file")
                            .help(crate::i18n::t("test_file_help"))
                            .value_name("FILE")
                    )
            )
            .subcommand(
                Command::new("workspace")
                    .about(crate::i18n::t("workspace_about"))
                    .subcommand(
                        Command::new("add")
                            .about(crate::i18n::t("workspace_add_about"))
                            .arg(
                                Arg::new("path")
                                    .help(crate::i18n::t("workspace_add_path_help"))
                                    .value_name("PATH")
                                    .required(true)
                                    .num_args(1..)
                            )
                    )
            );

        // è‡ªåŠ¨æ·»åŠ æ‰€æœ‰æ’ä»¶å‘½ä»¤
        for handler in plugins {
            cmd = cmd.subcommand(handler.configure(Command::new(handler.name())));
        }

        let matches = cmd.get_matches();

        let command = Self::parse_command_from_matches(&matches);

        Cli { command, raw_matches: matches }
    }
}


/// FILE: crates/sinter-core/src/cmd/builtin.rs

//! å†…ç½®å‘½ä»¤å®ç°
//!
//! åŒ…å«æ‰€æœ‰å†…ç½®å‘½ä»¤çš„æ‰§è¡Œé€»è¾‘

use crate::Commands;
use crate::cmd::{cmd_new, cmd_init, cmd_test, cmd_workspace};
use crate::build::{run_scala_file, run_single_file_with_deps, setup_bsp};
use crate::deps::add_dependency;
use crate::deps::deps::Dependency;
use crate::config::Project;
use std::path::PathBuf;

/// æ˜¾ç¤ºå·¥ä½œç©ºé—´å’Œä¾èµ–ä¿¡æ¯
fn print_workspace_and_dependencies(
    project: &Project,
    project_dir: &PathBuf,
    workspace_root: Option<&PathBuf>,
    workspace_project: Option<&Project>,
) {
    if let Some(ws_root) = workspace_root {
        println!("{}", crate::i18n::tf("running_in_workspace", &[&ws_root.display().to_string()]));
        
        // æ˜¾ç¤ºå·¥ä½œç©ºé—´ä¾èµ–
        if let Some(ws_proj) = workspace_project {
            if let Some(ws_config) = &ws_proj.workspace {
                let ws_deps: Vec<Dependency> = ws_config.dependencies
                    .iter()
                    .filter_map(|(k, spec)| match spec {
                        crate::config::DependencySpec::Simple(version) => {
                            Some(Dependency::from_toml_key(k, version))
                        }
                        crate::config::DependencySpec::Detailed(detail) => {
                            detail.version.as_ref().map(|v| Dependency::from_toml_key(k, v))
                        }
                    })
                    .collect();
                
                if !ws_deps.is_empty() {
                    println!("{}", crate::i18n::tf("workspace_dependencies", &[&ws_deps.len().to_string()]));
                    for dep in &ws_deps {
                        println!("{}", crate::i18n::tf("dependency_item", &[&dep.coord()]));
                    }
                } else {
                    println!("{}", crate::i18n::t("no_workspace_dependencies"));
                }
            }
        }
    } else {
        println!("{}", crate::i18n::tf("running_in_project", &[&project_dir.display().to_string()]));
    }
    
    // æ˜¾ç¤ºé¡¹ç›®ç‰¹å®šä¾èµ–
    let project_deps = crate::config::get_dependencies(project);
    if !project_deps.is_empty() {
        println!("{}", crate::i18n::tf("project_dependencies", &[&project_deps.len().to_string()]));
        for dep in &project_deps {
            println!("{}", crate::i18n::tf("dependency_item", &[&dep.coord()]));
        }
    } else {
        println!("{}", crate::i18n::t("no_project_dependencies"));
    }
}

/// æ‰§è¡Œå†…ç½®å‘½ä»¤
pub async fn execute_command(command: Commands, cwd: &PathBuf) -> anyhow::Result<()> {
    match command {
        Commands::New { name } => {
            cmd_new(cwd, &name).await?;
        }
        Commands::Init => {
            cmd_init(cwd).await?;
        }
        Commands::Workspace { subcommand } => {
            cmd_workspace(cwd, &subcommand).await?;
        }
        Commands::Build => {
            execute_build(cwd).await?;
        }
        Commands::Run { file, lib } => {
            execute_run(cwd, file, lib).await?;
        }
        Commands::Add { deps } => {
            execute_add(cwd, &deps).await?;
        }
        Commands::Test { file } => {
            cmd_test(cwd, file).await?;
        }
        Commands::Jsp { .. } => {
            // JSP å‘½ä»¤åº”è¯¥ç”±æ’ä»¶ç³»ç»Ÿå¤„ç†
            unreachable!("JSP command should be handled by plugin system");
        }
    }
    Ok(())
}

/// æ‰§è¡Œé»˜è®¤è¡Œä¸ºï¼ˆæ— å‘½ä»¤æ—¶ï¼‰
pub async fn execute_default(cwd: &PathBuf) -> anyhow::Result<()> {
    if cwd.join("project.toml").exists() {
        let project = crate::config::load_project(cwd)?;
        let target = crate::config::get_main_file_path(&project);
        if cwd.join(&target).exists() {
            let deps = crate::config::get_dependencies(&project);
            let output = run_single_file_with_deps(cwd, &target, &deps).await?;
            println!("{}", output);
        } else {
            println!("{}", crate::i18n::tf("main_file_not_found", &[&target.display().to_string()]));
        }
    } else {
        println!("{}", crate::i18n::t("no_command_provided"));
    }
    Ok(())
}

/// æ£€æŸ¥å½“å‰ç›®å½•æ˜¯å¦æ˜¯å·¥ä½œç©ºé—´æ ¹ç›®å½•
fn is_workspace_root(dir: &PathBuf) -> bool {
    if let Ok(project) = crate::config::load_project(dir) {
        project.workspace.is_some()
    } else {
        false
    }
}

/// æ‰§è¡Œæ„å»ºå‘½ä»¤
async fn execute_build(cwd: &PathBuf) -> anyhow::Result<()> {
    // æ£€æŸ¥å½“å‰ç›®å½•æ˜¯å¦æ˜¯å·¥ä½œç©ºé—´æ ¹ç›®å½•
    if is_workspace_root(cwd) {
        // åœ¨å·¥ä½œç©ºé—´æ ¹ç›®å½•ï¼šç¼–è¯‘å·¥ä½œç©ºé—´é…ç½®ä¸­åˆ—å‡ºçš„æ‰€æœ‰æˆå‘˜
        let (root_project, members) = crate::config::load_workspace(cwd)?.unwrap();
        
        // æ˜¾ç¤ºå·¥ä½œç©ºé—´ä¿¡æ¯
        println!("{}", crate::i18n::tf("running_in_workspace", &[&cwd.display().to_string()]));
        
        // æ˜¾ç¤ºå·¥ä½œç©ºé—´ä¾èµ–
        if let Some(ws_config) = &root_project.workspace {
            let ws_deps: Vec<Dependency> = ws_config.dependencies
                .iter()
                .filter_map(|(k, spec)| match spec {
                    crate::config::DependencySpec::Simple(version) => {
                        Some(Dependency::from_toml_key(k, version))
                    }
                    crate::config::DependencySpec::Detailed(detail) => {
                        detail.version.as_ref().map(|v| Dependency::from_toml_key(k, v))
                    }
                })
                .collect();
            
            if !ws_deps.is_empty() {
                println!("{}", crate::i18n::tf("workspace_dependencies", &[&ws_deps.len().to_string()]));
                for dep in &ws_deps {
                    println!("{}", crate::i18n::tf("dependency_item", &[&dep.coord()]));
                }
            } else {
                println!("{}", crate::i18n::t("no_workspace_dependencies"));
            }
        }
        
        // ç¼–è¯‘æ‰€æœ‰æˆå‘˜é¡¹ç›®
        for member in members {
            let member_dir = cwd.join(&member.package.name);
            let deps = crate::config::get_dependencies_with_workspace(&member, Some(&root_project));

            // æ˜¾ç¤ºæˆå‘˜é¡¹ç›®çš„ä¾èµ–ä¿¡æ¯
            println!("\n{}", crate::i18n::tf("running_in_project", &[&member_dir.display().to_string()]));
            let project_deps = crate::config::get_dependencies(&member);
            if !project_deps.is_empty() {
                println!("{}", crate::i18n::tf("project_dependencies", &[&project_deps.len().to_string()]));
                for dep in &project_deps {
                    println!("{}", crate::i18n::tf("dependency_item", &[&dep.coord()]));
                }
            } else {
                println!("{}", crate::i18n::t("no_project_dependencies"));
            }

            // For workspace builds, use target directory relative to workspace root
            let workspace_target_dir = format!(
                "{}/{}",
                root_project.package.target_dir, member.package.name
            );
            crate::build::build::build_with_deps(
                &member_dir,
                &deps,
                &member.package.source_dir,
                &workspace_target_dir,
                Some(cwd),
            )
            .await?;

            // è®¾ç½®BSPä»¥æ”¯æŒIDE
            setup_bsp(
                &member,
                &member_dir,
                &deps,
                Some(cwd),
            )
            .await?;

            println!("{}", crate::i18n::tf("built_member", &[&member.package.name]));
        }
        println!("\n{}", crate::i18n::t("workspace_build_succeeded"));
    } else if let Some(workspace_root) = crate::config::find_workspace_root(cwd) {
        // åœ¨æˆå‘˜é¡¹ç›®ç›®å½•ï¼šåªç¼–è¯‘å½“å‰é¡¹ç›®
        let project = crate::config::load_project(cwd)?;
        let root_project = crate::config::load_project(&workspace_root)?;
        let deps = crate::config::get_dependencies_with_workspace(&project, Some(&root_project));
        
        // æ˜¾ç¤ºé¡¹ç›®ä¿¡æ¯
        print_workspace_and_dependencies(&project, cwd, Some(&workspace_root), Some(&root_project));
        
        // ä½¿ç”¨å·¥ä½œç©ºé—´çš„ target/é¡¹ç›®å ç›®å½•
        let workspace_target_dir = format!(
            "{}/{}",
            root_project.package.target_dir, project.package.name
        );
        
        crate::build::build::build_with_deps(
            cwd,
            &deps,
            &project.package.source_dir,
            &workspace_target_dir,
            Some(&workspace_root),
        )
        .await?;
        println!("\n{}", crate::i18n::tf("build_succeeded_with_deps", &[&deps.len().to_string()]));
    } else {
        // ç‹¬ç«‹é¡¹ç›®ï¼šç¼–è¯‘å½“å‰é¡¹ç›®
        let project = crate::config::load_project(cwd)?;
        let deps = crate::config::get_dependencies(&project);
        
        // æ˜¾ç¤ºé¡¹ç›®ä¿¡æ¯
        print_workspace_and_dependencies(&project, cwd, None, None);
        
        crate::build::build::build_with_deps(
            cwd,
            &deps,
            &project.package.source_dir,
            &project.package.target_dir,
            None,
        )
        .await?;
        println!("\n{}", crate::i18n::tf("build_succeeded_with_deps", &[&deps.len().to_string()]));
    }
    Ok(())
}

/// æ‰§è¡Œè¿è¡Œå‘½ä»¤
async fn execute_run(cwd: &PathBuf, file: Option<PathBuf>, lib: bool) -> anyhow::Result<()> {
    let workspace_root = crate::config::find_workspace_root(cwd);
    let workspace_root_ref = workspace_root.as_ref();

    // æ£€æŸ¥æ˜¯å¦åœ¨å·¥ä½œç©ºé—´æ ¹ç›®å½•è¿è¡Œ
    if let Some(ws_root) = workspace_root_ref {
        if cwd == ws_root {
            // åœ¨å·¥ä½œç©ºé—´æ ¹ç›®å½•ï¼šä¸ºæ‰€æœ‰æˆå‘˜è®¾ç½®BSP
            let (root_project, members) = crate::config::load_workspace(ws_root)?.unwrap();

            println!("{}", crate::i18n::tf("running_in_workspace", &[&ws_root.display().to_string()]));

            for member in members {
                let member_dir = ws_root.join(&member.package.name);
                let deps = crate::config::get_dependencies_with_workspace(&member, Some(&root_project));

                // æ˜¾ç¤ºæˆå‘˜é¡¹ç›®ä¿¡æ¯
                println!("\n{}", crate::i18n::tf("running_in_project", &[&member_dir.display().to_string()]));

                // è®¾ç½®BSPä»¥æ”¯æŒIDE
                setup_bsp(
                    &member,
                    &member_dir,
                    &deps,
                    Some(ws_root),
                )
                .await?;
            }

            println!("\n{}", crate::i18n::t("bsp_setup_completed"));
            return Ok(());
        }
    }

    // ç¡®å®šé¡¹ç›®é…ç½®å’Œç›®å½•
    let (project, project_dir) = if let Some(ws_root) = workspace_root_ref {
        // åœ¨ workspace ä¸­ï¼ŒæŸ¥æ‰¾æˆå‘˜é¡¹ç›®
        if let Some((_ws_proj, members)) = crate::config::load_workspace(ws_root)? {
            let member_name = cwd
                .strip_prefix(ws_root)
                .unwrap()
                .components()
                .next()
                .unwrap()
                .as_os_str()
                .to_str()
                .unwrap();
            if let Some(member) = members
                .into_iter()
                .find(|m| m.package.name == member_name)
            {
                (member, ws_root.clone().join(member_name))
            } else {
                // ä¸æ˜¯æˆå‘˜ï¼Œä½œä¸ºå•ä¸ªé¡¹ç›®å¤„ç†
                let proj = crate::config::load_project(cwd)?;
                (proj, cwd.clone())
            }
        } else {
            // å®é™…ä¸Šä¸æ˜¯ workspaceï¼Œä½œä¸ºå•ä¸ªé¡¹ç›®å¤„ç†
            let proj = crate::config::load_project(cwd)?;
            (proj, cwd.clone())
        }
    } else {
        let proj = crate::config::load_project(cwd)?;
        (proj, cwd.clone())
    };

    // è·å–ä¾èµ–
    let (deps, ws_proj) = if let Some(ws_root) = workspace_root_ref {
        let ws_proj = crate::config::load_project(ws_root)?;
        let deps = crate::config::get_dependencies_with_workspace(&project, Some(&ws_proj));
        (deps, Some(ws_proj))
    } else {
        let deps = crate::config::get_dependencies(&project);
        (deps, None)
    };

    // æ˜¾ç¤ºå·¥ä½œç©ºé—´å’Œä¾èµ–ä¿¡æ¯
    print_workspace_and_dependencies(&project, &project_dir, workspace_root_ref, ws_proj.as_ref());
    println!();

    // è®¾ç½® BSP ä»¥æ”¯æŒ IDE
    setup_bsp(
        &project,
        &project_dir,
        &deps,
        workspace_root_ref.map(|p| p.as_path()),
    )
    .await?;

    let target = file.unwrap_or_else(|| crate::config::get_main_file_path(&project));

    if !project_dir.join(&target).exists() {
        anyhow::bail!("File not found: {}", target.display());
    }

    if lib {
        let _ = run_scala_file(&project_dir, &target, true).await?;
        println!("{}", crate::i18n::tf("lib_compiled_only", &[&target.display().to_string()]));
    } else {
        let output = run_single_file_with_deps(&project_dir, &target, &deps).await?;
        println!("{}", output);
    }

    Ok(())
}

/// æ‰§è¡Œæ·»åŠ ä¾èµ–å‘½ä»¤
async fn execute_add(cwd: &PathBuf, deps: &[String]) -> anyhow::Result<()> {
    // ç›´æ¥åœ¨å½“å‰ç›®å½•æ·»åŠ ä¾èµ–ï¼Œadd_dependency ä¼šæ£€æµ‹æ˜¯å¦åœ¨å·¥ä½œç©ºé—´æ ¹ç›®å½•
    for dep in deps {
        add_dependency(cwd, dep).await?;
    }
    Ok(())
}




/// FILE: crates/sinter-core/src/cmd/init.rs

use std::path::PathBuf;

pub async fn cmd_init(cwd: &PathBuf) -> anyhow::Result<()> {
    // Check if project.toml already exists
    let manifest_path = cwd.join("project.toml");
    if manifest_path.exists() {
        anyhow::bail!("{}", crate::i18n::t("config_file_already_exists"));
    }

    // Create workspace project.toml
    let manifest = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/workspace.project.toml.template"));
    tokio::fs::write(manifest_path, manifest).await?;

    println!("{}", crate::i18n::tf("initialized_empty_workspace", &[&cwd.display().to_string()]));
    Ok(())
}


/// FILE: crates/sinter-core/src/cmd/mod.rs

pub mod new;
pub mod init;
pub mod test;
pub mod workspace;
pub mod builtin;

// å¯¼å‡ºå‘½ä»¤å‡½æ•°
pub use init::cmd_init;
pub use test::cmd_test;
pub use workspace::cmd_workspace;
pub use new::cmd_new;

// å‘½ä»¤æšä¸¾å®šä¹‰
#[derive(Debug)]
pub enum Commands {
    New {
        name: String
    },
    Init,
    Build,
    Run {
        file: Option<std::path::PathBuf>,
        lib: bool,
    },
    Add {
        deps: Vec<String>,
    },
    Test {
        file: Option<std::path::PathBuf>,
    },
    Workspace {
        subcommand: WorkspaceCommands,
    },
    Jsp {
        name: String,
    },
}

#[derive(Debug)]
pub enum WorkspaceCommands {
    Add {
        paths: Vec<String>,
    },
}


/// FILE: crates/sinter-core/src/cmd/new.rs

use std::path::PathBuf;

pub async fn cmd_new(cwd: &PathBuf, name: &str) -> anyhow::Result<()> {
    let proj_dir = cwd.join(name);
    if proj_dir.exists() {
        println!("{}", crate::i18n::tf("project_already_exists", &[name]));
        return Ok(());
    }
    tokio::fs::create_dir_all(proj_dir.join("src/main/scala")).await?;

    // project.toml
    let template = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/project.toml.template"));
    let manifest = template.replace("{name}", name);
    tokio::fs::write(proj_dir.join("project.toml"), manifest).await?;

    // Hello world
    let code = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/main.scala.template"));
    tokio::fs::write(
        proj_dir.join("src/main/scala/Main.scala"),
        code,
    )
    .await?;

    // Auto-add to workspace if in one
    if let Some(workspace_root) = crate::config::find_workspace_root(cwd) {
        let manifest_path = workspace_root.join("project.toml");
        let relative_path = proj_dir.strip_prefix(&workspace_root)
            .unwrap_or(&proj_dir)
            .to_string_lossy()
            .to_string();
        match crate::config::add_workspace_member(&manifest_path, &relative_path) {
            Ok(_) => {
                println!("{}", crate::i18n::tf("added_project_to_workspace", &[name]));
            }
            Err(e) => {
                if !e.to_string().contains("already exists") {
                    eprintln!("Warning: Failed to add project to workspace: {}", e);
                }
            }
        }
    }

    println!("{}", crate::i18n::tf("created_project", &[name]));
    Ok(())
}



/// FILE: crates/sinter-core/src/cmd/test.rs

use std::path::PathBuf;
use tokio::process::Command;

pub async fn cmd_test(cwd: &PathBuf, file: Option<PathBuf>) -> anyhow::Result<()> {
    let workspace_root = crate::config::find_workspace_root(cwd);
    let (project, project_dir) = if let Some(ws_root) = workspace_root.as_ref() {
        // In workspace, check if this is a member project
        if let Some((_ws_proj, members)) = crate::config::load_workspace(ws_root)? {
            let relative_path = cwd.strip_prefix(ws_root).unwrap();
            if let Some(first_component) = relative_path.components().next() {
                let member_name = first_component.as_os_str().to_str().unwrap();
                if let Some(member) = members.into_iter().find(|m| m.package.name == member_name) {
                    (member, ws_root.clone().join(member_name))
                } else {
                    // Not a workspace member, treat as standalone project
                    let proj = crate::config::load_project(cwd)?;
                    (proj, cwd.clone())
                }
            } else {
                // cwd == ws_root, treat as standalone project
                let proj = crate::config::load_project(cwd)?;
                (proj, cwd.clone())
            }
        } else {
            // No workspace config, treat as standalone project
            let proj = crate::config::load_project(cwd)?;
            (proj, cwd.clone())
        }
    } else {
        let proj = crate::config::load_project(cwd)?;
        (proj, cwd.clone())
    };

    let deps = if let Some(ws_root) = workspace_root {
        let ws_proj = crate::config::load_project(&ws_root)?;
        crate::config::get_dependencies_with_workspace(&project, Some(&ws_proj))
    } else {
        crate::config::get_dependencies(&project)
    };

    let test_target = if let Some(f) = file {
        f
    } else {
        PathBuf::from(&project.package.test_dir)
    };

    let abs_test_target = project_dir.join(&test_target);

    if !abs_test_target.exists() {
        println!("No tests found in {}", test_target.display());
        return Ok(());
    }

    // Use scala-cli test
    let mut cmd = Command::new("scala-cli");
    cmd.arg("test").arg(&abs_test_target);
    cmd.current_dir(&project_dir);

    for dep in deps {
        cmd.arg("--dependency").arg(dep.coord());
    }

    let output = cmd.output().await?;
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);

    if !stdout.is_empty() {
        println!("{}", stdout);
    }
    if !stderr.is_empty() {
        eprintln!("{}", stderr);
    }

    if !output.status.success() {
        anyhow::bail!("Test failed");
    }

    Ok(())
}


/// FILE: crates/sinter-core/src/cmd/workspace.rs

use std::path::PathBuf;

use crate::WorkspaceCommands;

pub async fn cmd_workspace(cwd: &PathBuf, subcommand: &WorkspaceCommands) -> anyhow::Result<()> {
    match subcommand {
        WorkspaceCommands::Add { paths } => {
            cmd_workspace_add(cwd, paths).await?;
        }
    }
    Ok(())
}

async fn cmd_workspace_add(cwd: &PathBuf, member_paths: &[String]) -> anyhow::Result<()> {
    // Find workspace root
    let workspace_root = crate::config::find_workspace_root(cwd)
        .ok_or_else(|| anyhow::anyhow!("{}", crate::i18n::t("not_in_workspace")))?;

    let manifest_path = workspace_root.join("project.toml");

    for member_path in member_paths {
        // Check if member already exists by trying to add it
        match crate::config::add_workspace_member(&manifest_path, member_path) {
            Ok(_) => {
                println!("{}", crate::i18n::tf("added_member_to_workspace", &[member_path]));
            }
            Err(_) => {
                println!("{}", crate::i18n::tf("member_already_exists", &[member_path]));
            }
        }
    }
    Ok(())
}


/// FILE: crates/sinter-core/src/commands.rs

/// æè‡´ç®€åŒ–çš„å‘½ä»¤å®šä¹‰å®
#[macro_export]
macro_rules! plugin_command {
    ($name:ident, $about:expr, $body:block) => {
        pub struct $name;

        #[async_trait::async_trait]
        impl crate::core::CommandHandler for $name {
            fn name(&self) -> &'static str {
                stringify!($name).to_lowercase().trim_end_matches("command")
            }

            fn about(&self) -> &'static str {
                $about
            }

            async fn execute(&self, matches: &clap::ArgMatches, cwd: &std::path::PathBuf) -> anyhow::Result<()> {
                $body
            }
        }

            inventory::submit! {
            Box::new($name) as Box<dyn crate::core::CommandHandler>
        }
    };
}

/// è¶…çº§ç®€å•çš„æ’ä»¶å®šä¹‰å® - æ— éœ€äº†è§£å†…éƒ¨ç»†èŠ‚
#[macro_export]
macro_rules! simple_plugin {
    ($cmd_name:literal, $description:literal, $config:expr, $handler:expr) => {
        paste::paste! {
            pub struct [<Simple $cmd_name:camel Plugin>];

            #[async_trait::async_trait]
            impl crate::core::CommandHandler for [<Simple $cmd_name:camel Plugin>] {
                fn name(&self) -> &'static str {
                    $cmd_name
                }

                fn about(&self) -> &'static str {
                    $description
                }

                fn configure(&self, cmd: clap::Command) -> clap::Command {
                    let config_fn = $config;
                    config_fn(cmd.about(self.about()))
                }

                async fn execute(&self, matches: &clap::ArgMatches, cwd: &std::path::PathBuf) -> anyhow::Result<()> {
                    let handler = $handler;
                    handler(matches.clone(), cwd.clone()).await
                }
            }

            // å¯¼å‡ºæ’ä»¶ç»“æ„ä½“ä¾›æ³¨å†Œä½¿ç”¨
            pub use [<Simple $cmd_name:camel Plugin>] as [<plugin_ $cmd_name>];
        }
    };
}


/// FILE: crates/sinter-core/src/config.rs

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};

use anyhow::Context;
use config::Config;
use toml_edit::{value, DocumentMut, Item, Table};

use crate::deps::deps::Dependency;

#[derive(Deserialize, Serialize, Debug)]
pub struct Project {
    pub package: Package,
    #[serde(default)]
    pub dependencies: HashMap<String, DependencySpec>,
    #[serde(default)]
    pub workspace: Option<Workspace>,
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(untagged)]
pub enum DependencySpec {
    Simple(String),
    Detailed(DependencyDetail),
}

#[derive(Deserialize, Serialize, Debug)]
pub struct DependencyDetail {
    pub version: Option<String>,
    #[serde(default)]
    pub workspace: bool,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Workspace {
    pub members: Vec<String>,
    #[serde(default)]
    pub dependencies: HashMap<String, DependencySpec>,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Package {
    pub name: String,
    pub version: String,
    pub main: Option<String>,
    #[serde(default = "default_scala_version")]
    pub scala_version: String,
    #[serde(default = "default_source_dir")]
    pub source_dir: String,
    #[serde(default = "default_target_dir")]
    pub target_dir: String,
    #[serde(default = "default_test_dir")]
    pub test_dir: String,
    #[serde(default = "default_backend")]
    pub backend: String,
}

fn default_scala_version() -> String {
    "2.13".to_string()
}

fn default_source_dir() -> String {
    "src/main/scala".to_string()
}

fn default_target_dir() -> String {
    "target".to_string()
}

fn default_test_dir() -> String {
    "src/test/scala".to_string()
}

fn default_backend() -> String {
    "scala-cli".to_string()
}

pub fn load_project(dir: &Path) -> anyhow::Result<Project> {
    let manifest_path = dir.join("project.toml");
    let settings = Config::builder()
        .add_source(config::File::from(manifest_path))
        .build()?;
    let proj: Project = settings.try_deserialize()?;
    Ok(proj)
}

pub fn load_project_async(dir: &Path) -> anyhow::Result<Project> {
    // For async operations if needed
    load_project(dir)
}

pub fn get_dependencies(project: &Project) -> Vec<Dependency> {
    project.dependencies
        .iter()
        .filter_map(|(k, spec)| match spec {
            crate::config::DependencySpec::Simple(version) => {
                Some(Dependency::from_toml_key(k, &version))
            }
            crate::config::DependencySpec::Detailed(detail) => {
                detail.version.as_ref().map(|v| Dependency::from_toml_key(k, v))
            }
        })
        .collect()
}

pub fn get_dependencies_with_workspace(project: &Project, workspace_root: Option<&Project>) -> Vec<Dependency> {
    let mut deps = Vec::new();

    // åªæ·»åŠ é¡¹ç›®ä¸­æ˜¾å¼å£°æ˜çš„ä¾èµ–
    for (k, spec) in &project.dependencies {
        match spec {
            crate::config::DependencySpec::Simple(version) => {
                // ç®€å•æ ¼å¼çš„ä¾èµ–ç›´æ¥ä½¿ç”¨é¡¹ç›®ä¸­æŒ‡å®šçš„ç‰ˆæœ¬
                deps.push(Dependency::from_toml_key(k, &version));
            }
            crate::config::DependencySpec::Detailed(detail) => {
                if detail.workspace {
                    // workspaceä¾èµ–ï¼Œä»workspaceæ ¹è·å–ç‰ˆæœ¬
                    if let Some(ws) = workspace_root {
                        if let Some(ws_config) = &ws.workspace {
                            if let Some(ws_spec) = ws_config.dependencies.get(k) {
                                match ws_spec {
                                    crate::config::DependencySpec::Simple(version) => {
                                        deps.push(Dependency::from_toml_key(k, &version));
                                    }
                                    crate::config::DependencySpec::Detailed(ws_detail) => {
                                        if let Some(version) = &ws_detail.version {
                                            deps.push(Dependency::from_toml_key(k, version));
                                        }
                                    }
                                }
                            } else {
                                // workspaceä¸­æ²¡æœ‰å®šä¹‰æ­¤ä¾èµ–ï¼Œè·³è¿‡
                                eprintln!("Warning: dependency '{}' marked as workspace but not found in workspace root", k);
                            }
                        }
                    }
                } else if let Some(version) = &detail.version {
                    // éworkspaceä¾èµ–ï¼Œä½¿ç”¨é¡¹ç›®ä¸­æŒ‡å®šçš„ç‰ˆæœ¬
                    deps.push(Dependency::from_toml_key(k, version));
                }
            }
        }
    }

    deps
}

pub async fn get_transitive_dependencies_with_workspace(project: &Project, workspace_root: Option<&Project>) -> anyhow::Result<Vec<Dependency>> {
    let direct_deps = get_dependencies_with_workspace(project, workspace_root);
    let dep_manager = crate::deps::default_dependency_manager().await;
    dep_manager.get_transitive_dependencies(&direct_deps).await
}

pub async fn generate_ide_classpath(project: &Project, workspace_root: Option<&Project>, project_dir: &Path) -> anyhow::Result<()> {
    let transitive_deps = get_transitive_dependencies_with_workspace(project, workspace_root).await?;

    let dep_manager = crate::deps::default_dependency_manager().await;
    let target_dir = project_dir.join(&project.package.target_dir);
    dep_manager.prepare_dependencies(&transitive_deps, &target_dir).await?;

    // è·å–ä¾èµ–JARæ–‡ä»¶çš„è·¯å¾„
    let mut classpath_entries = String::new();
    for dep in &transitive_deps {
        if let Dependency::Maven { group, artifact, version } = dep {
            // coursieré€šå¸¸å°†JARæ–‡ä»¶å­˜å‚¨åœ¨~/.coursier/cache/v1/https/repo1.maven.org/maven2/...
            // æˆ‘ä»¬éœ€è¦æ‰¾åˆ°å®é™…çš„JARæ–‡ä»¶è·¯å¾„
            if let Some(jar_path) = find_jar_path(group, artifact, version) {
                classpath_entries.push_str(&format!("\t<classpathentry kind=\"lib\" path=\"{}\"/>\n", jar_path.display()));
            }
        }
    }

    // è¯»å–æ¨¡æ¿
    let template_path = Path::new("templates/.classpath.template");
    let template_content = std::fs::read_to_string(template_path)?;

    // æ›¿æ¢æ¨¡æ¿å˜é‡
    let classpath_content = template_content
        .replace("{source_dir}", &project.package.source_dir)
        .replace("{target_dir}", &project.package.target_dir)
        .replace("{classpath_entries}", &classpath_entries);

    // å†™å…¥.classpathæ–‡ä»¶
    let classpath_path = project_dir.join(".classpath");
    std::fs::write(classpath_path, classpath_content)?;

    Ok(())
}

fn find_jar_path(group: &str, artifact: &str, version: &str) -> Option<PathBuf> {
    // å°è¯•å¸¸è§çš„coursierç¼“å­˜ä½ç½®
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    let cache_base = PathBuf::from(home).join(".coursier").join("cache").join("v1");

    // Maven Centralè·¯å¾„
    let maven_path = cache_base
        .join("https")
        .join("repo1.maven.org")
        .join("maven2")
        .join(group.replace(".", "/"))
        .join(artifact)
        .join(version)
        .join(format!("{}-{}.jar", artifact, version));

    if maven_path.exists() {
        Some(maven_path)
    } else {
        // å°è¯•å…¶ä»–ä»“åº“æˆ–è¿”å›None
        None
    }
}

pub fn get_main_file_path(project: &Project) -> std::path::PathBuf {
    let main_class = project.package.main.as_deref().unwrap_or("Main");
    std::path::PathBuf::from(&project.package.source_dir).join(format!("{}.scala", main_class))
}

pub fn find_workspace_root(start_dir: &Path) -> Option<std::path::PathBuf> {
    let mut current = start_dir;
    loop {
        let manifest = current.join("project.toml");
        if manifest.exists() {
            if let Ok(settings) = Config::builder()
                .add_source(config::File::from(manifest.clone()))
                .build()
            {
                if let Ok(project) = settings.try_deserialize::<Project>() {
                    if project.workspace.is_some() {
                        return Some(current.to_path_buf());
                    }
                }
            }
        }
        if let Some(parent) = current.parent() {
            current = parent;
        } else {
            break;
        }
    }
    None
}

pub fn load_workspace(dir: &Path) -> anyhow::Result<Option<(Project, Vec<Project>)>> {
    let manifest_path = dir.join("project.toml");
    if !manifest_path.exists() {
        return Ok(None);
    }
    let settings = Config::builder()
        .add_source(config::File::from(manifest_path))
        .build()?;
    let root_project: Project = settings.try_deserialize()?;
    if let Some(workspace) = &root_project.workspace {
        let mut members = Vec::new();
        for member_path in &workspace.members {
            let member_dir = dir.join(member_path);
            let member_project = load_project(&member_dir)?;
            members.push(member_project);
        }
        Ok(Some((root_project, members)))
    } else {
        Ok(None)
    }
}


pub fn add_dependency_to_manifest(manifest_path: &Path, key: &str, version: &str) -> anyhow::Result<()> {
    let content = std::fs::read_to_string(manifest_path)?;

    // æ­¥éª¤ 1ï¼šè§£æä¸º Document<String>
    let mut doc: DocumentMut = content
        .parse()
        .context("Failed to parse project.toml as TOML document")?;

    // ç¡®ä¿ dependencies è¡¨å­˜åœ¨
    let deps_key = "dependencies";
    if !doc.contains_key(deps_key) {
        doc.insert(deps_key, Item::Table(Table::new()));
    }

    let deps_item = doc.get_mut(deps_key).unwrap();
    if let Some(deps_table) = deps_item.as_table_mut() {
        deps_table[key] = value(version.to_string());

        // ç¾åŒ–æ ¼å¼
        let decor = deps_table.decor_mut();
        decor.set_prefix("\n");
        decor.set_suffix("\n");
    }

    std::fs::write(manifest_path, doc.to_string())?;
    Ok(())
}

pub fn add_workspace_dependency_to_manifest(manifest_path: &Path, key: &str, version: &str) -> anyhow::Result<()> {
    let content = std::fs::read_to_string(manifest_path)?;

    // æ­¥éª¤ 1ï¼šè§£æä¸º Document<String>
    let mut doc: DocumentMut = content
        .parse()
        .context("Failed to parse project.toml as TOML document")?;

    // ç¡®ä¿ workspace è¡¨å­˜åœ¨
    let ws_key = "workspace";
    if !doc.contains_key(ws_key) {
        doc.insert(ws_key, Item::Table(Table::new()));
    }

    let ws_item = doc.get_mut(ws_key).unwrap();
    if let Some(ws_table) = ws_item.as_table_mut() {
        // ç¡®ä¿ workspace.dependencies è¡¨å­˜åœ¨
        let deps_key = "dependencies";
        if !ws_table.contains_key(deps_key) {
            ws_table.insert(deps_key, Item::Table(Table::new()));
        }

        if let Some(deps_item) = ws_table.get_mut(deps_key) {
            if let Some(deps_table) = deps_item.as_table_mut() {
                deps_table[key] = value(version.to_string());

                // ç¾åŒ–æ ¼å¼
                let decor = deps_table.decor_mut();
                decor.set_prefix("\n");
                decor.set_suffix("\n");
            }
        }
    }

    std::fs::write(manifest_path, doc.to_string())?;
    Ok(())
}

pub fn add_workspace_member(manifest_path: &Path, member_path: &str) -> anyhow::Result<()> {
    let content = std::fs::read_to_string(manifest_path)?;
    let mut doc: DocumentMut = content.parse().context("Failed to parse project.toml")?;

    // Ensure workspace table exists
    let ws_key = "workspace";
    if !doc.contains_key(ws_key) {
        doc.insert(ws_key, Item::Table(Table::new()));
    }

    let ws_item = doc.get_mut(ws_key).unwrap();
    if let Some(ws_table) = ws_item.as_table_mut() {
        // Ensure members array exists
        if !ws_table.contains_key("members") {
            ws_table.insert("members", Item::Value(toml_edit::Value::Array(Default::default())));
        }

        if let Some(members_item) = ws_table.get_mut("members") {
            if let Some(members_array) = members_item.as_array_mut() {
                // Check if member already exists
                let exists = members_array.iter().any(|v| v.as_str() == Some(member_path));
                if exists {
                    anyhow::bail!("Member '{}' already exists in workspace", member_path);
                }
                members_array.push(member_path);
                std::fs::write(manifest_path, doc.to_string())?;
            }
        }
    }

    Ok(())
}


/// FILE: crates/sinter-core/src/core/app.rs

//! Sinter åº”ç”¨æ„å»ºå™¨
//!
//! ä½¿ç”¨å‡½æ•°å¼ Builder æ¨¡å¼æ„å»ºåº”ç”¨ï¼Œæ”¯æŒé“¾å¼æ³¨å†Œæ’ä»¶

use crate::core::handler::CommandHandler;
use crate::cli::Cli;
use crate::runtime::Executor;

/// Sinter åº”ç”¨æ„å»ºå™¨
///
/// ä½¿ç”¨ Builder æ¨¡å¼ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨æ³¨å†Œæ’ä»¶ï¼š
///
/// ```rust
/// Sinter::new()
///     .plugin(my_plugin())
///     .plugin(another_plugin())
///     .run()
///     .await?;
/// ```
pub struct Sinter {
    plugins: Vec<Box<dyn CommandHandler>>,
}

impl Sinter {
    /// åˆ›å»ºæ–°çš„ Sinter åº”ç”¨
    pub fn new() -> Self {
        Self {
            plugins: Vec::new(),
        }
    }

    /// æ³¨å†Œå•ä¸ªæ’ä»¶
    ///
    /// æ”¯æŒé“¾å¼è°ƒç”¨
    pub fn plugin<H: CommandHandler + 'static>(mut self, handler: H) -> Self {
        self.plugins.push(Box::new(handler));
        self
    }

    /// æ‰¹é‡æ³¨å†Œæ’ä»¶
    ///
    /// å¯ä»¥ä¼ å…¥ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä¸€æ¬¡æ€§æ³¨å†Œå¤šä¸ªæ’ä»¶
    pub fn plugins<H: CommandHandler + 'static, I: IntoIterator<Item = H>>(
        mut self,
        handlers: I,
    ) -> Self {
        for handler in handlers {
            self.plugins.push(Box::new(handler));
        }
        self
    }

    /// è¿è¡Œåº”ç”¨
    ///
    /// è§£æå‘½ä»¤è¡Œå‚æ•°ï¼Œæ‰§è¡Œå¯¹åº”çš„å‘½ä»¤
    pub async fn run(self) -> anyhow::Result<()> {
        let cli = Cli::parse_with_plugins(&self.plugins);
        let cwd = std::env::current_dir()?;
        Executor::new(self.plugins).execute(cli, cwd).await
    }
}

impl Default for Sinter {
    fn default() -> Self {
        Self::new()
    }
}




/// FILE: crates/sinter-core/src/core/handler.rs

//! å‘½ä»¤å¤„ç†å™¨ trait
//!
//! æ‰€æœ‰å‘½ä»¤ï¼ˆåŒ…æ‹¬å†…ç½®å‘½ä»¤å’Œæ’ä»¶ï¼‰éƒ½éœ€è¦å®ç°è¿™ä¸ª trait

use async_trait::async_trait;
use clap::{ArgMatches, Command};
use std::path::PathBuf;

/// å‘½ä»¤å¤„ç†å™¨ trait
///
/// å®ç°è¿™ä¸ª trait å°±å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„å‘½ä»¤ã€‚
/// æ— è®ºæ˜¯å†…ç½®å‘½ä»¤è¿˜æ˜¯æ’ä»¶ï¼Œéƒ½ä½¿ç”¨ç›¸åŒçš„æ¥å£ã€‚
#[async_trait]
pub trait CommandHandler: Send + Sync {
    /// è¿”å›å‘½ä»¤åç§°
    ///
    /// ä¾‹å¦‚ï¼š`"new"`, `"build"`, `"jsp"` ç­‰
    fn name(&self) -> &'static str;

    /// è¿”å›å‘½ä»¤æè¿°
    ///
    /// è¿™ä¸ªæè¿°ä¼šæ˜¾ç¤ºåœ¨å¸®åŠ©ä¿¡æ¯ä¸­
    fn about(&self) -> &'static str;

    /// é…ç½®å‘½ä»¤å‚æ•°
    ///
    /// é»˜è®¤å®ç°ä¼šè®¾ç½®å‘½ä»¤åç§°å’Œæè¿°ã€‚
    /// å¦‚æœéœ€è¦æ·»åŠ å‚æ•°ï¼Œå¯ä»¥é‡å†™è¿™ä¸ªæ–¹æ³•ã€‚
    fn configure(&self, cmd: Command) -> Command {
        cmd.name(self.name()).about(self.about())
    }

    /// æ‰§è¡Œå‘½ä»¤é€»è¾‘
    ///
    /// è¿™æ˜¯å‘½ä»¤çš„æ ¸å¿ƒé€»è¾‘ï¼Œå½“ç”¨æˆ·è¿è¡Œå‘½ä»¤æ—¶ä¼šè¢«è°ƒç”¨ã€‚
    async fn execute(&self, matches: &ArgMatches, cwd: &PathBuf) -> anyhow::Result<()>;
}




/// FILE: crates/sinter-core/src/core/mod.rs

//! æ ¸å¿ƒæ¨¡å—
//!
//! åŒ…å«æ’ä»¶ç³»ç»Ÿçš„æ ¸å¿ƒ trait å’Œåº”ç”¨ç»“æ„

pub mod handler;
pub mod app;

pub use handler::CommandHandler;
pub use app::Sinter;




/// FILE: crates/sinter-core/src/deps/add.rs

use std::path::Path;

pub async fn add_dependency(project_dir: &Path, dep_spec: &str) -> anyhow::Result<()> {
    let project = crate::config::load_project(project_dir)?;
    let manifest_path = project_dir.join("project.toml");

    // æ£€æµ‹æ˜¯å¦åœ¨å·¥ä½œç©ºé—´æ ¹ç›®å½•
    let is_workspace_root = project.workspace.is_some();

    // Check if it's an sbt path
    if dep_spec.starts_with("sbt:") || (dep_spec.contains("/") && !dep_spec.contains("::")) {
        let sbt_path = if dep_spec.starts_with("sbt:") {
            dep_spec[4..].to_string()
        } else {
            dep_spec.to_string()
        };

        // Validate that the sbt project exists
        let sbt_project_path = project_dir.join(&sbt_path);
        if !sbt_project_path.exists() {
            anyhow::bail!("sbt project path does not exist: {}", sbt_path);
        }

        let key = format!("sbt:{}", sbt_path);
        // å¦‚æœåœ¨å·¥ä½œç©ºé—´æ ¹ç›®å½•ï¼Œæ·»åŠ åˆ° workspace.dependencies
        if is_workspace_root {
            crate::config::add_workspace_dependency_to_manifest(&manifest_path, &key, "")?;
            println!("{}", crate::i18n::tf("added_dependency", &[&key, "sbt project (workspace)"]));
        } else {
            crate::config::add_dependency_to_manifest(&manifest_path, &key, "")?;
            println!("{}", crate::i18n::tf("added_dependency", &[&key, "sbt project"]));
        }
        return Ok(());
    }

    let (artifact, scala_ver, version) = parse_dep_spec(dep_spec, &project.package.scala_version).await?;

    let key = artifact.clone();

    let full_key = if !scala_ver.is_empty() && scala_ver != "latest" {
        format!("{}_{}", key, scala_ver)
    } else {
        key
    };

    // ä½¿ç”¨ä¾èµ–ç®¡ç†å™¨éªŒè¯ä¾èµ–æ˜¯å¦å¯ç”¨
    let dep_manager = crate::deps::default_dependency_manager().await;
    let dep = crate::deps::deps::Dependency::from_toml_key(&full_key, &version);
    
    // éªŒè¯ä¾èµ–æ˜¯å¦å¯ç”¨
    if let Err(e) = dep_manager.validate_dependency(&dep).await {
        anyhow::bail!("Failed to validate dependency {}: {}\nPlease check that the dependency coordinates are correct and the version exists.", full_key, e);
    }

    // å¦‚æœéªŒè¯é€šè¿‡ï¼Œä¸‹è½½ä¾èµ–ï¼ˆä½¿ç”¨coursieræ—¶ä¼šé¢„å…ˆä¸‹è½½å¹¶ç¼“å­˜ï¼‰
    if let Err(e) = dep_manager.prepare_dependencies(&[dep.clone()], &project_dir.join("target")).await {
        anyhow::bail!("Failed to download dependency {}: {}\nPlease check your network connection and try again.", full_key, e);
    }

    // å¦‚æœåœ¨å·¥ä½œç©ºé—´æ ¹ç›®å½•ï¼Œæ·»åŠ åˆ° workspace.dependencies
    if is_workspace_root {
        crate::config::add_workspace_dependency_to_manifest(&manifest_path, &full_key, &version)?;
        println!("{}", crate::i18n::tf("added_dependency", &[&full_key, &format!("{} (workspace)", version)]));
    } else {
        crate::config::add_dependency_to_manifest(&manifest_path, &full_key, &version)?;
        println!("{}", crate::i18n::tf("added_dependency", &[&full_key, &version]));
    }
    Ok(())
}


async fn parse_dep_spec(spec: &str, default_scala_version: &str) -> anyhow::Result<(String, String, String)> {
    let parts: Vec<&str> = spec.split("::").collect();

    // è¦æ±‚å®Œæ•´æ ¼å¼ï¼šgroup::artifact:version
    if parts.len() != 2 {
        anyhow::bail!("{}", crate::i18n::t("invalid_dependency_format"));
    }

    let group = parts[0];
    let artifact_version = parts[1];

    let av_parts: Vec<&str> = artifact_version.split(':').collect();
    if av_parts.len() != 2 {
        anyhow::bail!("{}", crate::i18n::t("invalid_dependency_format"));
    }

    let artifact_with_scala = av_parts[0];
    let version = av_parts[1];

    // æ£€æŸ¥artifactæ˜¯å¦åŒ…å«::ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æŠ¥é”™ï¼Œå› ä¸ºartifactä¸åº”è¯¥æœ‰::
    if artifact_with_scala.contains("::") {
        anyhow::bail!("{}", crate::i18n::t("invalid_artifact_format"));
    }

    let artifact_parts: Vec<&str> = artifact_with_scala.split('@').collect();
    let (artifact, scala_ver) = if artifact_parts.len() == 2 {
        (artifact_parts[0].to_string(), artifact_parts[1])
    } else {
        (artifact_with_scala.to_string(), default_scala_version)
    };

    let full_artifact = format!("{}::{}", group, artifact);

    if version.is_empty() || version == "latest" {
        anyhow::bail!("{}", crate::i18n::t("version_must_be_specified"));
    }

    Ok((full_artifact, scala_ver.to_string(), version.to_string()))
}



/// FILE: crates/sinter-core/src/deps/deps.rs

// src/deps.rs
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone)]
pub enum Dependency {
    Maven {
        group: String,
        artifact: String,
        version: String,
    },
    Sbt {
        path: String,
    },
}

impl Dependency {
    pub fn from_toml_key(key: &str, version: &str) -> Self {
        // Check if it's an sbt path (starts with sbt: or is a relative path)
        if key.starts_with("sbt:") || (key.contains("/") && !key.contains("::")) {
            let path = if key.starts_with("sbt:") {
                key[4..].to_string()
            } else {
                key.to_string()
            };
            Self::Sbt { path }
        } else {
            let parts: Vec<&str> = key.split("::").collect();
            let (group, artifact) = if parts.len() == 2 {
                (parts[0].to_string(), parts[1].to_string())
            } else {
                ("".to_string(), key.to_string())
            };
            Self::Maven {
                group,
                artifact,
                version: version.to_string(),
            }
        }
    }

    // ç”Ÿæˆ Maven åæ ‡ï¼šgroup:artifact:version æˆ– sbt è·¯å¾„
    pub fn coord(&self) -> String {
        match self {
            Dependency::Maven { group, artifact, version } => {
                format!("{}:{}:{}", group, artifact, version)
            }
            Dependency::Sbt { path } => {
                format!("sbt:{}", path)
            }
        }
    }

    pub fn is_sbt(&self) -> bool {
        matches!(self, Dependency::Sbt { .. })
    }

    pub fn sbt_path(&self) -> Option<&str> {
        match self {
            Dependency::Sbt { path } => Some(path),
            _ => None,
        }
    }
}




/// FILE: crates/sinter-core/src/deps/manager.rs

use crate::deps::deps::Dependency;
use std::path::{Path, PathBuf};
use tokio::process::Command;
use std::sync::atomic::{AtomicBool, Ordering};

/// æŠ½è±¡çš„ä¾èµ–ç®¡ç†å™¨trait
#[async_trait::async_trait]
pub trait DependencyManager {
    /// å‡†å¤‡ä¾èµ–ï¼ˆä¸‹è½½ã€æ„å»ºç­‰ï¼‰
    async fn prepare_dependencies(&self, deps: &[Dependency], target_dir: &Path) -> anyhow::Result<()>;

    /// è·å–æ„å»ºå‘½ä»¤çš„å‚æ•°
    fn get_build_args(&self, deps: &[Dependency]) -> Vec<String>;

    /// è·å–è¿è¡Œå‘½ä»¤çš„å‚æ•°
    fn get_run_args(&self, deps: &[Dependency]) -> Vec<String>;

    /// éªŒè¯ä¾èµ–æ˜¯å¦å¯ç”¨ï¼ˆç”¨äºæ·»åŠ ä¾èµ–æ—¶ï¼‰
    async fn validate_dependency(&self, dep: &Dependency) -> anyhow::Result<()>;

    /// è·å–ä¼ é€’ä¾èµ–ï¼ˆåŒ…æ‹¬ç›´æ¥ä¾èµ–å’Œæ‰€æœ‰ä¼ é€’ä¾èµ–ï¼‰
    async fn get_transitive_dependencies(&self, deps: &[Dependency]) -> anyhow::Result<Vec<Dependency>>;
}

/// è·å–æ‰“åŒ…çš„coursierå¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„
/// ä¼˜å…ˆä½¿ç”¨æ‰“åŒ…çš„ç‰ˆæœ¬ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›None
fn get_bundled_coursier_path() -> Option<PathBuf> {
    // å°è¯•ä»å¤šä¸ªå¯èƒ½çš„ä½ç½®æŸ¥æ‰¾æ‰“åŒ…çš„coursier
    let exe_name = if cfg!(target_os = "windows") {
        "coursier.exe"
    } else {
        "coursier"
    };
    
    // 1. å°è¯•ä»binç›®å½•ï¼ˆç›¸å¯¹äºå¯æ‰§è¡Œæ–‡ä»¶ï¼‰
    if let Ok(exe) = std::env::current_exe() {
        if let Some(exe_dir) = exe.parent() {
            let bundled_path = exe_dir.join("bin").join(exe_name);
            if bundled_path.exists() {
                return Some(bundled_path);
            }
        }
    }
    
    // 2. å°è¯•ä»CARGO_MANIFEST_DIR/binç›®å½•ï¼ˆå¼€å‘æ—¶ï¼‰
    if let Ok(manifest_dir) = std::env::var("CARGO_MANIFEST_DIR") {
        let bundled_path = PathBuf::from(manifest_dir).join("bin").join(exe_name);
        if bundled_path.exists() {
            return Some(bundled_path);
        }
    }
    
    None
}

/// è·å–coursierå¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„
/// ä¼˜å…ˆä½¿ç”¨æ‰“åŒ…çš„ç‰ˆæœ¬ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ä½¿ç”¨ç³»ç»Ÿå‘½ä»¤
async fn get_coursier_path() -> Option<String> {
    // é¦–å…ˆå°è¯•ä½¿ç”¨æ‰“åŒ…çš„coursier
    if let Some(bundled_path) = get_bundled_coursier_path() {
        // ç¡®ä¿æ–‡ä»¶æœ‰æ‰§è¡Œæƒé™
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            if let Ok(mut perms) = std::fs::metadata(&bundled_path).map(|m| m.permissions()) {
                perms.set_mode(0o755);
                let _ = std::fs::set_permissions(&bundled_path, perms);
            }
        }
        
        if let Some(path_str) = bundled_path.to_str() {
            // éªŒè¯æ‰“åŒ…çš„coursieræ˜¯å¦å¯ç”¨
            let mut cmd = Command::new(path_str);
            cmd.arg("--version");
            if cmd.output().await.map(|o| o.status.success()).unwrap_or(false) {
                return Some(path_str.to_string());
            }
        }
    }
    
    // å›é€€åˆ°ç³»ç»Ÿå‘½ä»¤
    if check_command_available("coursier").await {
        Some("coursier".to_string())
    } else {
        None
    }
}

/// æ£€æŸ¥å‘½ä»¤æ˜¯å¦å¯ç”¨
async fn check_command_available(cmd: &str) -> bool {
    Command::new(cmd)
        .arg("--version")
        .output()
        .await
        .map(|o| o.status.success())
        .unwrap_or(false)
}

static COURSIER_WARNING_PRINTED: AtomicBool = AtomicBool::new(false);

/// æ£€æŸ¥coursieræ˜¯å¦å¯ç”¨ï¼Œå¦‚æœä¸å¯ç”¨åˆ™æ‰“å°å®‰è£…æç¤ºï¼ˆä»…ä¸€æ¬¡ï¼‰
pub async fn check_coursier_available() -> bool {
    let available = get_coursier_path().await.is_some();
    if !available {
        // åªæ‰“å°ä¸€æ¬¡è­¦å‘Š
        if !COURSIER_WARNING_PRINTED.swap(true, Ordering::Relaxed) {
            eprintln!("Warning: coursier is not available. For better dependency management:");
            eprintln!("  - Install coursier: curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-pc-linux.gz | gzip -d > cs && chmod +x cs && ./cs install coursier");
            eprintln!("  - Or visit: https://get-coursier.io/");
            eprintln!("  Falling back to scala-cli for dependency management.");
        }
    }
    available
}

/// Coursier ä¾èµ–ç®¡ç†å™¨
pub struct CoursierDependencyManager;

#[async_trait::async_trait]
impl DependencyManager for CoursierDependencyManager {
    async fn prepare_dependencies(&self, deps: &[Dependency], _target_dir: &Path) -> anyhow::Result<()> {
        // è·å–coursierè·¯å¾„ï¼ˆä¼˜å…ˆä½¿ç”¨æ‰“åŒ…çš„ç‰ˆæœ¬ï¼‰
        let coursier_path = get_coursier_path().await
            .ok_or_else(|| anyhow::anyhow!("coursier is not available"))?;
        
        // ä½¿ç”¨coursierä¸‹è½½ä¾èµ–åˆ°æœ¬åœ°ç¼“å­˜
        // target_dirå‚æ•°ä¿ç•™ä»¥ä¿æŒtraitæ¥å£ä¸€è‡´æ€§ï¼Œä½†coursierä½¿ç”¨è‡ªå·±çš„ç¼“å­˜ç›®å½•
        for dep in deps {
            match dep {
                Dependency::Maven { group, artifact, version } => {
                    let coord = format!("{}:{}:{}", group, artifact, version);
                    
                    // ä½¿ç”¨coursier fetchä¸‹è½½ä¾èµ–ï¼ˆè¿™ä¼šè‡ªåŠ¨ç¼“å­˜ï¼‰
                    let mut cmd = Command::new(&coursier_path);
                    cmd.arg("fetch")
                        .arg("--quiet")
                        .arg(&coord);
                    
                    let output = cmd.output().await?;
                    if !output.status.success() {
                        let err = String::from_utf8_lossy(&output.stderr);
                        anyhow::bail!("Failed to fetch dependency {}: {}", coord, err);
                    }
                    
                    // å¯é€‰ï¼šå°†ä¾èµ–å¤åˆ¶åˆ°targetç›®å½•ï¼ˆå¦‚æœéœ€è¦ï¼‰
                    // é€šå¸¸coursierä¼šç®¡ç†ç¼“å­˜ï¼Œscala-cliä¹Ÿä¼šä½¿ç”¨ç›¸åŒçš„ç¼“å­˜
                }
                Dependency::Sbt { path } => {
                    // éªŒè¯sbté¡¹ç›®å­˜åœ¨
                    let sbt_project_path = Path::new(path);
                    if !sbt_project_path.exists() {
                        anyhow::bail!("sbt project path does not exist: {}", path);
                    }
                }
            }
        }
        
        Ok(())
    }

    fn get_build_args(&self, deps: &[Dependency]) -> Vec<String> {
        let mut args = Vec::new();

        for dep in deps {
            match dep {
                Dependency::Maven { group, artifact, version } => {
                    args.push("--dependency".to_string());
                    args.push(format!("{}:{}:{}", group, artifact, version));
                }
                Dependency::Sbt { path } => {
                    if Path::new(path).is_relative() {
                        args.push("--dependency".to_string());
                        args.push(format!("file://{}", path));
                    } else {
                        println!("Warning: Absolute sbt path {} may not work with scala-cli", path);
                    }
                }
            }
        }

        args
    }

    fn get_run_args(&self, deps: &[Dependency]) -> Vec<String> {
        self.get_build_args(deps)
    }

    async fn validate_dependency(&self, dep: &Dependency) -> anyhow::Result<()> {
        // è·å–coursierè·¯å¾„ï¼ˆä¼˜å…ˆä½¿ç”¨æ‰“åŒ…çš„ç‰ˆæœ¬ï¼‰
        let coursier_path = get_coursier_path().await
            .ok_or_else(|| anyhow::anyhow!("coursier is not available"))?;

        match dep {
            Dependency::Maven { group, artifact, version } => {
                let coord = format!("{}:{}:{}", group, artifact, version);

                // ä½¿ç”¨coursier resolveéªŒè¯ä¾èµ–æ˜¯å¦å­˜åœ¨
                let mut cmd = Command::new(&coursier_path);
                cmd.arg("resolve")
                    .arg("--quiet")
                    .arg(&coord);

                let output = cmd.output().await?;
                if !output.status.success() {
                    let err = String::from_utf8_lossy(&output.stderr);
                    anyhow::bail!("Dependency {} is not available: {}", coord, err);
                }

                Ok(())
            }
            Dependency::Sbt { path } => {
                let sbt_project_path = Path::new(path);
                if !sbt_project_path.exists() {
                    anyhow::bail!("sbt project path does not exist: {}", path);
                }
                Ok(())
            }
        }
    }

    async fn get_transitive_dependencies(&self, deps: &[Dependency]) -> anyhow::Result<Vec<Dependency>> {
        let coursier_path = get_coursier_path().await
            .ok_or_else(|| anyhow::anyhow!("coursier is not available"))?;

        let mut all_deps = Vec::new();
        let mut processed_coords = std::collections::HashSet::new();

        for dep in deps {
            match dep {
                Dependency::Maven { group, artifact, version } => {
                    let coord = format!("{}:{}:{}", group, artifact, version);

                    // ä½¿ç”¨coursier resolveè·å–ä¼ é€’ä¾èµ–
                    let mut cmd = Command::new(&coursier_path);
                    cmd.arg("resolve")
                        .arg("--quiet")
                        .arg("--print-tree=false")
                        .arg("--intransitive")  // è·å–æ‰€æœ‰ä¼ é€’ä¾èµ–
                        .arg(&coord);

                    let output = cmd.output().await?;
                    if !output.status.success() {
                        let err = String::from_utf8_lossy(&output.stderr);
                        eprintln!("Warning: Failed to resolve transitive dependencies for {}: {}", coord, err);
                        // å¦‚æœè§£æå¤±è´¥ï¼Œè‡³å°‘åŒ…å«åŸå§‹ä¾èµ–
                        if !processed_coords.contains(&coord) {
                            all_deps.push(dep.clone());
                            processed_coords.insert(coord);
                        }
                        continue;
                    }

                    // è§£æè¾“å‡ºï¼Œcoursier resolveè¾“å‡ºæ ¼å¼ä¸ºæ¯è¡Œä¸€ä¸ªåæ ‡
                    let stdout = String::from_utf8_lossy(&output.stdout);
                    for line in stdout.lines() {
                        let line = line.trim();
                        if line.is_empty() || line.starts_with('#') {
                            continue;
                        }

                        // è§£æMavenåæ ‡æ ¼å¼ group:artifact:version
                        let parts: Vec<&str> = line.split(':').collect();
                        if parts.len() >= 3 {
                            let group = parts[0];
                            let artifact = parts[1];
                            let version = parts[2];
                            let coord = format!("{}:{}:{}", group, artifact, version);

                            if !processed_coords.contains(&coord) {
                                all_deps.push(Dependency::Maven {
                                    group: group.to_string(),
                                    artifact: artifact.to_string(),
                                    version: version.to_string(),
                                });
                                processed_coords.insert(coord);
                            }
                        }
                    }
                }
                Dependency::Sbt { path } => {
                    // å¯¹äºsbtä¾èµ–ï¼Œæˆ‘ä»¬æ— æ³•è§£æä¼ é€’ä¾èµ–ï¼Œæ‰€ä»¥åªåŒ…å«æœ¬èº«
                    all_deps.push(dep.clone());
                }
            }
        }

        Ok(all_deps)
    }
}

/// Scala CLI ä¾èµ–ç®¡ç†å™¨
pub struct ScalaCliDependencyManager;

#[async_trait::async_trait]
impl DependencyManager for ScalaCliDependencyManager {
    async fn prepare_dependencies(&self, deps: &[Dependency], _target_dir: &Path) -> anyhow::Result<()> {
        // Scala CLI ä¼šè‡ªåŠ¨å¤„ç†ä¾èµ–ä¸‹è½½ï¼Œä¸éœ€è¦é¢„å…ˆå‡†å¤‡
        // ä½†æ˜¯æˆ‘ä»¬å¯ä»¥éªŒè¯ä¾èµ–æ˜¯å¦æœ‰æ•ˆ

        // å¯¹äºsbtä¾èµ–ï¼Œæˆ‘ä»¬éœ€è¦ç‰¹æ®Šå¤„ç†
        for dep in deps {
            if let Some(sbt_path) = dep.sbt_path() {
                // éªŒè¯sbté¡¹ç›®å­˜åœ¨
                let sbt_project_path = Path::new(sbt_path);
                if !sbt_project_path.exists() {
                    anyhow::bail!("sbt project path does not exist: {}", sbt_path);
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰project.tomlæˆ–å…¶ä»–Scala CLIé…ç½®æ–‡ä»¶
                let has_scala_cli_config = sbt_project_path.join("project.scala").exists() ||
                    sbt_project_path.join("project.sc").exists();

                if !has_scala_cli_config {
                    println!("Warning: sbt project {} may not be compatible with scala-cli", sbt_path);
                    println!("Consider converting it to use scala-cli or providing Maven coordinates");
                }
            }
        }

        Ok(())
    }

    fn get_build_args(&self, deps: &[Dependency]) -> Vec<String> {
        let mut args = Vec::new();

        for dep in deps {
            match dep {
                Dependency::Maven { group, artifact, version } => {
                    args.push("--dependency".to_string());
                    args.push(format!("{}:{}:{}", group, artifact, version));
                }
                Dependency::Sbt { path } => {
                    // å¯¹äºsbtä¾èµ–ï¼Œå°è¯•å°†å…¶ä½œä¸ºscala-clié¡¹ç›®æ·»åŠ 
                    // å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œå‡è®¾å®ƒæ˜¯ä¸€ä¸ªscala-clié¡¹ç›®
                    if Path::new(path).is_relative() {
                        args.push("--dependency".to_string());
                        args.push(format!("file://{}", path));
                    } else {
                        println!("Warning: Absolute sbt path {} may not work with scala-cli", path);
                    }
                }
            }
        }

        args
    }

    fn get_run_args(&self, deps: &[Dependency]) -> Vec<String> {
        // è¿è¡Œæ—¶å‚æ•°ä¸æ„å»ºæ—¶ç›¸åŒ
        self.get_build_args(deps)
    }

    async fn validate_dependency(&self, dep: &Dependency) -> anyhow::Result<()> {
        // Scala CLI éªŒè¯ï¼šé€šè¿‡å°è¯•ç¼–è¯‘ä¸€ä¸ªç®€å•çš„ç¨‹åºæ¥éªŒè¯ä¾èµ–æ˜¯å¦å¯ç”¨
        match dep {
            Dependency::Maven { group, artifact, version } => {
                let coord = format!("{}:{}:{}", group, artifact, version);

                // ä½¿ç”¨scala-cliæ¥éªŒè¯ä¾èµ–ï¼ˆé€šè¿‡å°è¯•ç¼–è¯‘ä¸€ä¸ªç®€å•çš„ç¨‹åºï¼‰
                // è¿™æ ·å¯ä»¥ç¡®ä¿ä¾èµ–å¯ä»¥è¢«æ­£ç¡®è§£æå’Œä¸‹è½½
                let mut cmd = Command::new("scala-cli");
                cmd.arg("--dependency")
                    .arg(&coord)
                    .arg("--quiet")
                    .arg("-e")
                    .arg("println(\"test\")");

                let output = cmd.output().await?;
                if !output.status.success() {
                    let err = String::from_utf8_lossy(&output.stderr);
                    anyhow::bail!("Dependency {} is not available: {}", coord, err);
                }

                Ok(())
            }
            Dependency::Sbt { path } => {
                let sbt_project_path = Path::new(path);
                if !sbt_project_path.exists() {
                    anyhow::bail!("sbt project path does not exist: {}", path);
                }
                Ok(())
            }
        }
    }

    async fn get_transitive_dependencies(&self, deps: &[Dependency]) -> anyhow::Result<Vec<Dependency>> {
        // Scala CLIæ²¡æœ‰ç›´æ¥çš„ä¼ é€’ä¾èµ–è§£æåŠŸèƒ½
        // æˆ‘ä»¬å°è¯•ä½¿ç”¨coursierä½œä¸ºåå¤‡ï¼Œå¦‚æœä¸å¯ç”¨åˆ™è¿”å›ç›´æ¥ä¾èµ–

        if let Some(coursier_path) = get_coursier_path().await {
            let mut all_deps = Vec::new();
            let mut processed_coords = std::collections::HashSet::new();

            for dep in deps {
                match dep {
                    Dependency::Maven { group, artifact, version } => {
                        let coord = format!("{}:{}:{}", group, artifact, version);

                        // ä½¿ç”¨coursier resolveè·å–ä¼ é€’ä¾èµ–
                        let mut cmd = Command::new(&coursier_path);
                        cmd.arg("resolve")
                            .arg("--quiet")
                            .arg("--print-tree=false")
                            .arg("--intransitive")
                            .arg(&coord);

                        let output = cmd.output().await?;
                        if !output.status.success() {
                            // å¦‚æœcoursierè§£æå¤±è´¥ï¼Œè‡³å°‘åŒ…å«åŸå§‹ä¾èµ–
                            if !processed_coords.contains(&coord) {
                                all_deps.push(dep.clone());
                                processed_coords.insert(coord);
                            }
                            continue;
                        }

                        // è§£æè¾“å‡º
                        let stdout = String::from_utf8_lossy(&output.stdout);
                        for line in stdout.lines() {
                            let line = line.trim();
                            if line.is_empty() || line.starts_with('#') {
                                continue;
                            }

                            let parts: Vec<&str> = line.split(':').collect();
                            if parts.len() >= 3 {
                                let group = parts[0];
                                let artifact = parts[1];
                                let version = parts[2];
                                let coord = format!("{}:{}:{}", group, artifact, version);

                                if !processed_coords.contains(&coord) {
                                    all_deps.push(Dependency::Maven {
                                        group: group.to_string(),
                                        artifact: artifact.to_string(),
                                        version: version.to_string(),
                                    });
                                    processed_coords.insert(coord);
                                }
                            }
                        }
                    }
                    Dependency::Sbt { .. } => {
                        // å¯¹äºsbtä¾èµ–ï¼Œæ— æ³•è§£æä¼ é€’ä¾èµ–
                        all_deps.push(dep.clone());
                    }
                }
            }

            Ok(all_deps)
        } else {
            // å¦‚æœcoursierä¸å¯ç”¨ï¼Œè¿”å›ç›´æ¥ä¾èµ–
            Ok(deps.to_vec())
        }
    }
}

/// è·å–é»˜è®¤çš„ä¾èµ–ç®¡ç†å™¨
/// ä¼˜å…ˆä½¿ç”¨coursierï¼ˆå¦‚æœå¯ç”¨ï¼‰ï¼Œå¦åˆ™å›é€€åˆ°ScalaCliDependencyManager
pub async fn default_dependency_manager() -> Box<dyn DependencyManager + Send + Sync> {
    if check_coursier_available().await {
        Box::new(CoursierDependencyManager)
    } else {
        Box::new(ScalaCliDependencyManager)
    }
}

/// åŒæ­¥ç‰ˆæœ¬çš„é»˜è®¤ä¾èµ–ç®¡ç†å™¨ï¼ˆç”¨äºä¸éœ€è¦å¼‚æ­¥çš„åœºæ™¯ï¼‰
/// æ³¨æ„ï¼šè¿™ä¼šæ£€æŸ¥coursieræ˜¯å¦å¯ç”¨ï¼Œä½†ä¸ä¼šç­‰å¾…
pub fn default_dependency_manager_sync() -> Box<dyn DependencyManager + Send + Sync> {
    // ä½¿ç”¨tokio runtimeæ¥æ£€æŸ¥å‘½ä»¤
    let rt = tokio::runtime::Runtime::new().unwrap();
    if rt.block_on(check_command_available("coursier")) {
        Box::new(CoursierDependencyManager)
    } else {
        Box::new(ScalaCliDependencyManager)
    }
}


/// FILE: crates/sinter-core/src/deps/mod.rs

pub mod deps;
pub mod add;
pub mod manager;

pub use add::add_dependency;
pub use manager::{DependencyManager, ScalaCliDependencyManager, CoursierDependencyManager, default_dependency_manager, default_dependency_manager_sync};



/// FILE: crates/sinter-core/src/i18n.rs

//! å›½é™…åŒ–æ”¯æŒæ¨¡å—
//!
//! æ­¤æ¨¡å—åœ¨æ„å»ºæ—¶ç”± build.rs ç”Ÿæˆï¼Œæä¾›ç±»å‹å®‰å…¨çš„ç¿»è¯‘åŠŸèƒ½ã€‚
//! è¯­è¨€é€‰æ‹©é€šè¿‡ Cargo ç‰¹æ€§æ ‡å¿—æ§åˆ¶ï¼š
//! - `lang-en` (é»˜è®¤): è‹±æ–‡
//! - `lang-zh`: ä¸­æ–‡
//!
//! ä½¿ç”¨ç¤ºä¾‹ï¼š
//! ```rust
//! use crate::i18n::{t, tf};
//!
//! // ç®€å•ç¿»è¯‘
//! println!("{}", t("main_about"));
//!
//! // å¸¦å‚æ•°çš„ç¿»è¯‘
//! println!("{}", tf("created_project", &["my-project"]));
//! ```

// Fallback å®ç°ï¼ˆç”¨äº rust-analyzer å’Œæµ‹è¯•ç¯å¢ƒï¼‰
// å½“ OUT_DIR æœªè®¾ç½®æ—¶ï¼Œrust-analyzer å¯ä»¥ä½¿ç”¨è¿™ä¸ªå®ç°è¿›è¡Œåˆ†æ
mod fallback {
    /// Get a translated string by key (fallback implementation)
    /// This is used when build scripts haven't run (e.g., in rust-analyzer)
    pub fn t(_key: &str) -> &'static str {
        // è¿”å›ä¸€ä¸ªå ä½ç¬¦å­—ç¬¦ä¸²ï¼Œè¿™æ · rust-analyzer å¯ä»¥æ­£å¸¸å·¥ä½œ
        // å®é™…æ„å»ºæ—¶ä¼šä½¿ç”¨ç”Ÿæˆçš„ä»£ç 
        "[Translation placeholder]"
    }

    /// Format a translated string with arguments (fallback implementation)
    pub fn tf(key: &str, args: &[&str]) -> String {
        let template = t(key);
        let mut result = template.to_string();
        for arg in args {
            if result.contains("{}") {
                result = result.replacen("{}", arg, 1);
            } else {
                break;
            }
        }
        result
    }
}

// å°è¯•åŒ…å«æ„å»ºæ—¶ç”Ÿæˆçš„ä»£ç 
// ä½¿ç”¨æ¡ä»¶ç¼–è¯‘ï¼šåªæœ‰åœ¨å®é™…æ„å»ºæ—¶æ‰åŒ…å«ç”Ÿæˆçš„ä»£ç 
#[cfg(all(not(test), not(doctest)))]
mod generated {
    // å°è¯•åŒ…å«ç”Ÿæˆçš„ä»£ç 
    // å¦‚æœ OUT_DIR æœªè®¾ç½®ï¼Œè¿™ä¼šåœ¨ç¼–è¯‘æ—¶å¤±è´¥
    // ä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡æä¾›ä¸€ä¸ªé»˜è®¤çš„è‹±æ–‡å®ç°æ¥é¿å…è¿™ä¸ªé—®é¢˜
    // æ³¨æ„ï¼šåœ¨å®é™…æ„å»ºæ—¶ï¼Œbuild.rs æ€»æ˜¯ä¼šè¿è¡Œï¼Œæ‰€ä»¥ OUT_DIR æ€»æ˜¯å­˜åœ¨
    include!(concat!(env!("OUT_DIR"), "/i18n.rs"));
}

// å¯¼å‡ºå‡½æ•°
// åœ¨å®é™…æ„å»ºæ—¶ä½¿ç”¨ç”Ÿæˆçš„ä»£ç ï¼Œåœ¨æµ‹è¯•æˆ– rust-analyzer æ—¶ä½¿ç”¨ fallback
#[cfg(all(not(test), not(doctest)))]
pub use generated::{t, tf};

#[cfg(any(test, doctest))]
pub use fallback::{t, tf};

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_translation() {
        // æµ‹è¯•ç®€å•ç¿»è¯‘
        let msg = t("main_about");
        assert!(!msg.is_empty());
    }

    #[test]
    fn test_formatted_translation() {
        // æµ‹è¯•æ ¼å¼åŒ–ç¿»è¯‘
        // æ³¨æ„ï¼šåœ¨æµ‹è¯•æ¨¡å¼ä¸‹ä½¿ç”¨ fallbackï¼Œæ‰€ä»¥åªæµ‹è¯•å‡½æ•°èƒ½æ­£å¸¸è°ƒç”¨
        let msg = tf("created_project", &["test-project"]);
        assert!(!msg.is_empty());
        // fallback å®ç°ä¼šæ›¿æ¢ {}ï¼Œæ‰€ä»¥åº”è¯¥åŒ…å«å‚æ•°
        assert!(msg.contains("test-project") || msg == "[Translation placeholder]");
    }
}




/// FILE: crates/sinter-core/src/lib.rs

//! Sinter - Scala é¡¹ç›®æ„å»ºå·¥å…·
//!
//! è¿™æ˜¯ä¸€ä¸ªç±»ä¼¼ Cargo çš„ Scala é¡¹ç›®ç®¡ç†å’Œæ„å»ºå·¥å…·ã€‚

// æ ¸å¿ƒæ¨¡å—
pub mod core;

// è¿è¡Œæ—¶æ¨¡å—
pub mod runtime;

// CLI å’Œé…ç½®
pub mod cli;
pub mod config;

// åŠŸèƒ½æ¨¡å—
pub mod build;
pub mod deps;
pub mod cmd;

// å®å’Œå·¥å…·
#[macro_use]
pub mod commands;

// å›½é™…åŒ–æ”¯æŒï¼ˆæ„å»ºæ—¶ç”Ÿæˆï¼‰
pub mod i18n;

// extern crate paste;

// å…¬å…± API
pub use core::{CommandHandler, Sinter};
pub use cli::Cli;
pub use cmd::{Commands, WorkspaceCommands};


/// FILE: crates/sinter-core/src/runtime/executor.rs

//! å‘½ä»¤æ‰§è¡Œå™¨
//!
//! è´Ÿè´£å°†è§£æåçš„ CLI å‘½ä»¤åˆ†å‘åˆ°å¯¹åº”çš„å¤„ç†å™¨

use crate::core::handler::CommandHandler;
use crate::cli::Cli;
use crate::cmd::builtin;
use std::path::PathBuf;

/// å‘½ä»¤æ‰§è¡Œå™¨
///
/// è´Ÿè´£æ‰§è¡Œå‘½ä»¤ï¼ŒåŒ…æ‹¬ï¼š
/// 1. æ’ä»¶å‘½ä»¤çš„æ‰§è¡Œ
/// 2. å†…ç½®å‘½ä»¤çš„æ‰§è¡Œ
pub struct Executor {
    plugins: Vec<Box<dyn CommandHandler>>,
}

impl Executor {
    /// åˆ›å»ºæ–°çš„æ‰§è¡Œå™¨
    pub fn new(plugins: Vec<Box<dyn CommandHandler>>) -> Self {
        Self { plugins }
    }

    /// æ‰§è¡Œå‘½ä»¤
    ///
    /// æ ¹æ® CLI è§£æç»“æœï¼Œæ‰§è¡Œå¯¹åº”çš„å‘½ä»¤
    pub async fn execute(&self, cli: Cli, cwd: PathBuf) -> anyhow::Result<()> {
        // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯æ’ä»¶å‘½ä»¤
        if let Some((command_name, matches)) = cli.raw_matches.subcommand() {
            if let Some(handler) = self.plugins.iter().find(|cmd| cmd.name() == command_name) {
                return handler.execute(matches, &cwd).await;
            }
        }

        // å¤„ç†å†…ç½®å‘½ä»¤
        if let Some(command) = cli.command {
            builtin::execute_command(command, &cwd).await?;
        } else {
            // æ²¡æœ‰æä¾›å‘½ä»¤ï¼Œå°è¯•è¿è¡Œé»˜è®¤è¡Œä¸º
            builtin::execute_default(&cwd).await?;
        }

        Ok(())
    }
}




/// FILE: crates/sinter-core/src/runtime/mod.rs

//! è¿è¡Œæ—¶æ¨¡å—
//!
//! å¤„ç†å‘½ä»¤çš„æ‰§è¡Œå’Œåˆ†å‘é€»è¾‘

pub mod executor;

pub use executor::Executor;




/// FILE: crates/sinter-core/templates/i18n.json

{
  "en": {
    "main_about": "A Cargo-like build tool for Scala",
    "new_about": "Create a new Scala project",
    "init_about": "Initialize a new workspace",
    "build_about": "Build the Scala project",
    "run_about": "Run the Scala project or a specific file",
    "add_about": "Add a dependency to the project",
    "workspace_about": "Workspace management",
    "workspace_add_about": "Add a member to the workspace",
    "new_name_help": "Name of the new project",
    "run_file_help": "Optional .scala file to run (relative to project root)",
    "run_lib_help": "Force library mode (compile only)",
    "add_dep_help": "Dependency in format: group::artifact:version[@scala-version]",
    "workspace_add_path_help": "Path to the member project",
    "test_about": "Run tests",
    "test_file_help": "Optional test file or directory to run (relative to project root)",
    "project_already_exists": "Project '{}' already exists",
    "created_project": "Created project `{}`",
    "initialized_empty_workspace": "Initialized empty workspace in {}",
    "added_member_to_workspace": "Added member '{}' to workspace",
    "added_project_to_workspace": "Added project '{}' to workspace",
    "member_already_exists": "Member '{}' already exists in workspace",
    "added_dependency": "Added dependency: {} = {}",
    "built_member": "Built member: {}",
    "build_succeeded_with_deps": "Build succeeded with {} dependencies",
    "workspace_build_succeeded": "Workspace build succeeded",
    "lib_compiled_only": "lib: {} (compiled only)",
    "main_file_not_found": "Main file not found: {}",
    "no_command_provided": "No command provided. Use --help for usage.",
    "config_file_already_exists": "project.toml already exists in this directory",
    "not_in_workspace": "Not in a workspace",
    "invalid_dependency_format": "Invalid dependency format, please use full format: group::artifact:version, e.g. org.typelevel::cats-core:2.9.0",
    "invalid_artifact_format": "Invalid dependency format, artifact should not contain '::', please use group:artifact:version format",
    "version_must_be_specified": "Version must be explicitly specified, 'latest' is not allowed",
    "running_in_workspace": "Running in workspace: {}",
    "running_in_project": "Running in project: {}",
    "workspace_dependencies": "Workspace dependencies ({}):",
    "project_dependencies": "Project dependencies ({}):",
    "no_workspace_dependencies": "No workspace dependencies",
    "no_project_dependencies": "No project dependencies",
    "dependency_item": "  - {}"
  },
  "zh": {
    "main_about": "ä¸€ä¸ªç±»ä¼¼ Cargo çš„ Scala æ„å»ºå·¥å…·",
    "new_about": "åˆ›å»ºä¸€ä¸ªæ–°çš„ Scala é¡¹ç›®",
    "init_about": "åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„å·¥ä½œç©ºé—´",
    "build_about": "æ„å»º Scala é¡¹ç›®",
    "run_about": "è¿è¡Œ Scala é¡¹ç›®æˆ–ç‰¹å®šæ–‡ä»¶",
    "add_about": "å‘é¡¹ç›®æ·»åŠ ä¾èµ–",
    "workspace_about": "å·¥ä½œç©ºé—´ç®¡ç†",
    "workspace_add_about": "å‘å·¥ä½œç©ºé—´æ·»åŠ æˆå‘˜",
    "new_name_help": "æ–°é¡¹ç›®çš„åç§°",
    "run_file_help": "å¯é€‰çš„è¦è¿è¡Œçš„ .scala æ–‡ä»¶ï¼ˆç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•ï¼‰",
    "run_lib_help": "å¼ºåˆ¶åº“æ¨¡å¼ï¼ˆä»…ç¼–è¯‘ï¼‰",
    "add_dep_help": "ä¾èµ–æ ¼å¼ï¼šgroup::artifact:version[@scala-version]",
    "workspace_add_path_help": "æˆå‘˜é¡¹ç›®çš„è·¯å¾„",
    "test_about": "è¿è¡Œæµ‹è¯•",
    "test_file_help": "å¯é€‰çš„æµ‹è¯•æ–‡ä»¶æˆ–ç›®å½•ï¼ˆç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•ï¼‰",
    "project_already_exists": "é¡¹ç›® '{}' å·²å­˜åœ¨",
    "created_project": "å·²åˆ›å»ºé¡¹ç›® `{}`",
    "initialized_empty_workspace": "å·²åˆå§‹åŒ–ç©ºå·¥ä½œç©ºé—´äº {}",
    "added_member_to_workspace": "å·²æ·»åŠ æˆå‘˜ '{}' åˆ°å·¥ä½œç©ºé—´",
    "added_project_to_workspace": "å·²æ·»åŠ é¡¹ç›® '{}' åˆ°å·¥ä½œç©ºé—´",
    "member_already_exists": "æˆå‘˜ '{}' å·²å­˜åœ¨äºå·¥ä½œç©ºé—´",
    "added_dependency": "å·²æ·»åŠ ä¾èµ–: {} = {}",
    "built_member": "å·²æ„å»ºæˆå‘˜: {}",
    "build_succeeded_with_deps": "æ„å»ºæˆåŠŸï¼ŒåŒ…å« {} ä¸ªä¾èµ–",
    "workspace_build_succeeded": "å·¥ä½œç©ºé—´æ„å»ºæˆåŠŸ",
    "lib_compiled_only": "åº“: {} (ä»…ç¼–è¯‘)",
    "main_file_not_found": "æœªæ‰¾åˆ°ä¸»æ–‡ä»¶: {}",
    "no_command_provided": "æœªæä¾›å‘½ä»¤ã€‚ä½¿ç”¨ --help è·å–ç”¨æ³•ã€‚",
    "config_file_already_exists": "project.toml å·²å­˜åœ¨äºæ­¤ç›®å½•",
    "not_in_workspace": "ä¸åœ¨å·¥ä½œç©ºé—´ä¸­",
    "invalid_dependency_format": "ä¾èµ–æ ¼å¼æ— æ•ˆï¼Œè¯·ä½¿ç”¨å®Œæ•´æ ¼å¼ï¼šgroup::artifact:versionï¼Œä¾‹å¦‚ org.typelevel::cats-core:2.9.0",
    "invalid_artifact_format": "ä¾èµ–æ ¼å¼æ— æ•ˆï¼Œartifact ä¸åº”åŒ…å« '::'ï¼Œè¯·ä½¿ç”¨ group:artifact:version æ ¼å¼",
    "version_must_be_specified": "å¿…é¡»æ˜ç¡®æŒ‡å®šç‰ˆæœ¬ï¼Œä¸å…è®¸ä½¿ç”¨ 'latest'",
    "running_in_workspace": "åœ¨å·¥ä½œç©ºé—´ä¸­è¿è¡Œ: {}",
    "running_in_project": "åœ¨é¡¹ç›®ä¸­è¿è¡Œ: {}",
    "workspace_dependencies": "å·¥ä½œç©ºé—´ä¾èµ– ({}):",
    "project_dependencies": "é¡¹ç›®ä¾èµ– ({}):",
    "no_workspace_dependencies": "æ— å·¥ä½œç©ºé—´ä¾èµ–",
    "no_project_dependencies": "æ— é¡¹ç›®ä¾èµ–",
    "dependency_item": "  - {}"
  }
}




/// FILE: crates/sinter-plugin-api/Cargo.toml

# crates/sinter-plugin-api/Cargo.toml
[package]
name = "sinter-plugin-api"
version.workspace = true
edition.workspace = true
license.workspace = true
description = "sinter æ’ä»¶å¼€å‘ API"

[dependencies]
sinter = { path = "../sinter-core" }
anyhow      = { workspace = true }
async-trait = { workspace = true }
clap        = { workspace = true }
tokio       = { workspace = true }


/// FILE: crates/sinter-plugin-api/README.md

# Sinter æ’ä»¶å¼€å‘ API

è¿™ä¸ª crate æä¾›äº†å¼€å‘ Sinter æ’ä»¶æ‰€éœ€çš„æ‰€æœ‰ä¾èµ–å’Œç±»å‹ã€‚**æ’ä»¶å¼€å‘è€…åªéœ€è¦ä¾èµ–è¿™ä¸€ä¸ª crate**ï¼Œå°±å¯ä»¥è·å¾—æ‰€æœ‰å¿…è¦çš„å·¥å…·ã€‚

## ç‰¹æ€§

- âœ… **å•ä¸€ä¾èµ–**ï¼šåªéœ€è¦æ·»åŠ  `sinter-plugin` åˆ°ä½ çš„ `Cargo.toml`
- âœ… **ç±»å‹é‡æ–°å¯¼å‡º**ï¼šæ‰€æœ‰å¸¸ç”¨ç±»å‹éƒ½å·²é‡æ–°å¯¼å‡ºï¼Œæ— éœ€é¢å¤–å¯¼å…¥
- âœ… **ç®€åŒ–å¼€å‘**ï¼šä¸éœ€è¦å…³å¿ƒåº•å±‚ä¾èµ–ç‰ˆæœ¬

## ä½¿ç”¨

### 1. æ·»åŠ ä¾èµ–

åœ¨ä½ çš„æ’ä»¶é¡¹ç›®çš„ `Cargo.toml` ä¸­ï¼š

```toml
[dependencies]
sinter-plugin = { path = "../sinter-plugin-api" }
# æˆ–è€…å¦‚æœå‘å¸ƒåˆ° crates.ioï¼š
# sinter-plugin = "0.1.0"
```

### 2. åˆ›å»ºæ’ä»¶

```rust
use sinter_plugin_api::*;

pub struct MyPlugin;

#[async_trait]
impl CommandHandler for MyPlugin {
    fn name(&self) -> &'static str {
        "mycommand"
    }

    fn about(&self) -> &'static str {
        "My awesome command"
    }

    fn configure(&self, cmd: Command) -> Command {
        cmd.arg(Arg::new("input").required(true))
    }

    async fn execute(&self, matches: &ArgMatches, cwd: &PathBuf) -> AnyhowResult<()> {
        let input = matches.get_one::<String>("input").unwrap();
        println!("Processing: {}", input);
        
        // ä½¿ç”¨é‡æ–°å¯¼å‡ºçš„ fs æ¨¡å—
        fs::write(cwd.join("output.txt"), input).await?;
        
        Ok(())
    }
}

pub fn my_plugin() -> MyPlugin {
    MyPlugin
}
```

## é‡æ–°å¯¼å‡ºçš„ç±»å‹

é€šè¿‡ `use sinter_plugin_api::*;` ä½ å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼š

- `CommandHandler` - æ’ä»¶ trait
- `async_trait` - async trait å®
- `Command`, `Arg`, `ArgMatches` - clap ç±»å‹
- `PathBuf` - è·¯å¾„ç±»å‹
- `AnyhowResult<T>` - é”™è¯¯å¤„ç†ç±»å‹ï¼ˆç­‰åŒäº `anyhow::Result<T>`ï¼‰
- `fs` - tokio æ–‡ä»¶ç³»ç»Ÿæ¨¡å—

## å®Œæ•´ç¤ºä¾‹

æŸ¥çœ‹ `plugins/src/jsp.rs` æŸ¥çœ‹å®Œæ•´çš„æ’ä»¶ç¤ºä¾‹ã€‚



/// FILE: crates/sinter-plugin-api/src/lib.rs

//! Sinter æ’ä»¶å¼€å‘ API
//!
//! è¿™ä¸ª crate æä¾›äº†å¼€å‘ Sinter æ’ä»¶æ‰€éœ€çš„æ‰€æœ‰ä¾èµ–å’Œç±»å‹ã€‚
//! æ’ä»¶å¼€å‘è€…åªéœ€è¦ä¾èµ–è¿™ä¸ª crateï¼Œå°±å¯ä»¥è·å¾—æ‰€æœ‰å¿…è¦çš„å·¥å…·ã€‚
//!
//! ## ä½¿ç”¨ç¤ºä¾‹
//!
//! ```rust
//! use sinter_plugin_api::*;
//!
//! pub struct MyPlugin;
//!
//! #[async_trait]
//! impl CommandHandler for MyPlugin {
//!     fn name(&self) -> &'static str {
//!         "mycommand"
//!     }
//!
//!     fn about(&self) -> &'static str {
//!         "My awesome command"
//!     }
//!
//!     fn configure(&self, cmd: Command) -> Command {
//!         cmd.arg(Arg::new("input").required(true))
//!     }
//!
//!     async fn execute(&self, matches: &ArgMatches, cwd: &PathBuf) -> AnyhowResult<()> {
//!         let input = matches.get_one::<String>("input").unwrap();
//!         println!("Processing: {}", input);
//!         
//!         // ä½¿ç”¨é‡æ–°å¯¼å‡ºçš„ fs æ¨¡å—
//!         fs::write(cwd.join("output.txt"), input).await?;
//!         
//!         Ok(())
//!     }
//! }
//! ```

// é‡æ–°å¯¼å‡ºæ ¸å¿ƒç±»å‹
pub use sinter::CommandHandler;

// é‡æ–°å¯¼å‡ºå¸¸ç”¨ç±»å‹ï¼Œæ–¹ä¾¿æ’ä»¶å¼€å‘
pub use clap::{Arg, ArgMatches, Command};
pub use std::path::PathBuf;
pub use anyhow::Result as AnyhowResult;
pub use async_trait::async_trait;

// é‡æ–°å¯¼å‡º tokio çš„å¸¸ç”¨åŠŸèƒ½
pub use tokio::fs;




/// FILE: crates/sinter-plugins/Cargo.toml

# crates/plugins/Cargo.toml
[package]
name = "sinter-plugins"
version.workspace = true
edition.workspace = true
license.workspace = true

[dependencies]
sinter-plugin-api = { path = "../sinter-plugin-api" }


/// FILE: crates/sinter-plugins/README.md

# Sinter æ’ä»¶é›†åˆ

è¿™ä¸ª crate åŒ…å« Sinter çš„æ‰©å±•æ’ä»¶ã€‚

## ç»“æ„

```
plugins/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs      # å¯¼å‡ºæ‰€æœ‰æ’ä»¶
â”‚   â””â”€â”€ jsp.rs      # JSP é¡¹ç›®ç”Ÿæˆæ’ä»¶
â””â”€â”€ README.md
```

## ä½¿ç”¨

åœ¨ä¸»é¡¹ç›®çš„ `main.rs` ä¸­ï¼š

```rust
use sinter::Sinter;
use plugins::jsp_plugin;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    Sinter::new()
        .plugin(jsp_plugin())
        .run()
        .await
}
```

## æ·»åŠ æ–°æ’ä»¶

### 1. æ·»åŠ ä¾èµ–

åœ¨ `Cargo.toml` ä¸­ï¼Œåªéœ€è¦ä¾èµ– `sinter-plugin`ï¼š

```toml
[dependencies]
sinter-plugin = { path = "../sinter-plugin-api" }
```

### 2. åˆ›å»ºæ’ä»¶

åœ¨ `src/` ç›®å½•ä¸‹åˆ›å»ºæ–°çš„æ’ä»¶æ–‡ä»¶ï¼ˆå¦‚ `my_plugin.rs`ï¼‰ï¼š

```rust
// src/my_plugin.rs
use sinter_plugin_api::*;

pub struct MyPlugin;

#[async_trait]
impl CommandHandler for MyPlugin {
    fn name(&self) -> &'static str {
        "mycommand"
    }

    fn about(&self) -> &'static str {
        "My awesome command"
    }

    fn configure(&self, cmd: Command) -> Command {
        cmd.arg(Arg::new("input").required(true))
    }

    async fn execute(&self, matches: &ArgMatches, cwd: &PathBuf) -> AnyhowResult<()> {
        let input = matches.get_one::<String>("input").unwrap();
        println!("Processing: {}", input);
        
        // ä½¿ç”¨é‡æ–°å¯¼å‡ºçš„ fs æ¨¡å—
        fs::write(cwd.join("output.txt"), input).await?;
        
        Ok(())
    }
}

pub fn my_plugin() -> MyPlugin {
    MyPlugin
}
```

### 3. å¯¼å‡ºæ’ä»¶

åœ¨ `src/lib.rs` ä¸­ï¼š

```rust
pub mod my_plugin;
pub use my_plugin::my_plugin;
```

## ä¼˜åŠ¿

ä½¿ç”¨ `sinter-plugin` çš„å¥½å¤„ï¼š

- âœ… **å•ä¸€ä¾èµ–**ï¼šä¸éœ€è¦å…³å¿ƒåº•å±‚ä¾èµ–ç‰ˆæœ¬
- âœ… **ç®€åŒ–å¯¼å…¥**ï¼šæ‰€æœ‰ç±»å‹éƒ½é€šè¿‡ `use sinter_plugin_api::*;` å¯¼å…¥
- âœ… **ç»Ÿä¸€æ¥å£**ï¼šæ‰€æœ‰æ’ä»¶ä½¿ç”¨ç›¸åŒçš„ API
- âœ… **æ˜“äºç»´æŠ¤**ï¼šä¾èµ–æ›´æ–°åªéœ€æ›´æ–° API crate




/// FILE: crates/sinter-plugins/src/jsp.rs

//! JSP é¡¹ç›®ç”Ÿæˆæ’ä»¶
//!
//! è¿™ä¸ªæ–‡ä»¶å±•ç¤ºäº†å¦‚ä½•åˆ›å»ºä¸€ä¸ªç®€å•çš„æ’ä»¶ã€‚
//! åªéœ€è¦å®ç° CommandHandler trait çš„å››ä¸ªæ–¹æ³•å³å¯ï¼š
//! 1. name() - è¿”å›å‘½ä»¤åç§°
//! 2. about() - è¿”å›å‘½ä»¤æè¿°
//! 3. configure() - é…ç½®å‘½ä»¤å‚æ•°ï¼ˆå¯é€‰ï¼Œæœ‰é»˜è®¤å®ç°ï¼‰
//! 4. execute() - æ‰§è¡Œå‘½ä»¤é€»è¾‘
//!
//! æ³¨æ„ï¼šåªéœ€è¦ä¾èµ– `sinter-plugin`ï¼Œæ‰€æœ‰å¿…è¦çš„ç±»å‹éƒ½å·²é‡æ–°å¯¼å‡º

use sinter_plugin_api::*;

// åµŒå…¥æ¨¡æ¿æ–‡ä»¶
static POM_XML_TEMPLATE: &str = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/pom.xml.template"));
static WEB_XML_TEMPLATE: &str = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/web.xml.template"));
static INDEX_JSP_TEMPLATE: &str = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/index.jsp.template"));

/// JSP æ’ä»¶ç»“æ„ä½“
pub struct JspPlugin;

#[async_trait]
impl CommandHandler for JspPlugin {
    /// å‘½ä»¤åç§°ï¼šç”¨æˆ·è¾“å…¥ `sinter jsp` æ—¶ä¼šè§¦å‘
    fn name(&self) -> &'static str {
        "jsp"
    }

    /// å‘½ä»¤æè¿°ï¼šæ˜¾ç¤ºåœ¨å¸®åŠ©ä¿¡æ¯ä¸­
    fn about(&self) -> &'static str {
        "Generate a new JSP project"
    }

    /// é…ç½®å‘½ä»¤å‚æ•°ï¼šå®šä¹‰ `sinter jsp <name>` ä¸­çš„å‚æ•°
    fn configure(&self, cmd: Command) -> Command {
        cmd.about(self.about()).arg(
            Arg::new("name")
                .help("Name of the JSP project")
                .required(true)
        )
    }

    /// æ‰§è¡Œå‘½ä»¤é€»è¾‘ï¼šå½“ç”¨æˆ·è¿è¡Œ `sinter jsp <name>` æ—¶è°ƒç”¨
    async fn execute(&self, matches: &ArgMatches, cwd: &PathBuf) -> AnyhowResult<()> {
        // ä»å‘½ä»¤è¡Œå‚æ•°ä¸­è·å–é¡¹ç›®åç§°
        let name = matches
            .get_one::<String>("name")
            .expect("name argument is required");

        // åˆ›å»ºé¡¹ç›®ç›®å½•
        let proj_dir = cwd.join(name);
        if proj_dir.exists() {
            println!("JSP project '{}' already exists", name);
            return Ok(());
        }

        // åˆ›å»ºç›®å½•ç»“æ„
        fs::create_dir_all(proj_dir.join("src/main/webapp/WEB-INF")).await?;
        fs::create_dir_all(proj_dir.join("src/main/java")).await?;
        fs::create_dir_all(proj_dir.join("src/main/resources")).await?;

        // ç”Ÿæˆ pom.xml
        let pom_xml = POM_XML_TEMPLATE.replace("{{name}}", name);
        fs::write(proj_dir.join("pom.xml"), pom_xml).await?;

        // ç”Ÿæˆ web.xml
        fs::write(proj_dir.join("src/main/webapp/WEB-INF/web.xml"), WEB_XML_TEMPLATE).await?;

        // ç”Ÿæˆ index.jsp
        fs::write(proj_dir.join("src/main/webapp/index.jsp"), INDEX_JSP_TEMPLATE).await?;

        println!("Created JSP project '{}'", name);
        println!("To build and run:");
        println!("  cd {}", name);
        println!("  mvn clean package");
        println!("  # Deploy the generated .war file to Tomcat");

        Ok(())
    }
}

// å¯¼å‡ºæ’ä»¶å®ä¾‹åˆ›å»ºå‡½æ•°ï¼Œä¾›æ³¨å†Œä½¿ç”¨
pub fn jsp_plugin() -> JspPlugin {
    JspPlugin
}




/// FILE: crates/sinter-plugins/src/lib.rs

//! Sinter æ’ä»¶é›†åˆ
//!
//! è¿™ä¸ª crate åŒ…å« Sinter çš„æ‰©å±•æ’ä»¶ã€‚
//! æ‰€æœ‰æ’ä»¶éƒ½å®ç° `sinter::CommandHandler` traitã€‚

pub mod jsp;

// å¯¼å‡ºæ‰€æœ‰æ’ä»¶
pub use jsp::jsp_plugin;




/// FILE: i18n.json

{
  "en": {
    "not_in_workspace": "Not in a workspace",
    "add_dep_help": "Dependency in format: group::artifact[@scala-version][:version]",
    "main_about": "A Cargo-like build tool for Scala",
    "project_already_exists": "Project '{0}' already exists",
    "test_about": "Run tests",
    "new_about": "Create a new Scala project",
    "new_name_help": "Name of the new project",
    "added_member_to_workspace": "Added member '{0}' to workspace",
    "run_about": "Run the Scala project or a specific file",
    "built_member": "Built member: {0}",
    "add_about": "Add a dependency to the project",
    "created_project": "Created project `{0}`",
    "workspace_about": "Workspace management",
    "run_file_help": "Optional .scala file to run (relative to project root)",
    "member_already_exists": "Member '{0}' already exists in workspace",
    "build_succeeded_with_deps": "Build succeeded with {0} dependencies",
    "build_about": "Build the Scala project",
    "workspace_add_path_help": "Path to the member project",
    "initialized_empty_workspace": "Initialized empty workspace in {0}",
    "added_dependency": "Added dependency: {0} = {1}",
    "main_file_not_found": "Main file not found: {0}",
    "config_file_already_exists": "project.toml already exists in this directory",
    "run_lib_help": "Force library mode (compile only)",
    "workspace_add_about": "Add a member to the workspace",
    "lib_compiled_only": "lib: {0} (compiled only)",
    "no_command_provided": "No command provided. Use --help for usage.",
    "test_file_help": "Optional test file or directory to run (relative to project root)",
    "init_about": "Initialize a new workspace"
  },
  "zh": {
    "created_project": "å·²åˆ›å»ºé¡¹ç›® `{0}`",
    "config_file_already_exists": "project.toml å·²å­˜åœ¨äºæ­¤ç›®å½•",
    "initialized_empty_workspace": "å·²åˆå§‹åŒ–ç©ºå·¥ä½œç©ºé—´äº {0}",
    "project_already_exists": "é¡¹ç›® '{0}' å·²å­˜åœ¨",
    "added_dependency": "å·²æ·»åŠ ä¾èµ–: {0} = {1}",
    "run_lib_help": "å¼ºåˆ¶åº“æ¨¡å¼ï¼ˆä»…ç¼–è¯‘ï¼‰",
    "test_file_help": "å¯é€‰çš„æµ‹è¯•æ–‡ä»¶æˆ–ç›®å½•ï¼ˆç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•ï¼‰",
    "built_member": "å·²æ„å»ºæˆå‘˜: {0}",
    "new_about": "åˆ›å»ºä¸€ä¸ªæ–°çš„Scalaé¡¹ç›®",
    "member_already_exists": "æˆå‘˜ '{0}' å·²å­˜åœ¨äºå·¥ä½œç©ºé—´",
    "run_about": "è¿è¡ŒScalaé¡¹ç›®æˆ–ç‰¹å®šæ–‡ä»¶",
    "add_about": "å‘é¡¹ç›®æ·»åŠ ä¾èµ–",
    "init_about": "åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„å·¥ä½œç©ºé—´",
    "workspace_add_about": "å‘å·¥ä½œç©ºé—´æ·»åŠ æˆå‘˜",
    "run_file_help": "å¯é€‰çš„è¦è¿è¡Œçš„.scalaæ–‡ä»¶ï¼ˆç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•ï¼‰",
    "test_about": "è¿è¡Œæµ‹è¯•",
    "main_about": "ä¸€ä¸ªç±»ä¼¼Cargoçš„Scalaæ„å»ºå·¥å…·",
    "workspace_add_path_help": "æˆå‘˜é¡¹ç›®çš„è·¯å¾„",
    "add_dep_help": "ä¾èµ–æ ¼å¼ï¼šgroup::artifact[@scala-version][:version]",
    "workspace_about": "å·¥ä½œç©ºé—´ç®¡ç†",
    "added_member_to_workspace": "å·²æ·»åŠ æˆå‘˜ '{0}' åˆ°å·¥ä½œç©ºé—´",
    "new_name_help": "æ–°é¡¹ç›®çš„åç§°",
    "build_about": "æ„å»ºScalaé¡¹ç›®",
    "lib_compiled_only": "åº“: {0} (ä»…ç¼–è¯‘)",
    "main_file_not_found": "æœªæ‰¾åˆ°ä¸»æ–‡ä»¶: {0}",
    "no_command_provided": "æœªæä¾›å‘½ä»¤ã€‚ä½¿ç”¨ --help è·å–ç”¨æ³•ã€‚",
    "build_succeeded_with_deps": "æ„å»ºæˆåŠŸï¼ŒåŒ…å« {0} ä¸ªä¾èµ–",
    "not_in_workspace": "ä¸åœ¨å·¥ä½œç©ºé—´ä¸­"
  }
}

æˆ‘æƒ³è¦ä½¿ç”¨coursierçš„apiå®Œæˆé¡¹ç›®ï¼Œè€Œä¸æ˜¯ç°åœ¨è¿™æ ·æ··ä¹±

