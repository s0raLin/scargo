use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // 告诉 Cargo 如果翻译文件改变，需要重新构建
    println!("cargo:rerun-if-changed=templates/i18n.json");
    
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let i18n_path = Path::new(&manifest_dir).join("templates/i18n.json");
    
    // 读取翻译文件
    let i18n_content = fs::read_to_string(&i18n_path)
        .expect("Failed to read i18n.json");
    
    let translations: serde_json::Value = serde_json::from_str(&i18n_content)
        .expect("Failed to parse i18n.json");
    
    // 确定当前语言（通过特性标志）
    let lang = if cfg!(feature = "lang-zh") {
        "zh"
    } else {
        "en"
    };
    
    // 获取当前语言的翻译
    let lang_translations = translations.get(lang)
        .and_then(|v| v.as_object())
        .expect(&format!("Language '{}' not found in i18n.json", lang));
    
    // 生成输出目录
    let out_dir = env::var("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir).join("i18n.rs");
    
    // 生成 Rust 代码
    let mut code = String::new();
    code.push_str("// Auto-generated i18n code - DO NOT EDIT\n");
    code.push_str("// This file is generated by build.rs\n\n");
    code.push_str("/// Get a translated string by key\n");
    code.push_str("pub fn t(key: &str) -> &'static str {\n");
    code.push_str("    match key {\n");
    
    // 为每个翻译键生成 match arm
    for (key, value) in lang_translations {
        let value_str = value.as_str().unwrap();
        // 转义字符串中的特殊字符
        let escaped = value_str
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n");
        code.push_str(&format!("        \"{}\" => \"{}\",\n", key, escaped));
    }
    
    // 如果 key 不匹配，返回一个默认消息而不是 key 本身（避免生命周期问题）
    code.push_str("        _ => \"[Translation key not found]\",\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    // 生成格式化函数
    code.push_str("/// Format a translated string with arguments\n");
    code.push_str("pub fn tf(key: &str, args: &[&str]) -> String {\n");
    code.push_str("    let template = t(key);\n");
    code.push_str("    let mut result = template.to_string();\n");
    code.push_str("    for arg in args {\n");
    code.push_str("        if result.contains(\"{}\") {\n");
    code.push_str("            result = result.replacen(\"{}\", arg, 1);\n");
    code.push_str("        } else {\n");
    code.push_str("            break;\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("    result\n");
    code.push_str("}\n");
    
    // 写入文件
    fs::write(&out_path, code)
        .expect("Failed to write generated i18n.rs");
    
    println!("cargo:warning=Generated i18n.rs for language: {}", lang);
}

